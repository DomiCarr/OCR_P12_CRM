Generated 2026-02-18 14:29:17

===============================================================================
    ./README.md
===============================================================================
# OCR_P12_CRM


===============================================================================
    ./app/controllers/auth_controller.py
===============================================================================
# app/controllers/auth_controller.py
"""
This module handles the authentication logic, integrating JWT generation
and local storage to provide persistent user sessions.
"""

from typing import Optional
from app.repositories.employee_repository import EmployeeRepository
from app.utils.auth import verify_password
from app.utils.permissions import has_permission
from app.utils.jwt_handler import create_token, decode_token
from app.utils.token_storage import save_token, get_token, delete_token


class AuthController:
    """
    Controller managing login, logout, and persistent session validation.
    """

    def __init__(self, employee_repository: EmployeeRepository):
        self.repository = employee_repository
        self.current_user_data: Optional[dict] = None

    def login(self, email: str, password: str) -> Optional[dict]:
        """
        Authenticate user and save a JWT locally if successful.
        """
        employee = self.repository.get_by_email(email)

        if employee and verify_password(employee.password, password):
            # Generate and save token locally
            token = create_token(employee.id, employee.department.name)
            save_token(token)

            # Return user data for main.py session management
            user_data = {
                "id": employee.id,
                "full_name": employee.full_name,
                "department": employee.department.name
            }
            self.current_user_data = user_data
            return user_data

        return None

    def logout(self) -> None:
        """
        Clear the session by deleting the local token.
        """
        delete_token()
        self.current_user_data = None

    def get_logged_in_user(self) -> Optional[dict]:
        """
        Validate the local token and return user data if still valid.
        """
        token = get_token()
        if not token:
            return None

        payload = decode_token(token)
        if payload:
            self.current_user_data = payload
            return payload

        # Token expired or invalid
        delete_token()
        return None

    def check_user_permission(self, action: str) -> bool:
        """
        Check permission based on the department stored in the JWT.
        """
        user = self.get_logged_in_user()
        if not user:
            return False

        return has_permission(action, user["department"])

===============================================================================
    ./app/controllers/client_controller.py
===============================================================================
# app/controllers/client_controller.py
"""
Controller handling business logic for Client management.
Ensures authentication and permission checks before data access.
"""

from app.repositories.client_repository import ClientRepository
from app.utils.decorators import require_auth


class ClientController:
    """Manages client-related operations."""

    def __init__(self, repository: ClientRepository, auth_controller):
        self.repository = repository
        self.auth_controller = auth_controller

    @require_auth
    def list_all_clients(self, user_data: dict):
        """
        Fetch all clients if the user has the 'read' permission.
        """
        if self.auth_controller.check_user_permission("read_client"):
            return self.repository.get_all_clients()
        return None

===============================================================================
    ./app/controllers/contract_controller.py
===============================================================================
# app/controllers/contract_controller.py
"""
Controller handling business logic for Contract management.
"""

from app.repositories.contract_repository import ContractRepository
from app.utils.decorators import require_auth


class ContractController:
    """Manages contract-related operations."""

    def __init__(self, repository: ContractRepository, auth_controller):
        self.repository = repository
        self.auth_controller = auth_controller

    @require_auth
    def list_all_contracts(self, user_data: dict):
        """
        Fetch all contracts if allowed.
        """
        if self.auth_controller.check_user_permission("read_contract"):
            return self.repository.get_all_contracts()
        return None

===============================================================================
    ./app/controllers/event_controller.py
===============================================================================
# app/controllers/event_controller.py
"""
Controller handling business logic for Event management.
"""

from app.repositories.event_repository import EventRepository
from app.utils.decorators import require_auth


class EventController:
    """Manages event-related operations."""

    def __init__(self, repository: EventRepository, auth_controller):
        self.repository = repository
        self.auth_controller = auth_controller

    @require_auth
    def list_all_events(self, user_data: dict):
        """
        Fetch all events if allowed.
        """
        if self.auth_controller.check_user_permission("read_event"):
            return self.repository.get_all_events()
        return None

===============================================================================
    ./app/models/__init__.py
===============================================================================
# app/models/__init__.py
"""
This module centralizes all SQLAlchemy models to facilitate imports
and ensure they are registered with the Base metadata for migrations.
"""

from app.models.base import Base
from app.models.department import Department
from app.models.employee import Employee
from app.models.client import Client
from app.models.contract import Contract
from app.models.event import Event

__all__ = [
    "Base",
    "Department",
    "Employee",
    "Client",
    "Contract",
    "Event"
]

===============================================================================
    ./app/models/base.py
===============================================================================
# app/models/base.py
"""
This module serves as the foundation for the ORM layer.
- Provides a centralized DeclarativeBase for model registration.
- Defines custom type aliases (Annotated) to standardize SQL constraints
  (String lengths, Primary Keys, and Timestamps) across the entire schema.
- Uses server-side functions for automated audit trails (created_at, updated_at).
"""
import datetime
from typing import Annotated
from sqlalchemy import String, Text, func
from sqlalchemy.orm import DeclarativeBase, mapped_column


# Type aliases to ensure consistency across all models
# Primary keys with auto-increment
pk_id = Annotated[int, mapped_column(primary_key=True, autoincrement=True)]

# Standard string lengths for database columns
str_20 = Annotated[str, mapped_column(String(20))]
str_50 = Annotated[str, mapped_column(String(50))]
str_100 = Annotated[str, mapped_column(String(100))]
str_255 = Annotated[str, mapped_column(String(255))]

# Long text for descriptions or notes
text_type = Annotated[str, mapped_column(Text)]

# Automatically managed timestamps
timestamp_now = Annotated[
    datetime.datetime,
    mapped_column(server_default=func.now())
]
timestamp_update = Annotated[
    datetime.datetime,
    mapped_column(server_default=func.now(), onupdate=func.now())
]


class Base(DeclarativeBase):
    """
    Base class for declarative models.
    Maintains a registry of all mapped classes.
    """
    pass

===============================================================================
    ./app/models/client.py
===============================================================================
# app/models/client.py
"""
This module defines the Client model, which stores customer information,
contact details, and handles relationships with sales employees,
contracts, and events.
"""

from typing import TYPE_CHECKING
from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import (
    Base,
    pk_id,
    str_50,
    str_100,
    str_20,
    timestamp_now,
    timestamp_update
)

if TYPE_CHECKING:
    from app.models.employee import Employee
    from app.models.event import Event
    from app.models.contract import Contract


class Client(Base):
    """
    Represents a customer in the CRM system.
    """

    __tablename__ = "client"

    id: Mapped[pk_id]
    full_name: Mapped[str_50]
    email: Mapped[str_100] = mapped_column(unique=True)
    phone: Mapped[str_20]
    company_name: Mapped[str_50]

    # Audit timestamps
    created_at: Mapped[timestamp_now]
    last_update: Mapped[timestamp_update]

    # Foreign Key to the Sales Contact (Employee)
    sales_contact_id: Mapped[int] = mapped_column(
        ForeignKey("employee.id")
    )

    # Relationships
    sales_contact: Mapped["Employee"] = relationship(
        back_populates="managed_clients"
    )
    contracts: Mapped[list["Contract"]] = relationship(
        back_populates="client"
    )
    events: Mapped[list["Event"]] = relationship(
        back_populates="client"
    )

    def __repr__(self) -> str:
        return (
            f"<Client(name={self.full_name}, "
            f"company={self.company_name})>"
        )

===============================================================================
    ./app/models/contract.py
===============================================================================
# app/models/contract.py
"""
This module defines the Contract model, which stores financial agreements
with clients, including amounts, payment status, and audit timestamps.
"""

from typing import TYPE_CHECKING
from sqlalchemy import ForeignKey, Boolean, Numeric
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import (
    Base,
    pk_id,
    timestamp_now,
    timestamp_update
)

if TYPE_CHECKING:
    from app.models.client import Client
    from app.models.event import Event


class Contract(Base):
    """
    Represents a financial agreement with a client.
    """

    __tablename__ = "contract"

    id: Mapped[pk_id]
    total_amount: Mapped[float] = mapped_column(Numeric(10, 2))
    remaining_amount: Mapped[float] = mapped_column(Numeric(10, 2))
    status: Mapped[bool] = mapped_column(Boolean, default=False)

    # Audit timestamps
    created_at: Mapped[timestamp_now]
    last_update: Mapped[timestamp_update]

    # Foreign Keys
    client_id: Mapped[int] = mapped_column(ForeignKey("client.id"))

    # Relationships
    client: Mapped["Client"] = relationship(back_populates="contracts")
    event: Mapped["Event"] = relationship(back_populates="contract")

    def __repr__(self) -> str:
        return (
            f"<Contract(id={self.id}, "
            f"remaining={self.remaining_amount}, "
            f"signed={self.status})>"
        )

===============================================================================
    ./app/models/department.py
===============================================================================
# app/models/department.py
"""
This module defines the Department model, which represents the different
business units within the company and manages their relationship with employees.
"""

from typing import TYPE_CHECKING
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import Base, pk_id, str_50

if TYPE_CHECKING:
    from app.models.employee import Employee


class Department(Base):
    """
    Represents a business unit (MANAGEMENT, SALES, or SUPPORT).
    """

    __tablename__ = "department"

    id: Mapped[pk_id]
    name: Mapped[str_50] = mapped_column(unique=True)

    # Relationships
    employees: Mapped[list["Employee"]] = relationship(
        back_populates="department"
    )

    def __repr__(self) -> str:
        return f"<Department(name={self.name})>"

===============================================================================
    ./app/models/employee.py
===============================================================================
# app/models/employee.py
"""
This module defines the Employee model, which stores staff member information,
credentials, and their association with departments and managed entities
such as clients and events.
"""

from typing import TYPE_CHECKING
from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import Base, pk_id, str_50, str_100, str_255, str_20

if TYPE_CHECKING:
    from app.models.department import Department
    from app.models.client import Client
    from app.models.event import Event


class Employee(Base):
    """
    Represents a staff member of Epic Events.
    """

    __tablename__ = "employee"

    id: Mapped[pk_id]
    full_name: Mapped[str_50]
    email: Mapped[str_100] = mapped_column(unique=True)
    password: Mapped[str_255]
    employee_number: Mapped[str_20] = mapped_column(unique=True)

    # Foreign Key to Department
    department_id: Mapped[int] = mapped_column(ForeignKey("department.id"))

    # Relationships
    department: Mapped["Department"] = relationship(back_populates="employees")

    # Managed entities (Sales/Support roles)
    managed_clients: Mapped[list["Client"]] = relationship(
        back_populates="sales_contact"
    )
    assigned_events: Mapped[list["Event"]] = relationship(
        back_populates="support_contact"
    )

    def __repr__(self) -> str:
        return (
            f"<Employee(name={self.full_name}, "
            f"department_id={self.department_id})>"
        )

===============================================================================
    ./app/models/event.py
===============================================================================
# app/models/event.py
"""
This module defines the Event model, representing a scheduled event
linked to a client, a contract, and potentially a support employee.
"""

from typing import TYPE_CHECKING, Optional
from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import (
    Base,
    pk_id,
    str_50,
    text_type,
    timestamp_now,
    timestamp_update
)

if TYPE_CHECKING:
    from app.models.client import Client
    from app.models.employee import Employee
    from app.models.contract import Contract


class Event(Base):
    """
    Represents a scheduled event for a specific client and contract.
    """

    __tablename__ = "event"

    id: Mapped[pk_id]
    name: Mapped[str_50]
    event_date: Mapped[timestamp_now]
    location: Mapped[str_50]
    attendees: Mapped[int]
    notes: Mapped[text_type]

    # Audit timestamps
    created_at: Mapped[timestamp_now]
    last_update: Mapped[timestamp_update]

    # Foreign Keys
    client_id: Mapped[int] = mapped_column(ForeignKey("client.id"))
    contract_id: Mapped[int] = mapped_column(ForeignKey("contract.id"))
    support_contact_id: Mapped[Optional[int]] = mapped_column(
        ForeignKey("employee.id"), nullable=True
    )

    # Relationships
    client: Mapped["Client"] = relationship(back_populates="events")
    contract: Mapped["Contract"] = relationship(back_populates="event")
    support_contact: Mapped["Employee"] = relationship(
        back_populates="assigned_events"
    )

    def __repr__(self) -> str:
        return f"<Event(name={self.name}, date={self.event_date})>"

===============================================================================
    ./app/repositories/base_repository.py
===============================================================================
# app/repositories/base_repository.py
"""
This module defines the BaseRepository class using Generics.
It provides a standardized interface for common database operations (CRUD)
shared across all specific repositories.
"""

from typing import Generic, TypeVar, Type, Optional, List
from sqlalchemy.orm import Session
from app.models.base import Base

T = TypeVar("T", bound=Base)


class BaseRepository(Generic[T]):
    """
    Base class for data access logic.
    """

    def __init__(self, session: Session, model: Type[T]):
        self.session = session
        self.model = model

    def get_by_id(self, obj_id: int) -> Optional[T]:
        """Fetch a single record by its primary key."""
        return self.session.query(self.model).filter(
            self.model.id == obj_id
        ).first()

    def get_all(self) -> List[T]:
        """Fetch all records for this model."""
        return self.session.query(self.model).all()

    def add(self, obj: T) -> None:
        """Add a new object to the session."""
        self.session.add(obj)

    def delete(self, obj: T) -> None:
        """Remove an object from the session."""
        self.session.delete(obj)

===============================================================================
    ./app/repositories/client_repository.py
===============================================================================
# app/repositories/client_repository.py
"""
Data access layer for Client-specific operations.
"""

from sqlalchemy.orm import Session
from app.models.client import Client
from app.repositories.base_repository import BaseRepository


class ClientRepository(BaseRepository[Client]):
    """
    Repository handling Client database queries.
    """

    def __init__(self, session: Session):
        super().__init__(session, Client)

    def get_by_email(self, email: str):
        """
        Fetch a client by its unique email.
        """
        return self.session.query(self.model).filter(
            self.model.email == email
        ).first()

===============================================================================
    ./app/repositories/contract_repository.py
===============================================================================
# app/repositories/contract_repository.py
"""
Data access layer for Contract-specific operations.
"""

from sqlalchemy.orm import Session
from app.models.contract import Contract
from app.repositories.base_repository import BaseRepository


class ContractRepository(BaseRepository[Contract]):
    """
    Repository handling Contract database queries.
    """

    def __init__(self, session: Session):
        super().__init__(session, Contract)


===============================================================================
    ./app/repositories/employee_repository.py
===============================================================================
# app/repositories/employee_repository.py
"""
This module specializes the BaseRepository for the Employee model.
It provides specific lookup methods necessary for authentication
and staff management.
"""

from typing import Optional
from sqlalchemy.orm import Session
from app.models.employee import Employee
from app.repositories.base_repository import BaseRepository


class EmployeeRepository(BaseRepository[Employee]):
    """
    Data access layer for Employee-specific operations.
    """

    def __init__(self, session: Session):
        super().__init__(session, Employee)

    def get_by_email(self, email: str) -> Optional[Employee]:
        """
        Fetch an employee by their unique email address.
        Used for authentication.
        """
        return self.session.query(self.model).filter(
            self.model.email == email
        ).first()

    def get_by_employee_number(self, emp_number: str) -> Optional[Employee]:
        """
        Fetch an employee by their unique employee number.
        """
        return self.session.query(self.model).filter(
            self.model.employee_number == emp_number
        ).first()

===============================================================================
    ./app/repositories/event_repository.py
===============================================================================
# app/repositories/event_repository.py
"""
Data access layer for Event-specific operations.
"""

from sqlalchemy.orm import Session
from app.models.event import Event
from app.repositories.base_repository import BaseRepository


class EventRepository(BaseRepository[Event]):
    """
    Repository handling Event database queries.
    """

    def __init__(self, session: Session):
        super().__init__(session, Event)

===============================================================================
    ./app/utils/auth.py
===============================================================================
# app/utils/auth.py
"""
This module handles secure password management using the Argon2 hashing
algorithm. It provides utilities for hashing plain text passwords and
verifying them against stored hashes.
"""

from argon2 import PasswordHasher
from argon2.exceptions import VerifyMismatchError, InvalidHashError

# Initialize the hasher with default secure parameters
ph = PasswordHasher()


def hash_password(password: str) -> str:
    """
    Hash a password using Argon2.
    """
    return ph.hash(password)


def verify_password(hashed_password: str, plain_password: str) -> bool:
    """
    Verify a password against its Argon2 hash.
    """
    try:
        return ph.verify(hashed_password, plain_password)
    except (VerifyMismatchError, InvalidHashError):
        return False

===============================================================================
    ./app/utils/decorators.py
===============================================================================
# app/utils/decorators.py
"""
This module provides decorators to enforce authentication and authorization
checks on controller methods or CLI commands.
"""

from functools import wraps
from typing import Callable, Any
from app.utils.token_storage import get_token
from app.utils.jwt_handler import decode_token


def require_auth(func: Callable) -> Callable:
    """
    Decorator to ensure a user is authenticated before executing a command.
    It reads and validates the local JWT token.
    """
    @wraps(func)
    def wrapper(*args, **kwargs) -> Any:
        token = get_token()
        if not token:
            print("[Error] You must be logged in to perform this action.")
            return None

        user_data = decode_token(token)
        if not user_data:
            print("[Error] Session expired or invalid. Please login again.")
            return None

        # Pass user data as an argument to the decorated function
        return func(user_data=user_data, *args, **kwargs)

    return wrapper

===============================================================================
    ./app/utils/jwt_handler.py
===============================================================================
# app/utils/jwt_handler.py
"""
This module handles JSON Web Token (JWT) generation and validation.
It ensures that user sessions are persistent, secure, and include
expiration logic as required by the technical specifications.
"""

import os
import datetime
from typing import Optional
import jwt


# Configuration from environment variables
SECRET_KEY = os.getenv("JWT_SECRET", "default-secret-key-to-change")
ALGORITHM = os.getenv("JWT_ALGORITHM", "HS256")
TOKEN_EXPIRATION_HOURS = 12


def create_token(employee_id: int, department_name: str) -> str:
    """
    Generate a JWT token containing employee ID and department.
    The token is set to expire in 12 hours.
    """
    payload = {
        "sub": employee_id,
        "department": department_name,
        "iat": datetime.datetime.utcnow(),
        "exp": (
            datetime.datetime.utcnow() +
            datetime.timedelta(hours=TOKEN_EXPIRATION_HOURS)
        )
    }
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)


def decode_token(token: str) -> Optional[dict]:
    """
    Decode and validate a JWT token.
    Returns the payload if valid, or None if expired/invalid.
    """
    try:
        return jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    except (jwt.ExpiredSignatureError, jwt.InvalidTokenError):
        return None

===============================================================================
    ./app/utils/permissions.py
===============================================================================
# app/utils/permissions.py
"""
This module provides a centralized authorization system using an
Access Control Matrix (ACM). It maps specific actions to departments
to determine user permissions across the application.
"""

from enum import Enum


class DepartmentName(Enum):
    """Enumeration of existing departments."""

    MANAGEMENT = "MANAGEMENT"
    SALES = "SALES"
    SUPPORT = "SUPPORT"


# The Permission Matrix: (Action, Department)
# Use a set for O(1) lookups and clear mapping.
PERMISSION_MATRIX = {
    ("manage_employees", DepartmentName.MANAGEMENT.value),
    ("manage_contracts", DepartmentName.MANAGEMENT.value),
    ("manage_contracts", DepartmentName.SALES.value),
    ("update_events", DepartmentName.MANAGEMENT.value),
    ("update_events", DepartmentName.SUPPORT.value),
}


def has_permission(action: str, department_name: str) -> bool:
    """
    Check if a specific couple (action, department) exists in the matrix.
    """
    return (action, department_name) in PERMISSION_MATRIX

===============================================================================
    ./app/utils/token_storage.py
===============================================================================
# app/utils/token_storage.py
"""
This module manages the local persistence of the JWT token.
It provides functions to save, retrieve, and delete the token from
a local file to maintain user sessions across CLI executions.
"""

import os
from typing import Optional

TOKEN_FILE = ".token"


def save_token(token: str) -> None:
    """
    Save the JWT token to a local hidden file.
    """
    with open(TOKEN_FILE, "w", encoding="utf-8") as f:
        f.write(token)


def get_token() -> Optional[str]:
    """
    Retrieve the JWT token from the local file if it exists.
    """
    if os.path.exists(TOKEN_FILE):
        with open(TOKEN_FILE, "r", encoding="utf-8") as f:
            return f.read().strip()
    return None


def delete_token() -> None:
    """
    Remove the local token file to log out the user.
    """
    if os.path.exists(TOKEN_FILE):
        os.remove(TOKEN_FILE)

===============================================================================
    ./app/views/auth_view.py
===============================================================================
# app/views/auth_view.py
"""
View for authentication related interactions.
Handles login inputs and success/failure messages.
"""

from app.views.base_view import BaseView


class AuthView(BaseView):
    """Handles login inputs."""

    def ask_login_details(self) -> tuple[str, str]:
        """Prompt user for email and password."""
        print("\n=== Epic Events CRM - Login ===")
        email = self.ask_input("Email")
        password = self.ask_input("Password")
        return email, password

    def display_login_success(self):
        """Confirm successful login."""
        self.display_message("Login successful! Welcome.")

    def display_login_failure(self):
        """Warn about failed credentials."""
        self.display_error("Invalid email or password.")

===============================================================================
    ./app/views/base_view.py
===============================================================================
# app/views/base_view.py
"""
Base class for all views in the application.
Provides common display methods for CLI interaction.
"""


class BaseView:
    """Provides common display methods for CLI interaction."""

    def display_message(self, message: str):
        """Display a simple text message."""
        print(f"\n{message}")

    def display_error(self, message: str):
        """Display an error message formatted for visibility."""
        print(f"\n[ERROR] {message}")

    def ask_input(self, prompt: str) -> str:
        """Helper to get user input."""
        return input(f"{prompt}: ").strip()

===============================================================================
    ./app/views/client_view.py
===============================================================================
# app/views/client_view.py
"""
View for Client related interactions.
"""
from app.views.base_view import BaseView


class ClientView(BaseView):
    """Handles client display and inputs."""

    def display_clients(self, clients: list):
        """Print the list of all clients."""
        print("\n=== Clients List ===")
        if not clients:
            print("No clients found.")
            return
        for client in clients:
            print(
                f"ID: {client.id} | Name: {client.full_name} | "
                f"Email: {client.email} | Company: {client.company_name}"
            )

    def ask_client_details(self) -> dict:
        """Prompt user for new client information."""
        print("\n=== Add New Client ===")
        return {
            "full_name": self.ask_input("Full Name"),
            "email": self.ask_input("Email"),
            "phone": self.ask_input("Phone"),
            "company_name": self.ask_input("Company Name")
        }

===============================================================================
    ./app/views/contract_view.py
===============================================================================
# app/views/contract_view.py
"""
View for Contract related interactions.
"""
from app.views.base_view import BaseView


class ContractView(BaseView):
    """Handles contract display and inputs."""

    def display_contracts(self, contracts: list):
        """Print the list of all contracts."""
        print("\n=== Contracts List ===")
        if not contracts:
            print("No contracts found.")
            return
        for contract in contracts:
            status = "Signed" if contract.is_signed else "Not Signed"
            print(
                f"ID: {contract.id} | Client: {contract.client.full_name} | "
                f"Total Amount: {contract.total_amount} | Status: {status}"
            )

===============================================================================
    ./app/views/event_view.py
===============================================================================
# app/views/event_view.py
"""
View for Event related interactions.
"""
from app.views.base_view import BaseView


class EventView(BaseView):
    """Handles event display and inputs."""

    def display_events(self, events: list):
        """Print the list of all events."""
        print("\n=== Events List ===")
        if not events:
            print("No events found.")
            return
        for event in events:
            support = event.support_contact.full_name if event.support_contact else "TBD"
            print(
                f"ID: {event.id} | Name: {event.name} | "
                f"Date: {event.event_date_start} | Support: {support}"
            )

===============================================================================
    ./app/views/main_menu_view.py
===============================================================================
# app/views/main_menu_view.py
"""
Main menu view for the CRM application.
Adapts displayed options based on user department.
"""

from app.views.base_view import BaseView


class MainMenuView(BaseView):
    """Controller view for the main menu."""

    def display_menu(self, department: str):
        """Print the main menu options according to department."""
        print(f"\n=== Epic Events CRM - {department} Menu ===")
        print("1. List all clients")
        print("2. List all contracts")
        print("3. List all events")

        if department == "MANAGEMENT":
            print("10. Manage employees (Admin)")
        elif department == "SALES":
            print("20. Create new client")
        elif department == "SUPPORT":
            print("30. Update my events")

        print("0. Logout and Exit")

    def ask_menu_option(self) -> str:
        """Ask the user for a menu option."""
        return input("\nSelect an option: ").strip()

===============================================================================
    ./check_auth.py
===============================================================================
# check_auth.py
from app.utils.auth import hash_password, verify_password

password_to_test = "admin123"
# Le hash exact que vous avez mis dans le SQL
sql_hash = "$argon2id$v=19$m=65536,t=3,p=4$7Y5Wp8W1S6lF6z1N2q9Q5w$O7N8/v5J8J8"

# 1. Test de vérification
is_valid = verify_password(password_to_test, sql_hash)
print(f"Match SQL hash: {is_valid}")

# 2. Test de génération
new_hash = hash_password(password_to_test)
print(f"New hash generated: {new_hash}")
print(f"Match new hash: {verify_password(password_to_test, new_hash)}")

===============================================================================
    ./config/config.py
===============================================================================
# config/config.py
import os
from dotenv import load_dotenv

# Load variables from .env file
load_dotenv()


class Config:
    """Configuration loader for environment variables."""
    DB_USER = os.getenv("DB_USER")
    DB_PASSWORD = os.getenv("DB_PASSWORD")
    DB_HOST = os.getenv("DB_HOST")
    DB_PORT = os.getenv("DB_PORT")
    DB_NAME = os.getenv("DB_NAME")
    SECRET_KEY = os.getenv("SECRET_KEY")

    @classmethod
    def get_db_url(cls):
        """Return formatted SQLAlchemy database URL."""
        return (
            f"mysql+mysqlconnector://{cls.DB_USER}:{cls.DB_PASSWORD}@"
            f"{cls.DB_HOST}:{cls.DB_PORT}/{cls.DB_NAME}"
        )

===============================================================================
    ./init_db.py
===============================================================================
# init_db.py
from sqlalchemy import create_engine
from app.models import Base
from config.config import Config


def create_tables():
    """
    Creates all database tables defined in the models.
    """
    engine = create_engine(Config.get_db_url())

    print("Connecting to the database...")
    try:
        # Create all tables stored in the metadata
        Base.metadata.create_all(engine)
        print("Success: All tables created successfully.")
    except Exception as e:
        print(f"Error during table creation: {e}")


if __name__ == "__main__":
    create_tables()

===============================================================================
    ./main.py
===============================================================================
# main.py
"""
Entry point for the Epic Events CRM application.
Manages the main loop and coordinate between controllers and views.
"""

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from config.config import Config

from app.repositories.employee_repository import EmployeeRepository
from app.repositories.client_repository import ClientRepository
from app.repositories.contract_repository import ContractRepository
from app.repositories.event_repository import EventRepository

from app.controllers.auth_controller import AuthController
from app.controllers.client_controller import ClientController
from app.controllers.contract_controller import ContractController
from app.controllers.event_controller import EventController

from app.views.auth_view import AuthView
from app.views.main_menu_view import MainMenuView
from app.views.client_view import ClientView
from app.views.contract_view import ContractView
from app.views.event_view import EventView


def main():
    """Main application execution logic."""
    # Database Setup
    engine = create_engine(Config.get_db_url())
    session_factory = sessionmaker(bind=engine)
    session = session_factory()

    # Initialize Repositories
    emp_repo = EmployeeRepository(session)
    client_repo = ClientRepository(session)
    contract_repo = ContractRepository(session)
    event_repo = EventRepository(session)

    # Initialize Controllers
    auth_ctrl = AuthController(emp_repo)
    client_ctrl = ClientController(client_repo, auth_ctrl)
    contract_ctrl = ContractController(contract_repo, auth_ctrl)
    event_ctrl = EventController(event_repo, auth_ctrl)

    # Initialize Views
    auth_view = AuthView()
    menu_view = MainMenuView()
    client_view = ClientView()
    contract_view = ContractView()
    event_view = EventView()

    # 1. Authentication Check
    user_data = auth_ctrl.get_logged_in_user()
    if not user_data:
        email, password = auth_view.ask_login_details()
        # Capture user_data directly from login()
        user_data = auth_ctrl.login(email, password)
        if not user_data:
            auth_view.display_login_failure()
            return

    auth_view.display_login_success()

    # 2. Application Loop
    while True:
        menu_view.display_menu(user_data["department"])
        choice = menu_view.ask_menu_option()

        if choice == "1":
            data = client_ctrl.list_all_clients()
            client_view.display_clients(data)
        elif choice == "2":
            data = contract_ctrl.list_all_contracts()
            contract_view.display_contracts(data)
        elif choice == "3":
            data = event_ctrl.list_all_events()
            event_view.display_events(data)
        elif choice == "0":
            auth_ctrl.logout()
            print("Goodbye!")
            break
        else:
            print("Invalid option. Please try again.")


if __name__ == "__main__":
    main()

