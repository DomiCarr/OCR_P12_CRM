Generated 2026-02-19 17:59:50

===============================================================================
    ./.pytest_cache/README.md
===============================================================================
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.


===============================================================================
    ./README.md
===============================================================================
# OCR_P12_CRM


===============================================================================
    ./app/controllers/auth_controller.py
===============================================================================
# app/controllers/auth_controller.py
"""
This module handles the authentication logic, integrating JWT generation
and local storage to provide persistent user sessions.
"""

from typing import Optional
import sentry_sdk
from app.repositories.employee_repository import EmployeeRepository
from app.utils.auth import verify_password
from app.utils.permissions import has_permission
from app.utils.jwt_handler import create_token, decode_token
from app.utils.token_storage import save_token, get_token, delete_token


class AuthController:
    """
    Controller managing login, logout, and persistent session validation.
    """

    def __init__(self, employee_repository: EmployeeRepository):
        self.repository = employee_repository
        self.current_user_data: Optional[dict] = None

    def login(self, email: str, password: str) -> Optional[dict]:
        """
        Authenticate user and save a JWT locally if successful.
        """
        employee = self.repository.get_by_email(email)

        if employee and verify_password(employee.password, password):
            # Generate and save token locally
            token = create_token(employee.id, employee.department.name)
            save_token(token)

            # Return user data for main.py session management
            user_data = {
                "id": employee.id,
                "full_name": employee.full_name,
                "department": employee.department.name
            }

            # Attach user identity to Sentry scope for error tracking
            sentry_sdk.set_user({
                "id": str(employee.id),
                "username": employee.full_name,
                "department": employee.department.name
            })

            self.current_user_data = user_data
            return user_data

        return None

    def logout(self) -> None:
        """
        Clear the session by deleting the local token.
        """
        delete_token()
        # Clear Sentry user context to avoid cross-user error reporting
        sentry_sdk.set_user(None)
        self.current_user_data = None

    def get_logged_in_user(self) -> Optional[dict]:
        """
        Validate the local token and return user data if still valid.
        """
        token = get_token()
        if not token:
            return None

        payload = decode_token(token)
        if payload:
            # Restore Sentry user identity for persistent sessions
            sentry_sdk.set_user({
                "id": str(payload.get("id")),
                "department": payload.get("department")
            })
            self.current_user_data = payload
            return payload

        # Token expired or invalid
        delete_token()
        return None

    def check_user_permission(self, action: str) -> bool:
        """
        Check if the currently logged-in user has permission for an action.
        """
        if not self.current_user_data:
            return False

        dept = self.current_user_data.get("department")
        return has_permission(action, dept)

===============================================================================
    ./app/controllers/client_controller.py
===============================================================================
# app/controllers/client_controller.py
"""
Controller handling business logic for Client management.
Ensures authentication and permission checks before data access.
"""

from datetime import datetime
from app.repositories.client_repository import ClientRepository
from app.utils.decorators import require_auth


class ClientController:
    """Manages client-related operations."""

    def __init__(self, repository: ClientRepository, auth_controller):
        self.repository = repository
        self.auth_controller = auth_controller

    @require_auth
    def list_all_clients(self, user_data: dict):
        """Fetch all clients if the user has the 'read_client' permission."""
        self.auth_controller.current_user_data = user_data
        permission = "read_client"
        if self.auth_controller.check_user_permission(permission):
            return self.repository.get_all_clients()
        return []

    @require_auth
    def create_client(self, user_data: dict, client_data: dict):
        """Create a new client and associate with the current sales person."""
        self.auth_controller.current_user_data = user_data
        if self.auth_controller.check_user_permission("create_client"):
            # Set sales_contact_id from the current logged-in user
            client_data["sales_contact_id"] = user_data["id"]

            # Set last_contact to now if not provided
            if not client_data.get("last_contact"):
                client_data["last_contact"] = datetime.now()

            new_client = self.repository.add_client(client_data)
            print(f"Client '{new_client.full_name}' created successfully.")
            return new_client
        print("Access denied: You do not have permission to create a client.")
        return None

===============================================================================
    ./app/controllers/contract_controller.py
===============================================================================
# app/controllers/contract_controller.py
"""
Controller handling business logic for Contract management.
"""

from app.repositories.contract_repository import ContractRepository
from app.utils.decorators import require_auth


class ContractController:
    """Manages contract-related operations."""

    def __init__(self, repository: ContractRepository, auth_controller):
        self.repository = repository
        self.auth_controller = auth_controller

    @require_auth
    def list_all_contracts(self, user_data: dict):
        """
        Fetch all contracts if allowed.
        """
        self.auth_controller.current_user_data = user_data
        if self.auth_controller.check_user_permission("read_contract"):
            return self.repository.get_all_contracts()
        return None

===============================================================================
    ./app/controllers/employee_controller.py
===============================================================================
# app/controllers/employee_controller.py
"""
Controller handling business logic for Employee management.
"""

from app.models.employee import Employee
from app.repositories.employee_repository import EmployeeRepository
from app.utils.decorators import require_auth
from app.utils.auth import hash_password


class EmployeeController:
    """Manages employee-related operations."""

    def __init__(self, repository: EmployeeRepository, auth_controller):
        self.repository = repository
        self.auth_controller = auth_controller

    @require_auth
    def list_all_employees(self, user_data: dict):
        """
        Fetch all employees if the user has the 'read_employee' permission.
        """
        self.auth_controller.current_user_data = user_data

        if self.auth_controller.check_user_permission("read_employee"):
            return self.repository.get_all()

        return []

    @require_auth
    def create_employee(self, user_data: dict, employee_data: dict):
        """
        Create a new employee after permission check and password hashing.
        """
        self.auth_controller.current_user_data = user_data

        if not self.auth_controller.check_user_permission("create_employee"):
            return None

        # Hash the password before storage
        employee_data["password"] = hash_password(employee_data["password"])

        # Create the instance
        new_employee = Employee(**employee_data)

        # Pass the instance (not the dict) to the repository
        created_employee = self.repository.add(new_employee)
        return created_employee

    @require_auth
    def update_employee(self, user_data: dict, emp_id: int, update_data: dict):
        """
        Update an existing employee's data.
        """
        self.auth_controller.current_user_data = user_data

        if not self.auth_controller.check_user_permission("update_employee"):
            return None

        if "password" in update_data:
            update_data["password"] = hash_password(update_data["password"])

        updated_emp = self.repository.update(emp_id, update_data)
        return updated_emp

===============================================================================
    ./app/controllers/event_controller.py
===============================================================================
# app/controllers/event_controller.py
"""
Controller handling business logic for Event management.
"""

from app.repositories.event_repository import EventRepository
from app.utils.decorators import require_auth


class EventController:
    """Manages event-related operations."""

    def __init__(self, repository: EventRepository, auth_controller):
        self.repository = repository
        self.auth_controller = auth_controller

    @require_auth
    def list_all_events(self, user_data: dict):
        """
        Fetch all events if allowed.
        """
        self.auth_controller.current_user_data = user_data
        if self.auth_controller.check_user_permission("read_event"):
            return self.repository.get_all_events()
        return None

===============================================================================
    ./app/models/__init__.py
===============================================================================
# app/models/__init__.py
"""
This module centralizes all SQLAlchemy models to facilitate imports
and ensure they are registered with the Base metadata for migrations.
"""

from app.models.base import Base
from app.models.department import Department
from app.models.employee import Employee
from app.models.client import Client
from app.models.contract import Contract
from app.models.event import Event

__all__ = [
    "Base",
    "Department",
    "Employee",
    "Client",
    "Contract",
    "Event"
]

===============================================================================
    ./app/models/base.py
===============================================================================
# app/models/base.py
"""
This module serves as the foundation for the ORM layer.
- Provides a centralized DeclarativeBase for model registration.
- Defines custom type aliases (Annotated) to standardize SQL constraints
  (String lengths, Primary Keys, and Timestamps) across the entire schema.
- Uses server-side functions for automated audit trails (created_at, updated_at).
"""
import datetime
from typing import Annotated
from sqlalchemy import String, Text, func
from sqlalchemy.orm import DeclarativeBase, mapped_column


# Type aliases to ensure consistency across all models
# Primary keys with auto-increment
pk_id = Annotated[int, mapped_column(primary_key=True, autoincrement=True)]

# Standard string lengths for database columns
str_20 = Annotated[str, mapped_column(String(20))]
str_50 = Annotated[str, mapped_column(String(50))]
str_100 = Annotated[str, mapped_column(String(100))]
str_255 = Annotated[str, mapped_column(String(255))]

# Long text for descriptions or notes
text_type = Annotated[str, mapped_column(Text)]

# Automatically managed timestamps
timestamp_now = Annotated[
    datetime.datetime,
    mapped_column(server_default=func.now())
]
timestamp_update = Annotated[
    datetime.datetime,
    mapped_column(server_default=func.now(), onupdate=func.now())
]


class Base(DeclarativeBase):
    """
    Base class for declarative models.
    Maintains a registry of all mapped classes.
    """
    pass

===============================================================================
    ./app/models/client.py
===============================================================================
# app/models/client.py
"""
This module defines the Client model, which stores customer information,
contact details, and handles relationships with sales employees,
contracts, and events.
"""

from typing import TYPE_CHECKING
from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import (
    Base,
    pk_id,
    str_50,
    str_100,
    str_20,
    timestamp_now,
    timestamp_update
)

if TYPE_CHECKING:
    from app.models.employee import Employee
    from app.models.event import Event
    from app.models.contract import Contract


class Client(Base):
    """
    Represents a customer in the CRM system.
    """

    __tablename__ = "client"

    id: Mapped[pk_id]
    full_name: Mapped[str_50]
    email: Mapped[str_100] = mapped_column(unique=True)
    phone: Mapped[str_20]
    company_name: Mapped[str_50]

    # New field for last business contact
    last_contact: Mapped[timestamp_now]

    # Audit timestamps
    creation_date: Mapped[timestamp_now]
    last_update: Mapped[timestamp_update]

    # Foreign Key to the Sales Contact (Employee)
    sales_contact_id: Mapped[int] = mapped_column(
        ForeignKey("employee.id")
    )

    # Relationships
    sales_contact: Mapped["Employee"] = relationship(
        back_populates="managed_clients"
    )
    contracts: Mapped[list["Contract"]] = relationship(
        back_populates="client"
    )
    events: Mapped[list["Event"]] = relationship(
        back_populates="client"
    )

    def __repr__(self) -> str:
        return (
            f"<Client(name={self.full_name}, "
            f"company={self.company_name})>"
        )

===============================================================================
    ./app/models/contract.py
===============================================================================
# app/models/contract.py
"""
This module defines the Contract model, which stores financial agreements
with clients, including amounts, payment status, and audit timestamps.
"""

from typing import TYPE_CHECKING
from sqlalchemy import ForeignKey, Boolean, Numeric
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import (
    Base,
    pk_id,
    timestamp_now,
    timestamp_update
)

if TYPE_CHECKING:
    from app.models.client import Client
    from app.models.event import Event
    from app.models.employee import Employee


class Contract(Base):
    """
    Represents a financial agreement with a client.
    """

    __tablename__ = "contract"

    id: Mapped[pk_id]
    total_amount: Mapped[float] = mapped_column(Numeric(10, 2))
    remaining_amount: Mapped[float] = mapped_column(Numeric(10, 2))
    is_signed: Mapped[bool] = mapped_column(Boolean, default=False)

    # Audit timestamps
    creation_date: Mapped[timestamp_now]
    last_update: Mapped[timestamp_update]

    # Foreign Keys
    client_id: Mapped[int] = mapped_column(ForeignKey("client.id"))
    sales_contact_id: Mapped[int] = mapped_column(ForeignKey("employee.id"))

    # Relationships
    client: Mapped["Client"] = relationship(back_populates="contracts")
    sales_contact: Mapped["Employee"] = relationship(
        back_populates="managed_contracts"
    )
    event: Mapped["Event"] = relationship(back_populates="contract")

    def __repr__(self) -> str:
        return (
            f"<Contract(id={self.id}, "
            f"remaining={self.remaining_amount}, "
            f"signed={self.is_signed})>"
        )

===============================================================================
    ./app/models/department.py
===============================================================================
# app/models/department.py
"""
This module defines the Department model, which represents the different
business units within the company and manages their relationship with employees.
"""

from typing import TYPE_CHECKING
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import Base, pk_id, str_50

if TYPE_CHECKING:
    from app.models.employee import Employee


class Department(Base):
    """
    Represents a business unit (MANAGEMENT, SALES, or SUPPORT).
    """

    __tablename__ = "department"

    id: Mapped[pk_id]
    name: Mapped[str_50] = mapped_column(unique=True)

    # Relationships
    employees: Mapped[list["Employee"]] = relationship(
        back_populates="department"
    )

    def __repr__(self) -> str:
        return f"<Department(name={self.name})>"

===============================================================================
    ./app/models/employee.py
===============================================================================
# app/models/employee.py
"""
This module defines the Employee model, which stores staff member information,
credentials, and their association with departments and managed entities
such as clients and events.
"""

from typing import TYPE_CHECKING
from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import Base, pk_id, str_50, str_100, str_255, str_20

if TYPE_CHECKING:
    from app.models.department import Department
    from app.models.client import Client
    from app.models.event import Event
    from app.models.contract import Contract


class Employee(Base):
    """
    Represents a staff member of Epic Events.
    """

    __tablename__ = "employee"

    id: Mapped[pk_id]
    full_name: Mapped[str_50]
    email: Mapped[str_100] = mapped_column(unique=True)
    password: Mapped[str_255]
    employee_number: Mapped[str_20] = mapped_column(unique=True)

    # Foreign Key to Department
    department_id: Mapped[int] = mapped_column(ForeignKey("department.id"))

    # Relationships
    department: Mapped["Department"] = relationship(back_populates="employees")

    # Managed entities (Sales/Support roles)
    managed_clients: Mapped[list["Client"]] = relationship(
        back_populates="sales_contact"
    )
    managed_contracts: Mapped[list["Contract"]] = relationship(
        back_populates="sales_contact"
    )
    assigned_events: Mapped[list["Event"]] = relationship(
        back_populates="support_contact"
    )

    def __repr__(self) -> str:
        return (
            f"<Employee(name={self.full_name}, "
            f"department_id={self.department_id})>"
        )

===============================================================================
    ./app/models/event.py
===============================================================================
# app/models/event.py
"""
This module defines the Event model, representing a scheduled event
linked to a client, a contract, and potentially a support employee.
"""

from typing import TYPE_CHECKING, Optional
from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import (
    Base,
    pk_id,
    str_50,
    text_type,
    timestamp_now,
    timestamp_update
)

if TYPE_CHECKING:
    from app.models.client import Client
    from app.models.employee import Employee
    from app.models.contract import Contract


class Event(Base):
    """
    Represents a scheduled event for a specific client and contract.
    """

    __tablename__ = "event"

    id: Mapped[pk_id]
    name: Mapped[str_50]
    event_date_start: Mapped[timestamp_now]
    event_date_end: Mapped[timestamp_now]
    location: Mapped[str_50]
    attendees: Mapped[int]
    notes: Mapped[text_type]

    # Audit timestamps
    creation_date: Mapped[timestamp_now]
    last_update: Mapped[timestamp_update]

    # Foreign Keys
    client_id: Mapped[int] = mapped_column(ForeignKey("client.id"))
    contract_id: Mapped[int] = mapped_column(ForeignKey("contract.id"))
    support_contact_id: Mapped[Optional[int]] = mapped_column(
        ForeignKey("employee.id"), nullable=True
    )

    # Relationships
    client: Mapped["Client"] = relationship(back_populates="events")
    contract: Mapped["Contract"] = relationship(back_populates="event")
    support_contact: Mapped["Employee"] = relationship(
        back_populates="assigned_events"
    )

    def __repr__(self) -> str:
        return f"<Event(name={self.name}, start={self.event_date_start})>"

===============================================================================
    ./app/repositories/base_repository.py
===============================================================================
# app/repositories/base_repository.py
"""
This module defines the BaseRepository class using Generics.
It provides a standardized interface for common database operations (CRUD)
shared across all specific repositories.
"""

from typing import Generic, TypeVar, Type, Optional, List
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
import sentry_sdk
from app.models.base import Base

T = TypeVar("T", bound=Base)


class BaseRepository(Generic[T]):
    """
    Base class for data access logic.
    """

    def __init__(self, session: Session, model: Type[T]):
        self.session = session
        self.model = model

    def get_by_id(self, obj_id: int) -> Optional[T]:
        """Fetch a single record by its primary key."""
        return self.session.query(self.model).filter(
            self.model.id == obj_id
        ).first()

    def get_all(self) -> List[T]:
        """Fetch all records for this model."""
        return self.session.query(self.model).all()

    def add(self, obj: T) -> T:
        """Add a new object and commit the transaction."""
        try:
            self.session.add(obj)
            self.session.commit()
            self.session.refresh(obj)
            return obj
        except IntegrityError as e:
            # Capture database constraint violations (e.g., duplicate email)
            self.session.rollback()
            sentry_sdk.capture_exception(e)
            raise e
        except SQLAlchemyError as e:
            # Capture any other database-related errors
            self.session.rollback()
            sentry_sdk.capture_exception(e)
            raise e

    def update(self, obj_id: int, update_data: dict) -> Optional[T]:
        """Update a record and commit the transaction."""
        obj = self.get_by_id(obj_id)
        if obj:
            try:
                for key, value in update_data.items():
                    if hasattr(obj, key):
                        setattr(obj, key, value)
                self.session.commit()
                self.session.refresh(obj)
                return obj
            except SQLAlchemyError as e:
                self.session.rollback()
                sentry_sdk.capture_exception(e)
                raise e
        return None

    def delete(self, obj: T) -> None:
        """Remove an object and commit the transaction."""
        try:
            self.session.delete(obj)
            self.session.commit()
        except SQLAlchemyError as e:
            self.session.rollback()
            sentry_sdk.capture_exception(e)
            raise e

===============================================================================
    ./app/repositories/client_repository.py
===============================================================================
# app/repositories/client_repository.py
"""
Data access layer for Client-specific operations.
"""

from typing import Optional, List
from sqlalchemy.orm import Session
from app.models.client import Client
from app.repositories.base_repository import BaseRepository


class ClientRepository(BaseRepository[Client]):
    """
    Repository handling Client database queries.
    """

    def __init__(self, session: Session):
        super().__init__(session, Client)

    def get_all_clients(self) -> List[Client]:
        """
        Fetch all clients by calling the inherited get_all method.
        """
        return self.get_all()

    def get_by_email(self, email: str) -> Optional[Client]:
        """
        Fetch a client by its unique email.
        """
        return self.session.query(self.model).filter(
            self.model.email == email
        ).first()

===============================================================================
    ./app/repositories/contract_repository.py
===============================================================================
# app/repositories/contract_repository.py
"""
Data access layer for Contract-specific operations.
"""

from typing import List, Optional
from sqlalchemy.orm import Session
from app.models.contract import Contract
from app.repositories.base_repository import BaseRepository


class ContractRepository(BaseRepository[Contract]):
    """
    Repository handling Contract database queries.
    """

    def __init__(self, session: Session):
        super().__init__(session, Contract)

    def get_all_contracts(self) -> List[Contract]:
        """
        Fetch all contracts by calling the inherited get_all method.
        """
        return self.get_all()

    def get_unsigned_contracts(self) -> List[Contract]:
        """
        Fetch all contracts that are not yet signed.
        """
        return self.session.query(self.model).filter(
            self.model.is_signed == False  # noqa: E712
        ).all()

    def get_unpaid_contracts(self) -> List[Contract]:
        """
        Fetch contracts where remaining amount is greater than zero.
        """
        return self.session.query(self.model).filter(
            self.model.remaining_amount > 0
        ).all()

===============================================================================
    ./app/repositories/department_repository.py
===============================================================================
# app/repositories/department_repository.py
"""
This module specializes the BaseRepository for the Department model.
"""

from typing import Optional, List
from sqlalchemy.orm import Session
from app.models.department import Department
from app.repositories.base_repository import BaseRepository


class DepartmentRepository(BaseRepository[Department]):
    """
    Data access layer for Department-specific operations.
    """

    def __init__(self, session: Session):
        super().__init__(session, Department)

    def get_all_departments(self) -> List[Department]:
        """
        Fetch all departments using the base repository method.
        """
        return self.get_all()

    def get_by_name(self, name: str) -> Optional[Department]:
        """
        Fetch a department by its unique name.
        """
        return self.session.query(self.model).filter(
            self.model.name == name
        ).first()

===============================================================================
    ./app/repositories/employee_repository.py
===============================================================================
# app/repositories/employee_repository.py
"""
This module specializes the BaseRepository for the Employee model.
It provides specific lookup methods necessary for authentication
and staff management.
"""

from typing import Optional
from sqlalchemy.orm import Session
from app.models.employee import Employee
from app.repositories.base_repository import BaseRepository


class EmployeeRepository(BaseRepository[Employee]):
    """
    Data access layer for Employee-specific operations.
    """

    def __init__(self, session: Session):
        super().__init__(session, Employee)

    def get_all_employees(self):
        """
        Fetch all employees using the base repository method.
        """
        return self.get_all()

    def get_by_email(self, email: str) -> Optional[Employee]:
        """
        Fetch an employee by their unique email address.
        Used for authentication.
        """
        return self.session.query(self.model).filter(
            self.model.email == email
        ).first()

    def get_by_employee_number(self, emp_number: str) -> Optional[Employee]:
        """
        Fetch an employee by their unique employee number.
        """
        return self.session.query(self.model).filter(
            self.model.employee_number == emp_number
        ).first()

===============================================================================
    ./app/repositories/event_repository.py
===============================================================================
# app/repositories/event_repository.py
"""
Data access layer for Event-specific operations.
"""

from typing import List, Optional
from sqlalchemy.orm import Session
from app.models.event import Event
from app.repositories.base_repository import BaseRepository


class EventRepository(BaseRepository[Event]):
    """
    Repository handling Event database queries.
    """

    def __init__(self, session: Session):
        super().__init__(session, Event)

    def get_all_events(self) -> List[Event]:
        """
        Fetch all events by calling the inherited get_all method.
        """
        return self.get_all()

    def get_events_without_support(self) -> List[Event]:
        """
        Fetch all events that have no support contact assigned.
        """
        return self.session.query(self.model).filter(
            self.model.support_contact_id == None  # noqa: E711
        ).all()

    def get_my_events(self, support_id: int) -> List[Event]:
        """
        Fetch events assigned to a specific support employee.
        """
        return self.session.query(self.model).filter(
            self.model.support_contact_id == support_id
        ).all()

===============================================================================
    ./app/utils/auth.py
===============================================================================
# app/utils/auth.py
"""
This module handles secure password management using the Argon2 hashing
algorithm. It provides utilities for hashing plain text passwords and
verifying them against stored hashes.
"""

from argon2 import PasswordHasher
from argon2.exceptions import VerifyMismatchError, InvalidHashError

# Initialize the hasher with default secure parameters
ph = PasswordHasher()


def hash_password(password: str) -> str:
    """
    Hash a password using Argon2.
    """
    return ph.hash(password)


def verify_password(hashed_password: str, plain_password: str) -> bool:
    """
    Verify a password against its Argon2 hash.
    """
    try:
        return ph.verify(hashed_password, plain_password)
    except (VerifyMismatchError, InvalidHashError):
        return False

===============================================================================
    ./app/utils/decorators.py
===============================================================================
# app/utils/decorators.py
"""
Authentication decorators for controller methods.
Ensures user_data is available via token or arguments.
"""

from functools import wraps
from typing import Callable, Any
import sentry_sdk
from app.utils.token_storage import get_token
from app.utils.jwt_handler import decode_token


def require_auth(func: Callable) -> Callable:
    """
    Decorator that ensures a user is authenticated before executing a method.
    Injects user_data into the function arguments.
    """
    @wraps(func)
    def wrapper(self, *args, **kwargs) -> Any:
        # Add a breadcrumb to track the authentication attempt in Sentry
        sentry_sdk.add_breadcrumb(
            category="auth",
            message=f"Checking authentication for {func.__name__}",
            level="info",
        )

        # 1. Check if user_data is already passed
        user_data = kwargs.get("user_data")

        # 2. If not, try to retrieve it from token storage
        if not user_data:
            token = get_token()
            if token:
                user_data = decode_token(token)

        if not user_data:
            sentry_sdk.add_breadcrumb(
                category="auth",
                message="Authentication failed: No user data found",
                level="warning",
            )
            return []

        # 3. Inject user_data for the controller logic
        kwargs["user_data"] = user_data
        return func(self, *args, **kwargs)

    return wrapper

===============================================================================
    ./app/utils/jwt_handler.py
===============================================================================
# app/utils/jwt_handler.py
"""
This module handles JSON Web Token (JWT) generation and validation.
It ensures that user sessions are persistent, secure, and include
expiration logic as required by the technical specifications.
"""

import os
import datetime
from typing import Optional
import jwt
import sentry_sdk


# Configuration from environment variables
SECRET_KEY = os.getenv("JWT_SECRET", "default-secret-key-to-change")
ALGORITHM = os.getenv("JWT_ALGORITHM", "HS256")
TOKEN_EXPIRATION_HOURS = 12


def create_token(employee_id: int, department_name: str) -> str:
    """
    Generate a JWT token containing employee ID and department.
    The token is set to expire in 12 hours.
    """
    now = datetime.datetime.now(datetime.UTC)
    payload = {
        "sub": str(employee_id),
        "department": department_name,
        "iat": int(now.timestamp()),
        "exp": int((now + datetime.timedelta(hours=TOKEN_EXPIRATION_HOURS)).timestamp())
    }
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)


def decode_token(token: str) -> Optional[dict]:
    """
    Decode and validate a JWT token.
    Returns the payload if valid, or None if expired/invalid.
    """
    try:
        return jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    except jwt.ExpiredSignatureError as e:
        sentry_sdk.capture_exception(e)
        return None
    except jwt.InvalidTokenError as e:
        # Debug print for development phase
        print(f"DEBUG Decode Error: {e}")
        sentry_sdk.capture_exception(e)
        return None

===============================================================================
    ./app/utils/permissions.py
===============================================================================
# app/utils/permissions.py
"""
This module provides a centralized authorization system mapping
specific actions to departments to determine user permissions.
"""

import sentry_sdk

# Mapping of permissions per department
PERMISSIONS = {
    'MANAGEMENT': [
        'read_client',
        'create_client',
        'update_client',
        'read_contract',
        'create_contract',
        'update_contract',
        'read_event',
        'update_event',
        'read_employee',
        'create_employee',
        'update_employee',
        'delete_employee'
    ],
    'SALES': [
        'read_client',
        'create_client',
        'update_client',
        'read_contract',
        'update_contract',
        'read_event',
        'create_event'
    ],
    'SUPPORT': [
        'read_client',
        'read_contract',
        'read_event',
        'update_event'
    ]
}


def has_permission(action: str, department_name: str) -> bool:
    """
    Check if a specific department has the required permission.
    """
    allowed_actions = PERMISSIONS.get(department_name, [])
    is_allowed = action in allowed_actions

    if not is_allowed:
        # Log unauthorized access attempts to Sentry as a warning
        sentry_sdk.capture_message(
            f"Access denied: Department '{department_name}' "
            f"tried to perform action '{action}'",
            level="warning"
        )

    return is_allowed

===============================================================================
    ./app/utils/token_storage.py
===============================================================================
# app/utils/token_storage.py
"""
This module manages the local persistence of the JWT token.
It provides functions to save, retrieve, and delete the token from
a local file to maintain user sessions across CLI executions.
"""

import os
from typing import Optional

TOKEN_FILE = ".token"


def save_token(token: str) -> None:
    """
    Save the JWT token to a local hidden file.
    """
    with open(TOKEN_FILE, "w", encoding="utf-8") as f:
        f.write(token)


def get_token() -> Optional[str]:
    """
    Retrieve the JWT token from the local file if it exists.
    """
    if os.path.exists(TOKEN_FILE):
        with open(TOKEN_FILE, "r", encoding="utf-8") as f:
            return f.read().strip()
    return None


def delete_token() -> None:
    """
    Remove the local token file to log out the user.
    """
    if os.path.exists(TOKEN_FILE):
        os.remove(TOKEN_FILE)

===============================================================================
    ./app/views/auth_view.py
===============================================================================
# app/views/auth_view.py
"""
View for authentication related interactions.
Handles login inputs and success/failure messages.
"""

from app.views.base_view import BaseView


class AuthView(BaseView):
    """Handles login inputs."""

    def ask_login_details(self) -> tuple[str, str]:
        """Prompt user for email and password."""
        print("\n=== Epic Events CRM - Login ===")
        email = self.ask_input("Email")
        password = self.ask_input("Password")
        return email, password

    def display_login_success(self):
        """Confirm successful login."""
        self.display_message("Login successful! Welcome.")

    def display_login_failure(self):
        """Warn about failed credentials."""
        self.display_error("Invalid email or password.")

===============================================================================
    ./app/views/base_view.py
===============================================================================
# app/views/base_view.py
"""
Base class for all views in the application.
Provides common display methods and input validation for CLI interaction.
"""

import re
from datetime import datetime


class BaseView:
    """Provides common display methods and input validation for CLI."""

    def display_message(self, message: str):
        """Display a simple text message."""
        print(f"\n{message}")

    def display_error(self, message: str):
        """Display an error message formatted for visibility."""
        print(f"\n[ERROR] {message}")

    def ask_input(self, prompt: str) -> str:
        """Helper to get user input."""
        return input(f"{prompt}: ").strip()

    def validate_email(self, email: str) -> bool:
        """Check if the email format is valid."""
        pattern = r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$"
        if re.match(pattern, email):
            return True
        self.display_error("Invalid email format (ex: name@domain.com).")
        return False

    def validate_amount(self, amount: str) -> bool:
        """Check if the amount is a positive number."""
        try:
            val = float(amount)
            if val >= 0:
                return True
            self.display_error("Amount must be a positive value.")
        except ValueError:
            self.display_error("Amount must be a numeric value.")
        return False

    def validate_date(self, date_str: str) -> bool:
        """Check if the date format is valid (DD-MM-YYYY)."""
        try:
            datetime.strptime(date_str, "%d-%m-%Y")
            return True
        except ValueError:
            self.display_error("Invalid date format. Please use DD-MM-YYYY.")
            return False

===============================================================================
    ./app/views/client_view.py
===============================================================================
# app/views/client_view.py
"""
View for Client related interactions.
"""
from app.views.base_view import BaseView


class ClientView(BaseView):
    """Handles client display and inputs."""

    def display_clients(self, clients: list):
        """Print the list of all clients."""
        print("\n=== Clients List ===")
        if not clients:
            print("No clients found.")
            return
        for client in clients:
            print(
                f"ID: {client.id} | Name: {client.full_name} | "
                f"Email: {client.email} | Company: {client.company_name} | "
                f"Last Contact: {client.last_contact}"
            )

    def ask_client_details(self) -> dict:
        """Prompt user for new client information."""
        print("\n=== Add New Client ===")
        return {
            "full_name": self.ask_input("Full Name"),
            "email": self.ask_input("Email"),
            "phone": self.ask_input("Phone"),
            "company_name": self.ask_input("Company Name"),
            "last_contact": self.ask_input(
                "Last Contact Date (YYYY-MM-DD HH:MM:SS) "
                "[Leave empty for now]"
            )
        }

===============================================================================
    ./app/views/contract_view.py
===============================================================================
# app/views/contract_view.py
"""
View for Contract related interactions.
"""
from app.views.base_view import BaseView


class ContractView(BaseView):
    """Handles contract display and inputs."""

    def display_contracts(self, contracts: list):
        """Print the list of all contracts."""
        print("\n=== Contracts List ===")
        if not contracts:
            print("No contracts found.")
            return
        for contract in contracts:
            status = "Signed" if contract.is_signed else "Not Signed"
            print(
                f"ID: {contract.id} | Client: {contract.client.full_name} | "
                f"Sales Contact: {contract.sales_contact.full_name} | "
                f"Total: {contract.total_amount} | Status: {status}"
            )

===============================================================================
    ./app/views/employee_view.py
===============================================================================
# app/views/employee_view.py
"""
View for Employee related interactions.
"""
from app.views.base_view import BaseView


class EmployeeView(BaseView):
    """Handles employee display and inputs."""

    def display_employees(self, employees: list):
        """Print the list of all employees."""
        print("\n=== Employees List ===")
        if not employees:
            print("No employees found.")
            return
        for emp in employees:
            dept_name = emp.department.name if emp.department else "N/A"
            print(
                f"ID: {emp.id} | No: {emp.employee_number} | "
                f"Name: {emp.full_name} | Email: {emp.email} | "
                f"Dept: {dept_name}"
            )

    def ask_employee_details(self) -> dict:
        """Prompt user for new employee information."""
        print("\n=== Add New Employee ===")

        full_name = self.ask_input("Full Name")

        while True:
            email = self.ask_input("Email")
            if self.validate_email(email):
                break

        password = self.ask_input("Password")
        employee_number = self.ask_input("Employee Number")
        department_id = self.ask_input(
            "Department ID (1: Sales, 2: Support, 3: Management)"
        )

        return {
            "full_name": full_name,
            "email": email,
            "password": password,
            "employee_number": employee_number,
            "department_id": int(department_id) if department_id.isdigit() else 0
        }

    def ask_update_details(self) -> dict:
        """Prompt user for employee updates (all fields optional)."""
        print("\n=== Update Employee (Leave blank to keep current value) ===")

        full_name = self.ask_input("New Full Name (optional)")
        email = self.ask_input("New Email (optional)")
        password = self.ask_input("New Password (optional)")
        dept_id = self.ask_input("New Dept ID (optional)")

        details = {}
        if full_name:
            details["full_name"] = full_name
        if email:
            details["email"] = email
        if password:
            details["password"] = password
        if dept_id:
            details["department_id"] = int(dept_id) if dept_id.isdigit() else 0

        return details

===============================================================================
    ./app/views/event_view.py
===============================================================================
# app/views/event_view.py
"""
View for Event related interactions.
"""
from app.views.base_view import BaseView


class EventView(BaseView):
    """Handles event display and inputs."""

    def display_events(self, events: list):
        """Print the list of all events."""
        print("\n=== Events List ===")
        if not events:
            print("No events found.")
            return
        for event in events:
            support = (
                event.support_contact.full_name
                if event.support_contact
                else "TBD"
            )
            print(
                f"ID: {event.id} | Name: {event.name} | "
                f"From: {event.event_date_start} To: {event.event_date_end} | "
                f"Support: {support}"
            )

===============================================================================
    ./app/views/main_menu_view.py
===============================================================================
# app/views/main_menu_view.py
"""
Main menu view for the CRM application.
Adapts displayed options based on user department.
"""

from app.views.base_view import BaseView


class MainMenuView(BaseView):
    """Controller view for the main menu."""

    def display_menu(self, department: str):
        """Print the main menu options according to department."""
        print(f"\n=== Epic Events CRM - {department} Menu ===")
        print("1. List all clients")
        print("2. List all contracts")
        print("3. List all events")

        if department == "MANAGEMENT":
            print("4. List all employees")
            print("5. Create new employee")
            print("6. Update an employee")
        elif department == "SALES":
            print("20. Create new client")
        elif department == "SUPPORT":
            print("30. Update my events")

        print("0. Logout and Exit")

    def ask_menu_option(self) -> str:
        """Ask the user for a menu option."""
        return input("\nSelect an option: ").strip()

===============================================================================
    ./check_auth.py
===============================================================================
# check_auth.py
from app.utils.auth import hash_password, verify_password

password_to_test = "admin123"
# Le hash exact que vous avez mis dans le SQL
sql_hash = "$argon2id$v=19$m=65536,t=3,p=4$7Y5Wp8W1S6lF6z1N2q9Q5w$O7N8/v5J8J8"

# 1. Test de vérification
is_valid = verify_password(password_to_test, sql_hash)
print(f"Match SQL hash: {is_valid}")

# 2. Test de génération
new_hash = hash_password(password_to_test)
print(f"New hash generated: {new_hash}")
print(f"Match new hash: {verify_password(password_to_test, new_hash)}")

===============================================================================
    ./config/config.py
===============================================================================
# config/config.py
import os
from dotenv import load_dotenv

# Load variables from .env file
load_dotenv()


class Config:
    """Configuration loader for environment variables."""
    DB_USER = os.getenv("DB_USER")
    DB_PASSWORD = os.getenv("DB_PASSWORD")
    DB_HOST = os.getenv("DB_HOST")
    DB_PORT = os.getenv("DB_PORT")
    DB_NAME = os.getenv("DB_NAME")
    SECRET_KEY = os.getenv("SECRET_KEY")
    SENTRY_DSN = os.getenv("SENTRY_DSN")

    @classmethod
    def get_db_url(cls):
        """Return formatted SQLAlchemy database URL."""
        return (
            f"mysql+mysqlconnector://{cls.DB_USER}:{cls.DB_PASSWORD}@"
            f"{cls.DB_HOST}:{cls.DB_PORT}/{cls.DB_NAME}"
        )

===============================================================================
    ./init_db.py
===============================================================================
# init_db.py
from sqlalchemy import create_engine
from app.models import Base
from config.config import Config


def create_tables():
    """
    Creates all database tables defined in the models.
    """
    engine = create_engine(Config.get_db_url())

    print("Connecting to the database...")
    try:
        # Create all tables stored in the metadata
        Base.metadata.create_all(engine)
        print("Success: All tables created successfully.")
    except Exception as e:
        print(f"Error during table creation: {e}")


if __name__ == "__main__":
    create_tables()

===============================================================================
    ./main.py
===============================================================================
# main.py
"""
Entry point for the Epic Events CRM application.
Manages the main loop and coordinate between controllers and views.
"""

import sentry_sdk
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from config.config import Config

from app.repositories.employee_repository import EmployeeRepository
from app.repositories.client_repository import ClientRepository
from app.repositories.contract_repository import ContractRepository
from app.repositories.event_repository import EventRepository

from app.controllers.auth_controller import AuthController
from app.controllers.client_controller import ClientController
from app.controllers.contract_controller import ContractController
from app.controllers.event_controller import EventController
from app.controllers.employee_controller import EmployeeController

from app.views.auth_view import AuthView
from app.views.main_menu_view import MainMenuView
from app.views.client_view import ClientView
from app.views.contract_view import ContractView
from app.views.event_view import EventView
from app.views.employee_view import EmployeeView

# Initialize Sentry
sentry_sdk.init(
    dsn=Config.SENTRY_DSN,
    # Set the environment (default to development if not specified in Config)
    environment=getattr(Config, "ENVIRONMENT", "development"),
    traces_sample_rate=1.0,
    profiles_sample_rate=1.0,
)


def main():
    """Main application execution logic."""
    try:
        # Database Setup
        engine = create_engine(Config.get_db_url())
        session_factory = sessionmaker(bind=engine)
        session = session_factory()

        # Initialize Repositories
        emp_repo = EmployeeRepository(session)
        client_repo = ClientRepository(session)
        contract_repo = ContractRepository(session)
        event_repo = EventRepository(session)

        # Initialize Controllers
        auth_ctrl = AuthController(emp_repo)
        client_ctrl = ClientController(client_repo, auth_ctrl)
        contract_ctrl = ContractController(contract_repo, auth_ctrl)
        event_ctrl = EventController(event_repo, auth_ctrl)
        emp_ctrl = EmployeeController(emp_repo, auth_ctrl)

        # Initialize Views
        auth_view = AuthView()
        menu_view = MainMenuView()
        client_view = ClientView()
        contract_view = ContractView()
        event_view = EventView()
        emp_view = EmployeeView()

        # 1. Authentication Check
        user_data = auth_ctrl.get_logged_in_user()
        if not user_data:
            email, password = auth_view.ask_login_details()
            # Capture user_data directly from login()
            user_data = auth_ctrl.login(email, password)
            if not user_data:
                auth_view.display_login_failure()
                return

        auth_view.display_login_success()

        # 2. Application Loop
        while True:

            menu_view.display_menu(user_data["department"])
            choice = menu_view.ask_menu_option()

            if choice == "1":
                # Pass user_data to satisfy the @require_auth decorator
                data = client_ctrl.list_all_clients(user_data=user_data)
                client_view.display_clients(data)
            elif choice == "2":
                # Pass user_data to satisfy the @require_auth decorator
                data = contract_ctrl.list_all_contracts(user_data=user_data)
                contract_view.display_contracts(data)
            elif choice == "3":
                # Pass user_data to satisfy the @require_auth decorator
                data = event_ctrl.list_all_events(user_data=user_data)
                event_view.display_events(data)
            elif choice == "4":
                data = emp_ctrl.list_all_employees(user_data=user_data)
                emp_view.display_employees(data)
            elif choice == "5":
                details = emp_view.ask_employee_details()
                emp_ctrl.create_employee(user_data=user_data, employee_data=details)
            elif choice == "6":
                emp_id = emp_view.ask_input("Enter Employee ID to update")
                if emp_id.isdigit():
                    updates = emp_view.ask_update_details()
                    emp_ctrl.update_employee(
                        user_data=user_data,
                        emp_id=int(emp_id),
                        update_data=updates
                    )
            elif choice == "0":
                auth_ctrl.logout()
                print("Goodbye!")
                break
            else:
                print("Invalid option. Please try again.")

    except Exception as e:
        # Catch and report any fatal application errors
        sentry_sdk.capture_exception(e)
        print(f"A fatal error occurred: {e}")
        raise e


if __name__ == "__main__":
    main()

===============================================================================
    ./tests/__init__.py
===============================================================================


===============================================================================
    ./tests/conftest.py
===============================================================================
# tests/conftest.py
"""
Pytest configuration and global fixtures.
Provides database engine and session management for tests.

Tests included:
- N/A (Configuration file)

Changes:
- Removed unused 'os' import to satisfy flake8.
- Added load_dotenv() to ensure environment variables are available.
"""

from dotenv import load_dotenv
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from config.config import Config

# Load environment variables from .env file at startup
load_dotenv()


@pytest.fixture(scope="session")
def db_engine():
    """
    Create a database engine for the test session.
    Uses the connection URL from the project configuration.
    """
    engine = create_engine(Config.get_db_url())
    yield engine
    engine.dispose()


@pytest.fixture(scope="function")
def db_session(db_engine):
    """
    Provide a clean database session for each test.
    Uses a nested transaction (SAVEPOINT) to allow rollback.
    """
    connection = db_engine.connect()
    # Start a transaction
    transaction = connection.begin()

    # Bind session to connection
    Session = sessionmaker(bind=connection)
    session = Session()

    # Create a SAVEPOINT to allow sub-transactions (commits in tests)
    nested = connection.begin_nested()

    @pytest.fixture
    def _rollback_nested():
        yield
        if nested.is_active:
            nested.rollback()

    yield session

    session.close()
    # Rollback the root transaction to undo everything
    transaction.rollback()
    connection.close()
    connection.close()

===============================================================================
    ./tests/test_auth_utils.py
===============================================================================
# tests/test_auth_utils.py
"""
Unit tests for authentication utilities.

Tests included:
- test_password_hashing: Verify Argon2 hashing and verification.
- test_password_verification_fail: Ensure incorrect passwords are rejected.
- test_token_lifecycle: Save, retrieve, and delete token from storage.
"""

import os
from app.utils.auth import hash_password, verify_password
from app.utils.token_storage import save_token, get_token, delete_token, TOKEN_FILE


def test_password_hashing():
    """Test that hashing and verification work correctly with Argon2."""
    raw_password = "secure_password_2026"
    hashed = hash_password(raw_password)

    assert hashed != raw_password
    assert verify_password(hashed, raw_password) is True


def test_password_verification_fail():
    """Test that verification fails with a wrong password."""
    hashed = hash_password("correct_one")
    assert verify_password("wrong_one", hashed) is False


def test_token_lifecycle():
    """Test the full lifecycle: saving, getting, and deleting a token."""
    # Ensure a clean state
    if os.path.exists(TOKEN_FILE):
        os.remove(TOKEN_FILE)

    test_token = "abc.123.jwt.token"

    # Save
    save_token(test_token)
    assert os.path.exists(TOKEN_FILE)

    # Get
    retrieved = get_token()
    assert retrieved == test_token

    # Delete
    delete_token()
    assert not os.path.exists(TOKEN_FILE)
    assert get_token() is None

===============================================================================
    ./tests/test_integration_business_repos.py
===============================================================================
# tests/test_integration_business_repos.py
"""
Integration tests for Business Repositories (Client, Contract, Event).

Tests included:
- test_client_contract_event_chain: Verify the full creation chain with FKs.
- test_contract_integrity_violation: Verify error when client is missing.
- test_event_logic_queries: Verify business filters (unsigned, unpaid, etc.).
"""

import uuid
import pytest
from sqlalchemy.exc import IntegrityError
from app.repositories.client_repository import ClientRepository
from app.repositories.contract_repository import ContractRepository
from app.repositories.event_repository import EventRepository
from app.repositories.employee_repository import EmployeeRepository
from app.repositories.base_repository import BaseRepository
from app.models.department import Department
from app.models.employee import Employee
from app.models.client import Client
from app.models.contract import Contract
from app.models.event import Event
from datetime import datetime, timedelta


@pytest.fixture
def business_setup(db_session):
    """Fixture to provide staff and repositories for business integration."""
    dept_repo = BaseRepository(db_session, Department)
    emp_repo = EmployeeRepository(db_session)

    dept = dept_repo.add(Department(name=f"BIZ_{uuid.uuid4().hex[:6]}"))
    sales = emp_repo.add(Employee(
        full_name="Sales Rep",
        email=f"sales_{uuid.uuid4().hex[:6]}@epic.com",
        password="hash",
        employee_number=f"S_{uuid.uuid4().hex[:6]}",
        department_id=dept.id
    ))

    return {
        "sales": sales,
        "client_repo": ClientRepository(db_session),
        "contract_repo": ContractRepository(db_session),
        "event_repo": EventRepository(db_session)
    }


def test_client_contract_event_chain(business_setup):
    """Test the creation chain: Client -> Contract -> Event."""
    s = business_setup

    # 1. Create Client
    client = s["client_repo"].add(Client(
        full_name="Biz Client",
        email=f"biz_{uuid.uuid4().hex[:6]}@corp.com",
        phone="010203",
        company_name="BizCorp",
        sales_contact_id=s["sales"].id
    ))

    # 2. Create Contract
    contract = s["contract_repo"].add(Contract(
        total_amount=2000.0,
        remaining_amount=1000.0,
        is_signed=True,
        client_id=client.id,
        sales_contact_id=s["sales"].id
    ))

    # 3. Create Event
    event = s["event_repo"].add(Event(
        name="Biz Event",
        event_date_start=datetime.now(),
        event_date_end=datetime.now() + timedelta(hours=2),
        location="Paris",
        attendees=50,
        notes="Notes",
        client_id=client.id,
        contract_id=contract.id
    ))

    assert event.id is not None
    assert event.contract.total_amount == 2000.0
    assert event.client.full_name == "Biz Client"


def test_contract_integrity_violation(business_setup):
    """Verify that a contract cannot be created without a valid client."""
    s = business_setup
    invalid_contract = Contract(
        total_amount=100,
        remaining_amount=100,
        client_id=9999,  # Non-existent
        sales_contact_id=s["sales"].id
    )

    with pytest.raises(IntegrityError):
        s["contract_repo"].add(invalid_contract)


def test_event_logic_queries(business_setup):
    """Verify that specific repository filters return correct data."""
    s = business_setup

    # Create an unsigned contract
    client = s["client_repo"].add(Client(
        full_name="Filter Client",
        email=f"f_{uuid.uuid4().hex[:6]}@test.com",
        phone="0", company_name="F", sales_contact_id=s["sales"].id
    ))

    s["contract_repo"].add(Contract(
        total_amount=500, remaining_amount=500, is_signed=False,
        client_id=client.id, sales_contact_id=s["sales"].id
    ))

    unsigned = s["contract_repo"].get_unsigned_contracts()
    assert len(unsigned) >= 1
    assert any(c.is_signed is False for c in unsigned)

===============================================================================
    ./tests/test_integration_staff_repos.py
===============================================================================
# tests/test_integration_staff_repos.py
"""
Integration tests for Staff Repositories (Department & Employee).

Tests included:
- test_staff_creation_flow: Create a department then an employee linked to it.
- test_employee_unique_constraints_repo: Verify IntegrityError via Repository.
- test_department_lookup: Verify fetching department by name.
"""

import uuid
import pytest
from sqlalchemy.exc import IntegrityError
from app.repositories.department_repository import DepartmentRepository
from app.repositories.employee_repository import EmployeeRepository
from app.models.department import Department
from app.models.employee import Employee


@pytest.fixture
def staff_repos(db_session):
    """Fixture providing both staff repositories."""
    return DepartmentRepository(db_session), EmployeeRepository(db_session)


def test_staff_creation_flow(staff_repos):
    """Test full integration: creating a department and a linked employee."""
    dept_repo, emp_repo = staff_repos

    # 1. Create Department
    dept_name = f"DEPT_{uuid.uuid4().hex[:6]}"
    dept = Department(name=dept_name)
    dept_repo.add(dept)

    # 2. Create Employee linked to Dept
    emp_email = f"staff_{uuid.uuid4().hex[:6]}@epic.com"
    emp = Employee(
        full_name="Staff Member",
        email=emp_email,
        password="secure_hash",
        employee_number=f"EMP_{uuid.uuid4().hex[:6]}",
        department_id=dept.id
    )
    emp_repo.add(emp)

    # 3. Verify Integration
    fetched_emp = emp_repo.get_by_email(emp_email)
    assert fetched_emp.department.name == dept_name


def test_employee_unique_constraints_repo(staff_repos):
    """Verify that repositories correctly handle DB unique constraints."""
    dept_repo, emp_repo = staff_repos

    dept = Department(name=f"UNIQUE_DEPT_{uuid.uuid4().hex[:6]}")
    dept_repo.add(dept)

    shared_email = "duplicate@epic.com"
    emp1 = Employee(
        full_name="User 1", email=shared_email, password="h",
        employee_number="N1", department_id=dept.id
    )
    emp_repo.add(emp1)

    emp2 = Employee(
        full_name="User 2", email=shared_email, password="h",
        employee_number="N2", department_id=dept.id
    )

    with pytest.raises(IntegrityError):
        emp_repo.add(emp2)


def test_department_lookup(staff_repos):
    """Test the specific get_by_name method in DepartmentRepository."""
    dept_repo, _ = staff_repos
    name = "SUPPORT_TEAM"
    dept = Department(name=name)
    dept_repo.add(dept)

    found = dept_repo.get_by_name(name)
    assert found is not None
    assert found.id == dept.id

===============================================================================
    ./tests/test_jwt_handler.py
===============================================================================
# tests/test_jwt_handler.py
"""
Unit tests for JWT handler.

Tests included:
- test_create_and_decode_valid_token: Verify generation and decoding.
- test_decode_invalid_token: Ensure invalid strings return None.
- test_expired_token: Verify expiration logic returns None.
"""

import datetime
import jwt
from app.utils.jwt_handler import create_token, decode_token, SECRET_KEY, ALGORITHM


def test_create_and_decode_valid_token():
    """Verify that a generated token can be correctly decoded."""
    token = create_token(1, "Management")
    decoded = decode_token(token)

    assert decoded is not None
    assert decoded["sub"] == "1"
    assert decoded["department"] == "Management"


def test_decode_invalid_token():
    """Ensure that an invalid token returns None."""
    assert decode_token("invalid.token.string") is None


def test_expired_token():
    """Verify that an expired token returns None."""
    now = datetime.datetime.now(datetime.UTC)
    payload = {
        "sub": "1",
        "department": "Sales",
        "exp": int((now - datetime.timedelta(seconds=1)).timestamp())
    }
    expired_token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

    decoded = decode_token(expired_token)
    assert decoded is None

===============================================================================
    ./tests/test_logic_filters.py
===============================================================================
# tests/test_logic_filters.py
"""
Unit tests for specialized repository filtering logic.

Tests included:
- test_filter_unpaid_contracts: Verify only contracts with remaining_amount > 0 are returned.
- test_filter_events_without_support: Verify events with support_contact_id=None are returned.
- test_filter_unsigned_contracts: Verify only is_signed=False contracts are returned.
- test_filter_my_events: Verify support agents only see their assigned events.
"""

import uuid
import pytest
from datetime import datetime
from app.repositories.contract_repository import ContractRepository
from app.repositories.event_repository import EventRepository
from app.repositories.client_repository import ClientRepository
from app.repositories.employee_repository import EmployeeRepository
from app.repositories.base_repository import BaseRepository
from app.models.department import Department
from app.models.employee import Employee
from app.models.client import Client
from app.models.contract import Contract
from app.models.event import Event


@pytest.fixture
def filter_setup(db_session):
    """Setup a batch of data with various states for filtering tests."""
    dept_repo = BaseRepository(db_session, Department)
    emp_repo = EmployeeRepository(db_session)
    client_repo = ClientRepository(db_session)
    contract_repo = ContractRepository(db_session)

    dept = dept_repo.add(Department(name=f"FILT_{uuid.uuid4().hex[:6]}"))
    sales = emp_repo.add(Employee(
        full_name="Sales",
        email=f"s_{uuid.uuid4().hex[:6]}@test.com",
        password="h",
        employee_number=f"S{uuid.uuid4().hex[:4]}",
        department_id=dept.id
    ))
    support = emp_repo.add(Employee(
        full_name="Support",
        email=f"p_{uuid.uuid4().hex[:6]}@test.com",
        password="h",
        employee_number=f"P{uuid.uuid4().hex[:4]}",
        department_id=dept.id
    ))
    client = client_repo.add(Client(
        full_name="C",
        email=f"c_{uuid.uuid4().hex[:6]}@test.com",
        phone="0",
        company_name="C",
        sales_contact_id=sales.id
    ))
    # Create default contract for events
    contract = contract_repo.add(Contract(
        total_amount=1000,
        remaining_amount=500,
        is_signed=True,
        client_id=client.id,
        sales_contact_id=sales.id
    ))

    return {
        "db": db_session,
        "sales": sales,
        "support": support,
        "client": client,
        "contract": contract,
        "contract_repo": contract_repo,
        "event_repo": EventRepository(db_session)
    }


def test_filter_unpaid_contracts(filter_setup):
    """Verify that only contracts with a remaining balance are fetched."""
    repo = filter_setup["contract_repo"]
    client_id = filter_setup["client"].id
    sales_id = filter_setup["sales"].id

    repo.add(Contract(
        total_amount=1000, remaining_amount=0, is_signed=True,
        client_id=client_id, sales_contact_id=sales_id
    ))
    repo.add(Contract(
        total_amount=1000, remaining_amount=500, is_signed=True,
        client_id=client_id, sales_contact_id=sales_id
    ))

    unpaid = repo.get_unpaid_contracts()
    assert all(c.remaining_amount > 0 for c in unpaid)


def test_filter_events_without_support(filter_setup):
    """Verify that we can find events that need a support assignment."""
    repo = filter_setup["event_repo"]
    client_id = filter_setup["client"].id
    contract_id = filter_setup["contract"].id

    # Event with support
    repo.add(Event(
        name="E1", event_date_start=datetime.now(),
        event_date_end=datetime.now(), location="L", attendees=10,
        notes="N", client_id=client_id, contract_id=contract_id,
        support_contact_id=filter_setup["support"].id
    ))
    # Event without support
    repo.add(Event(
        name="E2", event_date_start=datetime.now(),
        event_date_end=datetime.now(), location="L", attendees=10,
        notes="N", client_id=client_id, contract_id=contract_id,
        support_contact_id=None
    ))

    no_support = repo.get_events_without_support()
    assert any(e.name == "E2" for e in no_support)
    assert all(e.support_contact_id is None for e in no_support)


def test_filter_unsigned_contracts(filter_setup):
    """Verify filtering of unsigned contracts."""
    repo = filter_setup["contract_repo"]
    client_id = filter_setup["client"].id
    sales_id = filter_setup["sales"].id

    repo.add(Contract(
        total_amount=100, remaining_amount=100, is_signed=False,
        client_id=client_id, sales_contact_id=sales_id
    ))

    unsigned = repo.get_unsigned_contracts()
    assert any(c.is_signed is False for c in unsigned)


def test_filter_my_events(filter_setup):
    """Verify support agents only see their assigned events."""
    repo = filter_setup["event_repo"]
    client_id = filter_setup["client"].id
    contract_id = filter_setup["contract"].id
    support_id = filter_setup["support"].id

    repo.add(Event(
        name="My Event", event_date_start=datetime.now(),
        event_date_end=datetime.now(), location="L", attendees=5,
        notes="N", client_id=client_id, contract_id=contract_id,
        support_contact_id=support_id
    ))

    my_events = repo.get_my_events(support_id)
    assert all(e.support_contact_id == support_id for e in my_events)

===============================================================================
    ./tests/test_models_business.py
===============================================================================
# tests/test_models_business.py
"""
Unit tests for Business models (Client, Contract, and Event).

Tests included:
- test_create_client: Verify client creation and relationship with sales.
- test_create_contract: Verify contract linked to client and sales contact.
- test_create_event: Verify event linked to contract, client and support.
- test_client_email_uniqueness: Ensure client emails are unique.
"""

import uuid
from datetime import datetime, timedelta
import pytest
from sqlalchemy.exc import IntegrityError
from app.models.department import Department
from app.models.employee import Employee
from app.models.client import Client
from app.models.contract import Contract
from app.models.event import Event


@pytest.fixture
def test_setup(db_session):
    """Fixture to provide a department and employees for business tests."""
    dept_sales = Department(name=f"SALES_{uuid.uuid4().hex[:6]}")
    dept_support = Department(name=f"SUPPORT_{uuid.uuid4().hex[:6]}")
    db_session.add_all([dept_sales, dept_support])
    db_session.commit()

    sales = Employee(
        full_name="Sales Guy",
        email=f"sales_{uuid.uuid4().hex[:6]}@epic.com",
        password="hash",
        employee_number=f"S_{uuid.uuid4().hex[:6]}",
        department_id=dept_sales.id
    )
    support = Employee(
        full_name="Support Guy",
        email=f"support_{uuid.uuid4().hex[:6]}@epic.com",
        password="hash",
        employee_number=f"SUP_{uuid.uuid4().hex[:6]}",
        department_id=dept_support.id
    )
    db_session.add_all([sales, support])
    db_session.commit()
    return sales, support


def test_create_client(db_session, test_setup):
    """Test client creation linked to a sales employee."""
    sales, _ = test_setup
    unique_email = f"client_{uuid.uuid4().hex[:6]}@corp.com"
    client = Client(
        full_name="Alice Client",
        email=unique_email,
        phone="0123456789",
        company_name="Alice Corp",
        sales_contact_id=sales.id
    )
    db_session.add(client)
    db_session.commit()

    assert client.id is not None
    assert client.sales_contact.full_name == "Sales Guy"
    assert str(client) == "<Client(name=Alice Client, company=Alice Corp)>"


def test_create_contract(db_session, test_setup):
    """Test contract creation with amounts and signature status."""
    sales, _ = test_setup
    client = Client(
        full_name="Contract Client",
        email=f"c_{uuid.uuid4().hex[:6]}@test.com",
        phone="000",
        company_name="C-Corp",
        sales_contact_id=sales.id
    )
    db_session.add(client)
    db_session.commit()

    contract = Contract(
        total_amount=1000.50,
        remaining_amount=500.00,
        is_signed=True,
        client_id=client.id,
        sales_contact_id=sales.id
    )
    db_session.add(contract)
    db_session.commit()

    assert contract.id is not None
    assert float(contract.total_amount) == 1000.50
    assert contract.client.full_name == "Contract Client"


def test_create_event(db_session, test_setup):
    """Test full event chain link: Client -> Contract -> Event."""
    sales, support = test_setup
    client = Client(
        full_name="Event Client",
        email=f"e_{uuid.uuid4().hex[:6]}@event.com",
        phone="111",
        company_name="E-Events",
        sales_contact_id=sales.id
    )
    db_session.add(client)
    db_session.commit()

    contract = Contract(
        total_amount=5000,
        remaining_amount=0,
        is_signed=True,
        client_id=client.id,
        sales_contact_id=sales.id
    )
    db_session.add(contract)
    db_session.commit()

    start_date = datetime.now() + timedelta(days=7)
    event = Event(
        name="Epic Party",
        event_date_start=start_date,
        event_date_end=start_date + timedelta(hours=5),
        location="Paris",
        attendees=100,
        notes="Important event",
        client_id=client.id,
        contract_id=contract.id,
        support_contact_id=support.id
    )
    db_session.add(event)
    db_session.commit()

    assert event.id is not None
    assert event.contract.is_signed is True
    assert event.support_contact.full_name == "Support Guy"


def test_client_email_uniqueness(db_session, test_setup):
    """Verify that two clients cannot share the same email."""
    sales, _ = test_setup
    email = "duplicate@test.com"
    c1 = Client(
        full_name="C1", email=email, phone="1",
        company_name="A", sales_contact_id=sales.id
    )
    db_session.add(c1)
    db_session.commit()

    c2 = Client(
        full_name="C2", email=email, phone="2",
        company_name="B", sales_contact_id=sales.id
    )
    db_session.add(c2)
    with pytest.raises(IntegrityError):
        db_session.commit()
    db_session.rollback()

===============================================================================
    ./tests/test_models_staff.py
===============================================================================
# tests/test_models_staff.py
"""
Unit tests for Staff models (Department and Employee).

Tests included:
- test_create_department: Validate department creation with unique names.
- test_department_unique_name: Ensure department names are unique.
- test_create_employee: Validate employee creation and relations.
- test_employee_unique_constraints: Validate email and employee_number uniqueness.
"""

import uuid
import pytest
from sqlalchemy.exc import IntegrityError
from app.models.department import Department
from app.models.employee import Employee


def test_create_department(db_session):
    """Test creating a department and its representation."""
    unique_name = f"DEPT_{uuid.uuid4().hex[:8]}"
    dept = Department(name=unique_name)
    db_session.add(dept)
    db_session.commit()

    assert dept.id is not None
    assert str(dept) == f"<Department(name={unique_name})>"


def test_department_unique_name(db_session):
    """Ensure that two departments cannot have the same name."""
    unique_name = f"UNIQUE_{uuid.uuid4().hex[:8]}"
    dept1 = Department(name=unique_name)
    db_session.add(dept1)
    db_session.commit()

    dept2 = Department(name=unique_name)
    db_session.add(dept2)
    with pytest.raises(IntegrityError):
        db_session.commit()
    db_session.rollback()


def test_create_employee(db_session):
    """Test creating an employee associated with a department."""
    unique_dept = f"SUPPORT_{uuid.uuid4().hex[:8]}"
    dept = Department(name=unique_dept)
    db_session.add(dept)
    db_session.commit()

    unique_email = f"user_{uuid.uuid4().hex[:8]}@test.com"
    emp = Employee(
        full_name="John Doe",
        email=unique_email,
        password="hashed_password",
        employee_number=f"EMP_{uuid.uuid4().hex[:8]}",
        department_id=dept.id
    )
    db_session.add(emp)
    db_session.commit()

    assert emp.id is not None
    assert emp.department.name == unique_dept


def test_employee_unique_constraints(db_session):
    """Test uniqueness of email and employee_number."""
    dept = Department(name=f"ADMIN_{uuid.uuid4().hex[:8]}")
    db_session.add(dept)
    db_session.commit()

    email = f"same_{uuid.uuid4().hex[:8]}@test.com"
    emp1 = Employee(
        full_name="User 1",
        email=email,
        password="pwd",
        employee_number="ID_STATIC",
        department_id=dept.id
    )
    db_session.add(emp1)
    db_session.commit()

    # Duplicate email
    emp2 = Employee(
        full_name="User 2",
        email=email,
        password="pwd",
        employee_number="ID_NEW",
        department_id=dept.id
    )
    db_session.add(emp2)
    with pytest.raises(IntegrityError):
        db_session.commit()
    db_session.rollback()


===============================================================================
    ./tests/test_permissions.py
===============================================================================
# tests/test_permissions.py
"""
Unit tests for the authorization system.

Tests included:
- test_management_permissions: Validate all actions for MANAGEMENT.
- test_sales_permissions: Validate allowed and restricted actions for SALES.
- test_support_permissions: Validate allowed and restricted actions for SUPPORT.
- test_unknown_department_permissions: Ensure unknown departments have no access.
"""

from app.utils.permissions import has_permission


def test_management_permissions():
    """Verify that MANAGEMENT has all its assigned permissions."""
    dept = "MANAGEMENT"
    assert has_permission("create_employee", dept) is True
    assert has_permission("delete_employee", dept) is True
    assert has_permission("update_contract", dept) is True


def test_sales_permissions():
    """Verify SALES permissions and restrictions."""
    dept = "SALES"
    # Allowed
    assert has_permission("create_client", dept) is True
    assert has_permission("create_event", dept) is True
    # Restricted
    assert has_permission("create_employee", dept) is False
    assert has_permission("delete_employee", dept) is False


def test_support_permissions():
    """Verify SUPPORT permissions and restrictions."""
    dept = "SUPPORT"
    # Allowed
    assert has_permission("read_event", dept) is True
    assert has_permission("update_event", dept) is True
    # Restricted
    assert has_permission("create_client", dept) is False
    assert has_permission("create_contract", dept) is False


def test_unknown_department_permissions():
    """Ensure that a non-existent department has no permissions."""
    assert has_permission("read_client", "GHOST_DEPT") is False

===============================================================================
    ./tests/test_repositories.py
===============================================================================
# tests/test_repositories.py
"""
Unit tests for Repositories.

Tests included:
- test_employee_repo_get_by_email: Verify lookup by email.
- test_employee_repo_add: Verify adding an employee via repo.
- test_repo_rollback_on_error: Ensure BaseRepository rolls back on failure.
"""

import uuid
import pytest
from sqlalchemy.exc import IntegrityError
from app.models.employee import Employee
from app.models.department import Department
from app.repositories.employee_repository import EmployeeRepository


@pytest.fixture
def employee_repo(db_session):
    """Fixture to provide the employee repository."""
    return EmployeeRepository(db_session)


def test_employee_repo_add(employee_repo, db_session):
    """Test adding an employee using the repository method."""
    # Setup department
    dept = Department(name=f"TECH_{uuid.uuid4().hex[:6]}")
    db_session.add(dept)
    db_session.commit()

    emp = Employee(
        full_name="Test Repo",
        email=f"repo_{uuid.uuid4().hex[:6]}@test.com",
        password="hash",
        employee_number=f"ID_{uuid.uuid4().hex[:6]}",
        department_id=dept.id
    )

    # Action via le repository
    employee_repo.add(emp)

    # Verification
    fetched = employee_repo.get_by_id(emp.id)
    assert fetched is not None
    assert fetched.full_name == "Test Repo"


def test_employee_repo_get_by_email(employee_repo, db_session):
    """Test finding an employee by email via the repository."""
    dept = Department(name=f"HR_{uuid.uuid4().hex[:6]}")
    db_session.add(dept)
    db_session.commit()

    email = f"findme_{uuid.uuid4().hex[:6]}@test.com"
    emp = Employee(
        full_name="Search Target",
        email=email,
        password="hash",
        employee_number=f"SN_{uuid.uuid4().hex[:6]}",
        department_id=dept.id
    )
    employee_repo.add(emp)

    found = employee_repo.get_by_email(email)
    assert found is not None
    assert found.id == emp.id


def test_repo_rollback_on_error(employee_repo, db_session):
    """Verify that BaseRepository handles IntegrityError and rolls back."""
    dept = Department(name=f"VOID_{uuid.uuid4().hex[:6]}")
    db_session.add(dept)
    db_session.commit()

    email = "duplicate@test.com"
    emp1 = Employee(
        full_name="User 1", email=email, password="h",
        employee_number="N1", department_id=dept.id
    )
    employee_repo.add(emp1)

    emp2 = Employee(
        full_name="User 2", email=email, password="h",
        employee_number="N2", department_id=dept.id
    )

    # Le BaseRepository doit lever l'erreur et faire le rollback
    with pytest.raises(IntegrityError):
        employee_repo.add(emp2)

