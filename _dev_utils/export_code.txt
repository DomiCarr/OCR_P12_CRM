================================================================================
EXPORT STRUCTURE & CODE APP
Generated: 2026-02-24 17:20:57
Project root: /Users/carrasd/Develp/OCR/Projets/P12/CRM
================================================================================

SECTION 1 â€” PROJECT STRUCTURE
--------------------------------------------------------------------------------
Listing all files and folders (excluded: .git __pycache__ _dev_utils env .venv .pytest_cache .mypy_cache .ruff_cache node_modules dist build)

.DS_Store
.coverage
.env
.gitignore
.token
README.md
app
    app/.DS_Store
    app/controllers
        app/controllers/auth_controller.py
        app/controllers/client_controller.py
        app/controllers/contract_controller.py
        app/controllers/employee_controller.py
        app/controllers/event_controller.py
    app/models
        app/models/.DS_Store
        app/models/__init__.py
        app/models/base.py
        app/models/client.py
        app/models/contract.py
        app/models/department.py
        app/models/employee.py
        app/models/event.py
    app/repositories
        app/repositories/base_repository.py
        app/repositories/client_repository.py
        app/repositories/contract_repository.py
        app/repositories/department_repository.py
        app/repositories/employee_repository.py
        app/repositories/event_repository.py
    app/static
    app/utils
        app/utils/.DS_Store
        app/utils/auth.py
        app/utils/decorators.py
        app/utils/jwt_handler.py
        app/utils/permissions.py
        app/utils/token_storage.py
    app/views
        app/views/auth_view.py
        app/views/base_view.py
        app/views/client_view.py
        app/views/contract_view.py
        app/views/employee_view.py
        app/views/event_view.py
        app/views/main_menu_view.py
check_auth.py
config
    config/config.py
epic_events_schema.sql
init_db.py
main.py
pytest.ini
requirements
requirements.txt
result.txt
tests
    tests/__init__.py
    tests/conftest.py
    tests/test_auth_controller_session_restore.py
    tests/test_auth_utils.py
    tests/test_business_validation.py
    tests/test_controllers_more_more_coverage.py
    tests/test_controllers_negative_paths.py
    tests/test_functional_auth.py
    tests/test_functional_management.py
    tests/test_functional_permissions.py
    tests/test_functional_sales.py
    tests/test_integration_business_repos.py
    tests/test_integration_staff_repos.py
    tests/test_jwt_handler.py
    tests/test_logic_filters.py
    tests/test_models_business.py
    tests/test_models_staff.py
    tests/test_permissions.py
    tests/test_repositories.py
    tests/test_repository_and_decorators_coverage.py
    tests/test_robustness_edge_cases.py

END SECTION 1

SECTION 2 â€” CONCATENATED FILES
--------------------------------------------------------------------------------
Included extensions: py html css js md json yml yaml toml ini cfg txt sql sh
Included special files: .gitignore .env.example Dockerfile docker-compose.yml docker-compose.yaml Makefile
Excluded directories: .git __pycache__ _dev_utils env .venv .pytest_cache .mypy_cache .ruff_cache node_modules dist build
Excluded file names: .DS_Store .coverage coverage.xml
Excluded file globs: *.pyc *.pyo *.pyd *.log *.sqlite *.sqlite3 *.db *.pem *.key *.p12

===============================================================================
FILE: ./.gitignore
------------------------------------------------------------------------------
META: 2331 bytes | modified: 2026-02-18 09:50:12
===============================================================================

# ---------------------------------------------------------
# System & IDEs
# ---------------------------------------------------------
.DS_Store
.vscode/
.idea/
*.sublime-project
*.sublime-workspace

# ---------------------------------------------------------
# Python & Environment
# ---------------------------------------------------------
# Virtual environments
env/
venv/
.venv/
# Security: Sensitive environment variables
.env
.env.local

# Python cache
__pycache__/
*.py[cod]
*$py.class

# ---------------------------------------------------------
# Flask & Security
# ---------------------------------------------------------
# Local instance folder (database, keys, etc.) - [cite: 51]
instance/
# Cache for web assets (CSS/JS)
.webassets-cache
# Local environment variables (can contain secrets) - [cite: 51]
.flaskenv
.env

# ---------------------------------------------------------
# Testing & Coverage
# ---------------------------------------------------------
# Pytest local cache [cite: 63]
.pytest_cache/
pytest_cache/
# Automation tools for testing in multiple environments
.tox/
.nox/
# Test coverage reports - [cite: 63, 69]
htmlcov/
.coverage
coverage.xml
*.cover
nosetests.xml

# ---------------------------------------------------------
# Performance Testing (Locust)
# ---------------------------------------------------------
# HTML reports generated by Locust after a load test - [cite: 73]
locust_report.html

# ---------------------------------------------------------
# Distribution / Build (Packaging and Installation)
# ---------------------------------------------------------
# Python packaging: folders created when building a distribution
build/
dist/
sdist/
# Installation metadata: created during local installation
*.egg-info/
.eggs/
# Binary distributions: platform-specific compiled packages
wheels/
# Python Eggs: older distribution formats and their caches
eggs/
develop-eggs/
# Shared libraries and temporary downloads
lib/
lib64/
downloads/
# Buildout/Zope specific
parts/
var/

# ---------------------------------------------------------
# Project Specific
# ---------------------------------------------------------
# Local session tokens (JWT)
.session.json
.token

# Database dumps and local SQL scripts
database/*.sql
*.sql

# Database migration / temporary SQL (if any)
*.sql.tmp


===============================================================================
FILE: ./README.md
------------------------------------------------------------------------------
META: 14 bytes | modified: 2026-02-14 15:37:25
===============================================================================

# OCR_P12_CRM


===============================================================================
FILE: ./app/controllers/auth_controller.py
------------------------------------------------------------------------------
META: 3074 bytes | modified: 2026-02-19 13:07:07
===============================================================================

# app/controllers/auth_controller.py
"""
This module handles the authentication logic, integrating JWT generation
and local storage to provide persistent user sessions.
"""

from typing import Optional
import sentry_sdk
from app.repositories.employee_repository import EmployeeRepository
from app.utils.auth import verify_password
from app.utils.permissions import has_permission
from app.utils.jwt_handler import create_token, decode_token
from app.utils.token_storage import save_token, get_token, delete_token


class AuthController:
    """
    Controller managing login, logout, and persistent session validation.
    """

    def __init__(self, employee_repository: EmployeeRepository):
        self.repository = employee_repository
        self.current_user_data: Optional[dict] = None

    def login(self, email: str, password: str) -> Optional[dict]:
        """
        Authenticate user and save a JWT locally if successful.
        """
        employee = self.repository.get_by_email(email)

        if employee and verify_password(employee.password, password):
            # Generate and save token locally
            token = create_token(employee.id, employee.department.name)
            save_token(token)

            # Return user data for main.py session management
            user_data = {
                "id": employee.id,
                "full_name": employee.full_name,
                "department": employee.department.name
            }

            # Attach user identity to Sentry scope for error tracking
            sentry_sdk.set_user({
                "id": str(employee.id),
                "username": employee.full_name,
                "department": employee.department.name
            })

            self.current_user_data = user_data
            return user_data

        return None

    def logout(self) -> None:
        """
        Clear the session by deleting the local token.
        """
        delete_token()
        # Clear Sentry user context to avoid cross-user error reporting
        sentry_sdk.set_user(None)
        self.current_user_data = None

    def get_logged_in_user(self) -> Optional[dict]:
        """
        Validate the local token and return user data if still valid.
        """
        token = get_token()
        if not token:
            return None

        payload = decode_token(token)
        if payload:
            # Restore Sentry user identity for persistent sessions
            sentry_sdk.set_user({
                "id": str(payload.get("id")),
                "department": payload.get("department")
            })
            self.current_user_data = payload
            return payload

        # Token expired or invalid
        delete_token()
        return None

    def check_user_permission(self, action: str) -> bool:
        """
        Check if the currently logged-in user has permission for an action.
        """
        if not self.current_user_data:
            return False

        dept = self.current_user_data.get("department")
        return has_permission(action, dept)

===============================================================================
FILE: ./app/controllers/client_controller.py
------------------------------------------------------------------------------
META: 3809 bytes | modified: 2026-02-19 22:16:16
===============================================================================

# app/controllers/client_controller.py
"""
Controller handling business logic for Client management.
Ensures authentication and permission checks before data access.
"""

from datetime import datetime
from app.models.client import Client
from app.repositories.client_repository import ClientRepository
from app.utils.decorators import require_auth


class ClientController:
    """Manages client-related operations."""

    def __init__(self, repository: ClientRepository, auth_controller):
        self.repository = repository
        self.auth_controller = auth_controller

    @require_auth
    def list_all_clients(self, *args, user_data: dict | None = None):
        """Fetch all clients if the user has the 'read_client' permission."""
        if user_data is None and args:
            if isinstance(args[0], dict) and "id" in args[0]:
                user_data = args[0]

        if user_data is None:
            return []

        self.auth_controller.current_user_data = user_data
        permission = "read_client"
        if self.auth_controller.check_user_permission(permission):
            return self.repository.get_all_clients()
        return []

    @require_auth
    def create_client(
        self,
        *args,
        user_data: dict | None = None,
        client_data: dict | None = None,
    ):
        """Create a new client and associate with the current sales person."""
        if client_data is None and args:
            first = args[0]
            if isinstance(first, dict) and "id" in first and "department" in first:
                user_data = first
                if len(args) > 1:
                    client_data = args[1]
            else:
                client_data = first

        if user_data is None:
            user_data = getattr(self.auth_controller, "current_user_data", None)

        if not user_data or not client_data:
            return None

        self.auth_controller.current_user_data = user_data
        if self.auth_controller.check_user_permission("create_client"):
            client_data["sales_contact_id"] = user_data["id"]

            if not client_data.get("last_contact"):
                client_data["last_contact"] = datetime.now()

            new_client = Client(**client_data)
            created_client = self.repository.add(new_client)

            if created_client:
                print(f"Client '{created_client.full_name}' created.")
            return created_client

        print("Access denied: You do not have permission to create a client.")
        return None

    @require_auth
    def update_client(self, user_data: dict, client_id: int, updates: dict):
        """Update client if user is assigned sales contact or management."""
        self.auth_controller.current_user_data = user_data
        if not self.auth_controller.check_user_permission("update_client"):
            print("Access denied: No update permission.")
            return None

        client = self.repository.get_by_id(client_id)
        if not client:
            print("Client not found.")
            return None

        # Logic: Sales can only update their own clients. Management can update all.
        is_owner = client.sales_contact_id == user_data["id"]
        is_management = user_data["department"] == "MANAGEMENT"

        if not (is_owner or is_management):
            print("Access denied: You are not the assigned sales contact.")
            return None

        # Update last_contact timestamp
        updates["last_contact"] = datetime.now()

        # FIXED: Pass 'updates' as a dict to match BaseRepository.update signature
        updated_client = self.repository.update(client_id, updates)
        if updated_client:
            print(f"Client '{updated_client.full_name}' updated.")
        return updated_client


===============================================================================
FILE: ./app/controllers/contract_controller.py
------------------------------------------------------------------------------
META: 4413 bytes | modified: 2026-02-20 21:38:59
===============================================================================

# app/controllers/contract_controller.py
"""
Controller handling business logic for Contract management.
"""

from app.models.client import Client
from app.models.contract import Contract
from app.repositories.contract_repository import ContractRepository
from app.utils.decorators import require_auth


class ContractController:
    """Manages contract-related operations."""

    def __init__(self, repository: ContractRepository, auth_controller):
        self.repository = repository
        self.auth_controller = auth_controller

    @require_auth
    def list_all_contracts(self, user_data: dict):
        """
        Fetch all contracts if allowed.
        """
        self.auth_controller.current_user_data = user_data
        if self.auth_controller.check_user_permission("read_contract"):
            return self.repository.get_all_contracts()
        return None

    @require_auth
    def list_unsigned_contracts(self, user_data: dict):
        """List unsigned contracts, optionally filtered for sales ownership."""
        self.auth_controller.current_user_data = user_data
        if not self.auth_controller.check_user_permission("read_contract"):
            return None

        contracts = self.repository.get_unsigned_contracts()
        if user_data.get("department") == "SALES":
            return [
                c for c in contracts
                if c.sales_contact_id == user_data.get("id")
            ]
        return contracts

    @require_auth
    def list_unpaid_contracts(self, user_data: dict):
        """List unpaid contracts, optionally filtered for sales ownership."""
        self.auth_controller.current_user_data = user_data
        if not self.auth_controller.check_user_permission("read_contract"):
            return None

        contracts = self.repository.get_unpaid_contracts()
        if user_data.get("department") == "SALES":
            return [
                c for c in contracts
                if c.sales_contact_id == user_data.get("id")
            ]
        return contracts

    @require_auth
    def create_contract(self, user_data: dict, contract_data: dict):
        """Create a new contract for a client."""
        self.auth_controller.current_user_data = user_data
        if self.auth_controller.check_user_permission("create_contract"):
            if "sales_contact_id" not in contract_data:
                client_id = contract_data.get("client_id")
                if client_id is None:
                    print("Client ID is required to create a contract.")
                    return None

                client = (
                    self.repository.session.query(Client)
                    .filter_by(id=client_id)
                    .first()
                )
                if not client:
                    print("Client not found.")
                    return None

                contract_data["sales_contact_id"] = client.sales_contact_id

            new_contract = Contract(**contract_data)
            created_contract = self.repository.add(new_contract)

            if created_contract:
                print(f"Contract {created_contract.id} created successfully.")
            return created_contract

        print("Access denied: You do not have permission to create a contract.")
        return None

    @require_auth
    def update_contract(self, user_data: dict, contract_id: int, updates: dict):
        """Update contract details if user has permission."""
        self.auth_controller.current_user_data = user_data
        if not self.auth_controller.check_user_permission("update_contract"):
            print("Access denied: No update permission for contracts.")
            return None

        contract = self.repository.get_by_id(contract_id)
        if not contract:
            print("Contract not found.")
            return None

        # Logic: Sales can only update their own contracts. Management can
        # update all.
        is_owner = contract.sales_contact_id == user_data["id"]
        is_management = user_data["department"] == "MANAGEMENT"

        if not (is_owner or is_management):
            print("Access denied: You are not the assigned sales contact.")
            return None

        updated_contract = self.repository.update(contract_id, updates)
        if updated_contract:
            print(f"Contract {updated_contract.id} updated.")
        return updated_contract

===============================================================================
FILE: ./app/controllers/employee_controller.py
------------------------------------------------------------------------------
META: 2148 bytes | modified: 2026-02-19 12:32:55
===============================================================================

# app/controllers/employee_controller.py
"""
Controller handling business logic for Employee management.
"""

from app.models.employee import Employee
from app.repositories.employee_repository import EmployeeRepository
from app.utils.decorators import require_auth
from app.utils.auth import hash_password


class EmployeeController:
    """Manages employee-related operations."""

    def __init__(self, repository: EmployeeRepository, auth_controller):
        self.repository = repository
        self.auth_controller = auth_controller

    @require_auth
    def list_all_employees(self, user_data: dict):
        """
        Fetch all employees if the user has the 'read_employee' permission.
        """
        self.auth_controller.current_user_data = user_data

        if self.auth_controller.check_user_permission("read_employee"):
            return self.repository.get_all()

        return []

    @require_auth
    def create_employee(self, user_data: dict, employee_data: dict):
        """
        Create a new employee after permission check and password hashing.
        """
        self.auth_controller.current_user_data = user_data

        if not self.auth_controller.check_user_permission("create_employee"):
            return None

        # Hash the password before storage
        employee_data["password"] = hash_password(employee_data["password"])

        # Create the instance
        new_employee = Employee(**employee_data)

        # Pass the instance (not the dict) to the repository
        created_employee = self.repository.add(new_employee)
        return created_employee

    @require_auth
    def update_employee(self, user_data: dict, emp_id: int, update_data: dict):
        """
        Update an existing employee's data.
        """
        self.auth_controller.current_user_data = user_data

        if not self.auth_controller.check_user_permission("update_employee"):
            return None

        if "password" in update_data:
            update_data["password"] = hash_password(update_data["password"])

        updated_emp = self.repository.update(emp_id, update_data)
        return updated_emp

===============================================================================
FILE: ./app/controllers/event_controller.py
------------------------------------------------------------------------------
META: 3570 bytes | modified: 2026-02-20 22:02:15
===============================================================================

"""
Controller handling business logic for Event management.
"""

from app.models.event import Event
from app.repositories.event_repository import EventRepository
from app.utils.decorators import require_auth


class EventController:
    """Manages event-related operations."""

    def __init__(self, repository: EventRepository, auth_controller):
        self.repository = repository
        self.auth_controller = auth_controller

    @require_auth
    def list_all_events(self, user_data: dict):
        """
        Fetch all events if allowed.
        """
        self.auth_controller.current_user_data = user_data
        if self.auth_controller.check_user_permission("read_event"):
            return self.repository.get_all_events()
        return None

    @require_auth
    def list_events_without_support(self, user_data: dict):
        """List events that have no support contact assigned."""
        self.auth_controller.current_user_data = user_data
        if not self.auth_controller.check_user_permission("read_event"):
            return None
        return self.repository.get_events_without_support()

    @require_auth
    def list_my_events(self, user_data: dict):
        """List events assigned to the current support user."""
        self.auth_controller.current_user_data = user_data
        if not self.auth_controller.check_user_permission("read_event"):
            return None
        support_id = user_data.get("id")
        if support_id is None:
            return None
        return self.repository.get_my_events(support_id)

    @require_auth
    def create_event(self, user_data: dict, event_data: dict, contract):
        """
        Create a new event if the contract is signed and user is the owner.
        """
        self.auth_controller.current_user_data = user_data
        if not self.auth_controller.check_user_permission("create_event"):
            print("Access denied: No permission to create events.")
            return None

        if contract.sales_contact_id != user_data["id"]:
            print("Access denied: You are not the sales contact for this client.")
            return None

        if not contract.is_signed:
            print("Access denied: Cannot create an event for an unsigned contract.")
            return None

        new_event = Event(**event_data)
        created_event = self.repository.add(new_event)

        if created_event:
            print(f"Event '{created_event.name}' created successfully.")
        return created_event

    @require_auth
    def update_event(self, user_data: dict, event_id: int, updates: dict):
        """Update event details if user is assigned support or management."""
        self.auth_controller.current_user_data = user_data
        if not self.auth_controller.check_user_permission("update_event"):
            print("Access denied: No update permission for events.")
            return None

        event = self.repository.get_by_id(event_id)
        if not event:
            print("Event not found.")
            return None

        # Logic: Support assigned or Management can update
        is_assigned = event.support_contact_id == user_data["id"]
        is_management = user_data["department"] == "MANAGEMENT"

        if not (is_assigned or is_management):
            print("Access denied: You are not the assigned support contact.")
            return None

        updated_event = self.repository.update(event_id, updates)
        if updated_event:
            print(f"Event '{updated_event.name}' updated.")
        return updated_event

===============================================================================
FILE: ./app/models/__init__.py
------------------------------------------------------------------------------
META: 506 bytes | modified: 2026-02-17 10:19:40
===============================================================================

# app/models/__init__.py
"""
This module centralizes all SQLAlchemy models to facilitate imports
and ensure they are registered with the Base metadata for migrations.
"""

from app.models.base import Base
from app.models.department import Department
from app.models.employee import Employee
from app.models.client import Client
from app.models.contract import Contract
from app.models.event import Event

__all__ = [
    "Base",
    "Department",
    "Employee",
    "Client",
    "Contract",
    "Event"
]

===============================================================================
FILE: ./app/models/base.py
------------------------------------------------------------------------------
META: 1432 bytes | modified: 2026-02-16 20:25:17
===============================================================================

# app/models/base.py
"""
This module serves as the foundation for the ORM layer.
- Provides a centralized DeclarativeBase for model registration.
- Defines custom type aliases (Annotated) to standardize SQL constraints
  (String lengths, Primary Keys, and Timestamps) across the entire schema.
- Uses server-side functions for automated audit trails (created_at, updated_at).
"""
import datetime
from typing import Annotated
from sqlalchemy import String, Text, func
from sqlalchemy.orm import DeclarativeBase, mapped_column


# Type aliases to ensure consistency across all models
# Primary keys with auto-increment
pk_id = Annotated[int, mapped_column(primary_key=True, autoincrement=True)]

# Standard string lengths for database columns
str_20 = Annotated[str, mapped_column(String(20))]
str_50 = Annotated[str, mapped_column(String(50))]
str_100 = Annotated[str, mapped_column(String(100))]
str_255 = Annotated[str, mapped_column(String(255))]

# Long text for descriptions or notes
text_type = Annotated[str, mapped_column(Text)]

# Automatically managed timestamps
timestamp_now = Annotated[
    datetime.datetime,
    mapped_column(server_default=func.now())
]
timestamp_update = Annotated[
    datetime.datetime,
    mapped_column(server_default=func.now(), onupdate=func.now())
]


class Base(DeclarativeBase):
    """
    Base class for declarative models.
    Maintains a registry of all mapped classes.
    """
    pass

===============================================================================
FILE: ./app/models/client.py
------------------------------------------------------------------------------
META: 1701 bytes | modified: 2026-02-19 21:47:37
===============================================================================

# app/models/client.py
"""
This module defines the Client model, which stores customer information,
contact details, and handles relationships with sales employees,
contracts, and events.
"""

from typing import TYPE_CHECKING
from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import (
    Base,
    pk_id,
    str_50,
    str_100,
    str_20,
    timestamp_now,
    timestamp_update
)

if TYPE_CHECKING:
    from app.models.employee import Employee
    from app.models.event import Event
    from app.models.contract import Contract


class Client(Base):
    """
    Represents a customer in the CRM system.
    """

    __tablename__ = "client"

    id: Mapped[pk_id]
    full_name: Mapped[str_50]
    email: Mapped[str_100] = mapped_column(unique=True)
    phone: Mapped[str_20]
    company_name: Mapped[str_50]

    # New field for last business contact
    last_contact: Mapped[timestamp_now]

    # Audit timestamps
    creation_date: Mapped[timestamp_now]
    last_update: Mapped[timestamp_update]

    # Foreign Key to the Sales Contact (Employee)
    sales_contact_id: Mapped[int | None] = mapped_column(
        ForeignKey("employee.id"),
        nullable=True,
    )

    # Relationships
    sales_contact: Mapped["Employee"] = relationship(
        back_populates="managed_clients"
    )
    contracts: Mapped[list["Contract"]] = relationship(
        back_populates="client"
    )
    events: Mapped[list["Event"]] = relationship(
        back_populates="client"
    )

    def __repr__(self) -> str:
        return (
            f"<Client(name={self.full_name}, "
            f"company={self.company_name})>"
        )


===============================================================================
FILE: ./app/models/contract.py
------------------------------------------------------------------------------
META: 1639 bytes | modified: 2026-02-19 12:22:24
===============================================================================

# app/models/contract.py
"""
This module defines the Contract model, which stores financial agreements
with clients, including amounts, payment status, and audit timestamps.
"""

from typing import TYPE_CHECKING
from sqlalchemy import ForeignKey, Boolean, Numeric
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import (
    Base,
    pk_id,
    timestamp_now,
    timestamp_update
)

if TYPE_CHECKING:
    from app.models.client import Client
    from app.models.event import Event
    from app.models.employee import Employee


class Contract(Base):
    """
    Represents a financial agreement with a client.
    """

    __tablename__ = "contract"

    id: Mapped[pk_id]
    total_amount: Mapped[float] = mapped_column(Numeric(10, 2))
    remaining_amount: Mapped[float] = mapped_column(Numeric(10, 2))
    is_signed: Mapped[bool] = mapped_column(Boolean, default=False)

    # Audit timestamps
    creation_date: Mapped[timestamp_now]
    last_update: Mapped[timestamp_update]

    # Foreign Keys
    client_id: Mapped[int] = mapped_column(ForeignKey("client.id"))
    sales_contact_id: Mapped[int] = mapped_column(ForeignKey("employee.id"))

    # Relationships
    client: Mapped["Client"] = relationship(back_populates="contracts")
    sales_contact: Mapped["Employee"] = relationship(
        back_populates="managed_contracts"
    )
    event: Mapped["Event"] = relationship(back_populates="contract")

    def __repr__(self) -> str:
        return (
            f"<Contract(id={self.id}, "
            f"remaining={self.remaining_amount}, "
            f"signed={self.is_signed})>"
        )

===============================================================================
FILE: ./app/models/department.py
------------------------------------------------------------------------------
META: 815 bytes | modified: 2026-02-17 10:18:39
===============================================================================

# app/models/department.py
"""
This module defines the Department model, which represents the different
business units within the company and manages their relationship with employees.
"""

from typing import TYPE_CHECKING
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import Base, pk_id, str_50

if TYPE_CHECKING:
    from app.models.employee import Employee


class Department(Base):
    """
    Represents a business unit (MANAGEMENT, SALES, or SUPPORT).
    """

    __tablename__ = "department"

    id: Mapped[pk_id]
    name: Mapped[str_50] = mapped_column(unique=True)

    # Relationships
    employees: Mapped[list["Employee"]] = relationship(
        back_populates="department"
    )

    def __repr__(self) -> str:
        return f"<Department(name={self.name})>"

===============================================================================
FILE: ./app/models/employee.py
------------------------------------------------------------------------------
META: 1669 bytes | modified: 2026-02-19 12:24:48
===============================================================================

# app/models/employee.py
"""
This module defines the Employee model, which stores staff member information,
credentials, and their association with departments and managed entities
such as clients and events.
"""

from typing import TYPE_CHECKING
from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import Base, pk_id, str_50, str_100, str_255, str_20

if TYPE_CHECKING:
    from app.models.department import Department
    from app.models.client import Client
    from app.models.event import Event
    from app.models.contract import Contract


class Employee(Base):
    """
    Represents a staff member of Epic Events.
    """

    __tablename__ = "employee"

    id: Mapped[pk_id]
    full_name: Mapped[str_50]
    email: Mapped[str_100] = mapped_column(unique=True)
    password: Mapped[str_255]
    employee_number: Mapped[str_20] = mapped_column(unique=True)

    # Foreign Key to Department
    department_id: Mapped[int] = mapped_column(ForeignKey("department.id"))

    # Relationships
    department: Mapped["Department"] = relationship(back_populates="employees")

    # Managed entities (Sales/Support roles)
    managed_clients: Mapped[list["Client"]] = relationship(
        back_populates="sales_contact"
    )
    managed_contracts: Mapped[list["Contract"]] = relationship(
        back_populates="sales_contact"
    )
    assigned_events: Mapped[list["Event"]] = relationship(
        back_populates="support_contact"
    )

    def __repr__(self) -> str:
        return (
            f"<Employee(name={self.full_name}, "
            f"department_id={self.department_id})>"
        )

===============================================================================
FILE: ./app/models/event.py
------------------------------------------------------------------------------
META: 1688 bytes | modified: 2026-02-19 12:28:31
===============================================================================

# app/models/event.py
"""
This module defines the Event model, representing a scheduled event
linked to a client, a contract, and potentially a support employee.
"""

from typing import TYPE_CHECKING, Optional
from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import (
    Base,
    pk_id,
    str_50,
    text_type,
    timestamp_now,
    timestamp_update
)

if TYPE_CHECKING:
    from app.models.client import Client
    from app.models.employee import Employee
    from app.models.contract import Contract


class Event(Base):
    """
    Represents a scheduled event for a specific client and contract.
    """

    __tablename__ = "event"

    id: Mapped[pk_id]
    name: Mapped[str_50]
    event_date_start: Mapped[timestamp_now]
    event_date_end: Mapped[timestamp_now]
    location: Mapped[str_50]
    attendees: Mapped[int]
    notes: Mapped[text_type]

    # Audit timestamps
    creation_date: Mapped[timestamp_now]
    last_update: Mapped[timestamp_update]

    # Foreign Keys
    client_id: Mapped[int] = mapped_column(ForeignKey("client.id"))
    contract_id: Mapped[int] = mapped_column(ForeignKey("contract.id"))
    support_contact_id: Mapped[Optional[int]] = mapped_column(
        ForeignKey("employee.id"), nullable=True
    )

    # Relationships
    client: Mapped["Client"] = relationship(back_populates="events")
    contract: Mapped["Contract"] = relationship(back_populates="event")
    support_contact: Mapped["Employee"] = relationship(
        back_populates="assigned_events"
    )

    def __repr__(self) -> str:
        return f"<Event(name={self.name}, start={self.event_date_start})>"

===============================================================================
FILE: ./app/repositories/base_repository.py
------------------------------------------------------------------------------
META: 2599 bytes | modified: 2026-02-19 18:41:26
===============================================================================

# app/repositories/base_repository.py
"""
This module defines the BaseRepository class using Generics.
It provides a standardized interface for common database operations (CRUD)
shared across all specific repositories.
"""

from typing import Generic, TypeVar, Type, Optional, List
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
import sentry_sdk
from app.models.base import Base

T = TypeVar("T", bound=Base)


class BaseRepository(Generic[T]):
    """
    Base class for data access logic.
    """

    def __init__(self, session: Session, model: Type[T]):
        self.session = session
        self.model = model

    def get_by_id(self, obj_id: int) -> Optional[T]:
        """Fetch a single record by its primary key."""
        return self.session.query(self.model).filter(
            self.model.id == obj_id
        ).first()

    def get_all(self) -> List[T]:
        """Fetch all records for this model."""
        return self.session.query(self.model).all()

    def add(self, obj: T) -> T:
        """Add a new object and commit the transaction."""
        try:
            self.session.add(obj)
            self.session.commit()
            self.session.refresh(obj)
            return obj
        except IntegrityError as e:
            # Capture database constraint violations (e.g., duplicate email)
            self.session.rollback()
            sentry_sdk.capture_exception(e)
            raise e
        except SQLAlchemyError as e:
            # Capture any other database-related errors
            self.session.rollback()
            sentry_sdk.capture_exception(e)
            raise e

    def update(self, obj_id: int, update_data: dict) -> Optional[T]:
        """Update a record and commit the transaction."""
        obj = self.get_by_id(obj_id)
        if obj:
            try:
                for key, value in update_data.items():
                    if hasattr(obj, key):
                        setattr(obj, key, value)
                self.session.commit()
                self.session.refresh(obj)
                return obj
            except SQLAlchemyError as e:
                self.session.rollback()
                sentry_sdk.capture_exception(e)
                raise e
        return None

    def delete(self, obj: T) -> None:
        """Remove an object and commit the transaction."""
        try:
            self.session.delete(obj)
            self.session.commit()
        except SQLAlchemyError as e:
            self.session.rollback()
            sentry_sdk.capture_exception(e)
            raise e

===============================================================================
FILE: ./app/repositories/client_repository.py
------------------------------------------------------------------------------
META: 872 bytes | modified: 2026-02-19 17:19:30
===============================================================================

# app/repositories/client_repository.py
"""
Data access layer for Client-specific operations.
"""

from typing import Optional, List
from sqlalchemy.orm import Session
from app.models.client import Client
from app.repositories.base_repository import BaseRepository


class ClientRepository(BaseRepository[Client]):
    """
    Repository handling Client database queries.
    """

    def __init__(self, session: Session):
        super().__init__(session, Client)

    def get_all_clients(self) -> List[Client]:
        """
        Fetch all clients by calling the inherited get_all method.
        """
        return self.get_all()

    def get_by_email(self, email: str) -> Optional[Client]:
        """
        Fetch a client by its unique email.
        """
        return self.session.query(self.model).filter(
            self.model.email == email
        ).first()

===============================================================================
FILE: ./app/repositories/contract_repository.py
------------------------------------------------------------------------------
META: 1177 bytes | modified: 2026-02-19 17:20:31
===============================================================================

# app/repositories/contract_repository.py
"""
Data access layer for Contract-specific operations.
"""

from typing import List, Optional
from sqlalchemy.orm import Session
from app.models.contract import Contract
from app.repositories.base_repository import BaseRepository


class ContractRepository(BaseRepository[Contract]):
    """
    Repository handling Contract database queries.
    """

    def __init__(self, session: Session):
        super().__init__(session, Contract)

    def get_all_contracts(self) -> List[Contract]:
        """
        Fetch all contracts by calling the inherited get_all method.
        """
        return self.get_all()

    def get_unsigned_contracts(self) -> List[Contract]:
        """
        Fetch all contracts that are not yet signed.
        """
        return self.session.query(self.model).filter(
            self.model.is_signed == False  # noqa: E712
        ).all()

    def get_unpaid_contracts(self) -> List[Contract]:
        """
        Fetch contracts where remaining amount is greater than zero.
        """
        return self.session.query(self.model).filter(
            self.model.remaining_amount > 0
        ).all()

===============================================================================
FILE: ./app/repositories/department_repository.py
------------------------------------------------------------------------------
META: 932 bytes | modified: 2026-02-19 17:32:16
===============================================================================

# app/repositories/department_repository.py
"""
This module specializes the BaseRepository for the Department model.
"""

from typing import Optional, List
from sqlalchemy.orm import Session
from app.models.department import Department
from app.repositories.base_repository import BaseRepository


class DepartmentRepository(BaseRepository[Department]):
    """
    Data access layer for Department-specific operations.
    """

    def __init__(self, session: Session):
        super().__init__(session, Department)

    def get_all_departments(self) -> List[Department]:
        """
        Fetch all departments using the base repository method.
        """
        return self.get_all()

    def get_by_name(self, name: str) -> Optional[Department]:
        """
        Fetch a department by its unique name.
        """
        return self.session.query(self.model).filter(
            self.model.name == name
        ).first()

===============================================================================
FILE: ./app/repositories/employee_repository.py
------------------------------------------------------------------------------
META: 1304 bytes | modified: 2026-02-18 15:01:28
===============================================================================

# app/repositories/employee_repository.py
"""
This module specializes the BaseRepository for the Employee model.
It provides specific lookup methods necessary for authentication
and staff management.
"""

from typing import Optional
from sqlalchemy.orm import Session
from app.models.employee import Employee
from app.repositories.base_repository import BaseRepository


class EmployeeRepository(BaseRepository[Employee]):
    """
    Data access layer for Employee-specific operations.
    """

    def __init__(self, session: Session):
        super().__init__(session, Employee)

    def get_all_employees(self):
        """
        Fetch all employees using the base repository method.
        """
        return self.get_all()

    def get_by_email(self, email: str) -> Optional[Employee]:
        """
        Fetch an employee by their unique email address.
        Used for authentication.
        """
        return self.session.query(self.model).filter(
            self.model.email == email
        ).first()

    def get_by_employee_number(self, emp_number: str) -> Optional[Employee]:
        """
        Fetch an employee by their unique employee number.
        """
        return self.session.query(self.model).filter(
            self.model.employee_number == emp_number
        ).first()

===============================================================================
FILE: ./app/repositories/event_repository.py
------------------------------------------------------------------------------
META: 1176 bytes | modified: 2026-02-19 17:21:34
===============================================================================

# app/repositories/event_repository.py
"""
Data access layer for Event-specific operations.
"""

from typing import List, Optional
from sqlalchemy.orm import Session
from app.models.event import Event
from app.repositories.base_repository import BaseRepository


class EventRepository(BaseRepository[Event]):
    """
    Repository handling Event database queries.
    """

    def __init__(self, session: Session):
        super().__init__(session, Event)

    def get_all_events(self) -> List[Event]:
        """
        Fetch all events by calling the inherited get_all method.
        """
        return self.get_all()

    def get_events_without_support(self) -> List[Event]:
        """
        Fetch all events that have no support contact assigned.
        """
        return self.session.query(self.model).filter(
            self.model.support_contact_id == None  # noqa: E711
        ).all()

    def get_my_events(self, support_id: int) -> List[Event]:
        """
        Fetch events assigned to a specific support employee.
        """
        return self.session.query(self.model).filter(
            self.model.support_contact_id == support_id
        ).all()

===============================================================================
FILE: ./app/utils/auth.py
------------------------------------------------------------------------------
META: 787 bytes | modified: 2026-02-18 10:28:13
===============================================================================

# app/utils/auth.py
"""
This module handles secure password management using the Argon2 hashing
algorithm. It provides utilities for hashing plain text passwords and
verifying them against stored hashes.
"""

from argon2 import PasswordHasher
from argon2.exceptions import VerifyMismatchError, InvalidHashError

# Initialize the hasher with default secure parameters
ph = PasswordHasher()


def hash_password(password: str) -> str:
    """
    Hash a password using Argon2.
    """
    return ph.hash(password)


def verify_password(hashed_password: str, plain_password: str) -> bool:
    """
    Verify a password against its Argon2 hash.
    """
    try:
        return ph.verify(hashed_password, plain_password)
    except (VerifyMismatchError, InvalidHashError):
        return False

===============================================================================
FILE: ./app/utils/decorators.py
------------------------------------------------------------------------------
META: 2128 bytes | modified: 2026-02-20 17:03:28
===============================================================================

# app/utils/decorators.py
"""
Authentication decorators for controller methods.
Ensures user_data is available via token or arguments.
"""

from functools import wraps
from typing import Any, Callable

import sentry_sdk

from app.utils.jwt_handler import decode_token
from app.utils.token_storage import get_token


# Handles dynamic `user_data` injection from kwargs, args, controller state, or token.
def require_auth(func: Callable) -> Callable:
    """
    Decorator that ensures a user is authenticated before executing a method.
    Injects user_data into kwargs to avoid shifting positional arguments.
    """

    def is_user_data(value: Any) -> bool:
        if not isinstance(value, dict):
            return False
        return "id" in value and "department" in value

    @wraps(func)
    def wrapper(self, *args, **kwargs) -> Any:
        sentry_sdk.add_breadcrumb(
            category="auth",
            message=f"Checking authentication for {func.__name__}",
            level="info",
        )

        user_data = kwargs.get("user_data")

        if not user_data and args and is_user_data(args[0]):
            user_data = args[0]

        if not user_data and hasattr(self, "auth_controller"):
            auth_ctrl = getattr(self, "auth_controller")
            current = getattr(auth_ctrl, "current_user_data", None)
            if current:
                user_data = current

        if not user_data:
            token = get_token()
            if token:
                user_data = decode_token(token)

        if not user_data:
            sentry_sdk.add_breadcrumb(
                category="auth",
                message="Authentication failed: No user data found",
                level="warning",
            )
            return None

        if "user_data" in kwargs:
            return func(self, *args, **kwargs)

        if args and is_user_data(args[0]):
            return func(self, *args, **kwargs)

        try:
            return func(self, *args, user_data=user_data, **kwargs)
        except TypeError:
            return func(self, user_data, *args, **kwargs)

    return wrapper


===============================================================================
FILE: ./app/utils/jwt_handler.py
------------------------------------------------------------------------------
META: 1606 bytes | modified: 2026-02-20 17:43:20
===============================================================================

# app/utils/jwt_handler.py
"""
This module handles JSON Web Token (JWT) generation and validation.
It ensures that user sessions are persistent, secure, and include
expiration logic as required by the technical specifications.
"""

import os
import datetime
from typing import Optional
import jwt
import sentry_sdk


# Configuration from environment variables
SECRET_KEY = os.getenv("JWT_SECRET", "default-secret-key-to-change")
ALGORITHM = os.getenv("JWT_ALGORITHM", "HS256")
TOKEN_EXPIRATION_HOURS = 12


def create_token(employee_id: int, department_name: str) -> str:
    """
    Generate a JWT token containing employee ID and department.
    The token is set to expire in 12 hours.
    """
    now = datetime.datetime.now(datetime.UTC)
    payload = {
        "sub": str(employee_id),
        "id": employee_id,
        "department": department_name,
        "iat": int(now.timestamp()),
        "exp": int(
            (now + datetime.timedelta(hours=TOKEN_EXPIRATION_HOURS)).timestamp()
        ),
    }
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)


def decode_token(token: str) -> Optional[dict]:
    """
    Decode and validate a JWT token.
    Returns the payload if valid, or None if expired/invalid.
    """
    try:
        return jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    except jwt.ExpiredSignatureError as e:
        sentry_sdk.capture_exception(e)
        return None
    except jwt.InvalidTokenError as e:
        # Debug print for development phase
        print(f"DEBUG Decode Error: {e}")
        sentry_sdk.capture_exception(e)
        return None

===============================================================================
FILE: ./app/utils/permissions.py
------------------------------------------------------------------------------
META: 1399 bytes | modified: 2026-02-20 21:54:41
===============================================================================

# app/utils/permissions.py
"""
This module provides a centralized authorization system mapping
specific actions to departments to determine user permissions.
"""

import sentry_sdk

# Mapping of permissions per department
PERMISSIONS = {
    'MANAGEMENT': [
        'read_client',
        'update_client',
        'read_contract',
        'create_contract',
        'update_contract',
        'read_event',
        'update_event',
        'read_employee',
        'create_employee',
        'update_employee',
        'delete_employee'
    ],
    'SALES': [
        'read_client',
        'create_client',
        'update_client',
        'read_contract',
        'update_contract',
        'read_event',
        'create_event'
    ],
    'SUPPORT': [
        'read_client',
        'read_contract',
        'read_event',
        'update_event'
    ]
}


def has_permission(action: str, department_name: str) -> bool:
    """
    Check if a specific department has the required permission.
    """
    allowed_actions = PERMISSIONS.get(department_name, [])
    is_allowed = action in allowed_actions

    if not is_allowed:
        # Log unauthorized access attempts to Sentry as a warning
        sentry_sdk.capture_message(
            f"Access denied: Department '{department_name}' "
            f"tried to perform action '{action}'",
            level="warning"
        )

    return is_allowed

===============================================================================
FILE: ./app/utils/token_storage.py
------------------------------------------------------------------------------
META: 889 bytes | modified: 2026-02-18 09:53:44
===============================================================================

# app/utils/token_storage.py
"""
This module manages the local persistence of the JWT token.
It provides functions to save, retrieve, and delete the token from
a local file to maintain user sessions across CLI executions.
"""

import os
from typing import Optional

TOKEN_FILE = ".token"


def save_token(token: str) -> None:
    """
    Save the JWT token to a local hidden file.
    """
    with open(TOKEN_FILE, "w", encoding="utf-8") as f:
        f.write(token)


def get_token() -> Optional[str]:
    """
    Retrieve the JWT token from the local file if it exists.
    """
    if os.path.exists(TOKEN_FILE):
        with open(TOKEN_FILE, "r", encoding="utf-8") as f:
            return f.read().strip()
    return None


def delete_token() -> None:
    """
    Remove the local token file to log out the user.
    """
    if os.path.exists(TOKEN_FILE):
        os.remove(TOKEN_FILE)

===============================================================================
FILE: ./app/views/auth_view.py
------------------------------------------------------------------------------
META: 779 bytes | modified: 2026-02-18 09:23:53
===============================================================================

# app/views/auth_view.py
"""
View for authentication related interactions.
Handles login inputs and success/failure messages.
"""

from app.views.base_view import BaseView


class AuthView(BaseView):
    """Handles login inputs."""

    def ask_login_details(self) -> tuple[str, str]:
        """Prompt user for email and password."""
        print("\n=== Epic Events CRM - Login ===")
        email = self.ask_input("Email")
        password = self.ask_input("Password")
        return email, password

    def display_login_success(self):
        """Confirm successful login."""
        self.display_message("Login successful! Welcome.")

    def display_login_failure(self):
        """Warn about failed credentials."""
        self.display_error("Invalid email or password.")

===============================================================================
FILE: ./app/views/base_view.py
------------------------------------------------------------------------------
META: 1729 bytes | modified: 2026-02-19 09:48:26
===============================================================================

# app/views/base_view.py
"""
Base class for all views in the application.
Provides common display methods and input validation for CLI interaction.
"""

import re
from datetime import datetime


class BaseView:
    """Provides common display methods and input validation for CLI."""

    def display_message(self, message: str):
        """Display a simple text message."""
        print(f"\n{message}")

    def display_error(self, message: str):
        """Display an error message formatted for visibility."""
        print(f"\n[ERROR] {message}")

    def ask_input(self, prompt: str) -> str:
        """Helper to get user input."""
        return input(f"{prompt}: ").strip()

    def validate_email(self, email: str) -> bool:
        """Check if the email format is valid."""
        pattern = r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$"
        if re.match(pattern, email):
            return True
        self.display_error("Invalid email format (ex: name@domain.com).")
        return False

    def validate_amount(self, amount: str) -> bool:
        """Check if the amount is a positive number."""
        try:
            val = float(amount)
            if val >= 0:
                return True
            self.display_error("Amount must be a positive value.")
        except ValueError:
            self.display_error("Amount must be a numeric value.")
        return False

    def validate_date(self, date_str: str) -> bool:
        """Check if the date format is valid (DD-MM-YYYY)."""
        try:
            datetime.strptime(date_str, "%d-%m-%Y")
            return True
        except ValueError:
            self.display_error("Invalid date format. Please use DD-MM-YYYY.")
            return False

===============================================================================
FILE: ./app/views/client_view.py
------------------------------------------------------------------------------
META: 1792 bytes | modified: 2026-02-20 20:49:45
===============================================================================

"""
View for Client related interactions.
"""
from app.views.base_view import BaseView


class ClientView(BaseView):
    """Handles client display and inputs."""

    def display_clients(self, clients: list):
        """Print the list of all clients."""
        print("\n=== Clients List ===")
        if not clients:
            print("No clients found.")
            return
        for client in clients:
            print(
                f"ID: {client.id} | Name: {client.full_name} | "
                f"Email: {client.email} | Company: {client.company_name} | "
                f"Last Contact: {client.last_contact}"
            )

    def ask_client_details(self) -> dict:
        """Prompt user for new client information."""
        print("\n=== Add New Client ===")
        return {
            "full_name": self.ask_input("Full Name"),
            "email": self.ask_input("Email"),
            "phone": self.ask_input("Phone"),
            "company_name": self.ask_input("Company Name"),
            "last_contact": self.ask_input(
                "Last Contact Date (YYYY-MM-DD HH:MM:SS) "
                "[Leave empty for now]"
            )
        }

    def ask_client_update_details(self) -> dict:
        """Prompt user for client update information."""
        print("\n=== Update Client ===")
        return {
            "full_name": self.ask_input("Full Name [Leave empty to skip]"),
            "email": self.ask_input("Email [Leave empty to skip]"),
            "phone": self.ask_input("Phone [Leave empty to skip]"),
            "company_name": self.ask_input("Company Name [Leave empty to skip]"),
            "last_contact": self.ask_input(
                "Last Contact Date (YYYY-MM-DD HH:MM:SS) "
                "[Leave empty to skip]"
            ),
        }

===============================================================================
FILE: ./app/views/contract_view.py
------------------------------------------------------------------------------
META: 1649 bytes | modified: 2026-02-20 20:49:56
===============================================================================

"""
View for Contract related interactions.
"""
from app.views.base_view import BaseView


class ContractView(BaseView):
    """Handles contract display and inputs."""

    def display_contracts(self, contracts: list):
        """Print the list of all contracts."""
        print("\n=== Contracts List ===")
        if not contracts:
            print("No contracts found.")
            return
        for contract in contracts:
            status = "Signed" if contract.is_signed else "Not Signed"
            print(
                f"ID: {contract.id} | Client: {contract.client.full_name} | "
                f"Sales Contact: {contract.sales_contact.full_name} | "
                f"Total: {contract.total_amount} | Status: {status}"
            )

    def ask_contract_details(self) -> dict:
        """Prompt user for new contract information."""
        print("\n=== Add New Contract ===")
        return {
            "client_id": self.ask_input("Client ID"),
            "total_amount": self.ask_input("Total Amount"),
            "remaining_amount": self.ask_input("Remaining Amount"),
            "is_signed": self.ask_input("Is Signed (y/n) [Leave empty for n]"),
        }

    def ask_contract_update_details(self) -> dict:
        """Prompt user for contract update information."""
        print("\n=== Update Contract ===")
        return {
            "total_amount": self.ask_input("Total Amount [Leave empty to skip]"),
            "remaining_amount": self.ask_input(
                "Remaining Amount [Leave empty to skip]"
            ),
            "is_signed": self.ask_input("Is Signed (y/n) [Leave empty to skip]"),
        }

===============================================================================
FILE: ./app/views/employee_view.py
------------------------------------------------------------------------------
META: 2289 bytes | modified: 2026-02-19 11:14:13
===============================================================================

# app/views/employee_view.py
"""
View for Employee related interactions.
"""
from app.views.base_view import BaseView


class EmployeeView(BaseView):
    """Handles employee display and inputs."""

    def display_employees(self, employees: list):
        """Print the list of all employees."""
        print("\n=== Employees List ===")
        if not employees:
            print("No employees found.")
            return
        for emp in employees:
            dept_name = emp.department.name if emp.department else "N/A"
            print(
                f"ID: {emp.id} | No: {emp.employee_number} | "
                f"Name: {emp.full_name} | Email: {emp.email} | "
                f"Dept: {dept_name}"
            )

    def ask_employee_details(self) -> dict:
        """Prompt user for new employee information."""
        print("\n=== Add New Employee ===")

        full_name = self.ask_input("Full Name")

        while True:
            email = self.ask_input("Email")
            if self.validate_email(email):
                break

        password = self.ask_input("Password")
        employee_number = self.ask_input("Employee Number")
        department_id = self.ask_input(
            "Department ID (1: Sales, 2: Support, 3: Management)"
        )

        return {
            "full_name": full_name,
            "email": email,
            "password": password,
            "employee_number": employee_number,
            "department_id": int(department_id) if department_id.isdigit() else 0
        }

    def ask_update_details(self) -> dict:
        """Prompt user for employee updates (all fields optional)."""
        print("\n=== Update Employee (Leave blank to keep current value) ===")

        full_name = self.ask_input("New Full Name (optional)")
        email = self.ask_input("New Email (optional)")
        password = self.ask_input("New Password (optional)")
        dept_id = self.ask_input("New Dept ID (optional)")

        details = {}
        if full_name:
            details["full_name"] = full_name
        if email:
            details["email"] = email
        if password:
            details["password"] = password
        if dept_id:
            details["department_id"] = int(dept_id) if dept_id.isdigit() else 0

        return details

===============================================================================
FILE: ./app/views/event_view.py
------------------------------------------------------------------------------
META: 2133 bytes | modified: 2026-02-20 20:50:06
===============================================================================

"""
View for Event related interactions.
"""
from app.views.base_view import BaseView


class EventView(BaseView):
    """Handles event display and inputs."""

    def display_events(self, events: list):
        """Print the list of all events."""
        print("\n=== Events List ===")
        if not events:
            print("No events found.")
            return
        for event in events:
            support = (
                event.support_contact.full_name
                if event.support_contact
                else "TBD"
            )
            print(
                f"ID: {event.id} | Name: {event.name} | "
                f"From: {event.event_date_start} To: {event.event_date_end} | "
                f"Support: {support}"
            )

    def ask_event_details(self) -> dict:
        """Prompt user for new event information."""
        print("\n=== Add New Event ===")
        return {
            "name": self.ask_input("Event Name"),
            "event_date_start": self.ask_input(
                "Event Start (YYYY-MM-DD HH:MM:SS)"
            ),
            "event_date_end": self.ask_input(
                "Event End (YYYY-MM-DD HH:MM:SS)"
            ),
            "location": self.ask_input("Location"),
            "attendees": self.ask_input("Attendees"),
            "notes": self.ask_input("Notes"),
        }

    def ask_event_update_details(self) -> dict:
        """Prompt user for event update information."""
        print("\n=== Update Event ===")
        return {
            "event_date_start": self.ask_input(
                "Event Start (YYYY-MM-DD HH:MM:SS) [Leave empty to skip]"
            ),
            "event_date_end": self.ask_input(
                "Event End (YYYY-MM-DD HH:MM:SS) [Leave empty to skip]"
            ),
            "location": self.ask_input("Location [Leave empty to skip]"),
            "attendees": self.ask_input("Attendees [Leave empty to skip]"),
            "notes": self.ask_input("Notes [Leave empty to skip]"),
            "support_contact_id": self.ask_input(
                "Support Contact ID [Leave empty to skip]"
            ),
        }

===============================================================================
FILE: ./app/views/main_menu_view.py
------------------------------------------------------------------------------
META: 1492 bytes | modified: 2026-02-20 20:05:26
===============================================================================

# app/views/main_menu_view.py
"""
Main menu view for the CRM application.
Adapts displayed options based on user department.
"""

from app.views.base_view import BaseView


class MainMenuView(BaseView):
    """Controller view for the main menu."""

    def display_menu(self, department: str):
        """Print the main menu options according to department."""
        print(f"\n=== Epic Events CRM - {department} Menu ===")
        print("1. List all clients")
        print("2. List all contracts")
        print("3. List all events")

        if department == "MANAGEMENT":
            print("4. List all employees")
            print("5. Create new employee")
            print("6. Update an employee")
            print("7. Create new contract")
            print("8. Update a contract")
            print("9. Assign support to an event")
            print("10. List events without support")
        elif department == "SALES":
            print("20. Create new client")
            print("21. Update a client")
            print("22. Update a contract")
            print("23. List unsigned contracts")
            print("24. List unpaid contracts")
            print("25. Create new event")
        elif department == "SUPPORT":
            print("30. List my events")
            print("31. Update my events")

        print("0. Logout and Exit")

    def ask_menu_option(self) -> str:
        """Ask the user for a menu option."""
        return input("\nSelect an option: ").strip()

===============================================================================
FILE: ./check_auth.py
------------------------------------------------------------------------------
META: 532 bytes | modified: 2026-02-18 10:06:15
===============================================================================

# check_auth.py
from app.utils.auth import hash_password, verify_password

password_to_test = "admin123"
# Le hash exact que vous avez mis dans le SQL
sql_hash = "$argon2id$v=19$m=65536,t=3,p=4$7Y5Wp8W1S6lF6z1N2q9Q5w$O7N8/v5J8J8"

# 1. Test de vÃ©rification
is_valid = verify_password(password_to_test, sql_hash)
print(f"Match SQL hash: {is_valid}")

# 2. Test de gÃ©nÃ©ration
new_hash = hash_password(password_to_test)
print(f"New hash generated: {new_hash}")
print(f"Match new hash: {verify_password(password_to_test, new_hash)}")

===============================================================================
FILE: ./config/config.py
------------------------------------------------------------------------------
META: 699 bytes | modified: 2026-02-19 10:37:14
===============================================================================

# config/config.py
import os
from dotenv import load_dotenv

# Load variables from .env file
load_dotenv()


class Config:
    """Configuration loader for environment variables."""
    DB_USER = os.getenv("DB_USER")
    DB_PASSWORD = os.getenv("DB_PASSWORD")
    DB_HOST = os.getenv("DB_HOST")
    DB_PORT = os.getenv("DB_PORT")
    DB_NAME = os.getenv("DB_NAME")
    SECRET_KEY = os.getenv("SECRET_KEY")
    SENTRY_DSN = os.getenv("SENTRY_DSN")

    @classmethod
    def get_db_url(cls):
        """Return formatted SQLAlchemy database URL."""
        return (
            f"mysql+mysqlconnector://{cls.DB_USER}:{cls.DB_PASSWORD}@"
            f"{cls.DB_HOST}:{cls.DB_PORT}/{cls.DB_NAME}"
        )

===============================================================================
FILE: ./epic_events_schema.sql
------------------------------------------------------------------------------
META: 0 bytes | modified: 2026-02-24 06:01:39
===============================================================================



===============================================================================
FILE: ./init_db.py
------------------------------------------------------------------------------
META: 583 bytes | modified: 2026-02-16 20:47:55
===============================================================================

# init_db.py
from sqlalchemy import create_engine
from app.models import Base
from config.config import Config


def create_tables():
    """
    Creates all database tables defined in the models.
    """
    engine = create_engine(Config.get_db_url())

    print("Connecting to the database...")
    try:
        # Create all tables stored in the metadata
        Base.metadata.create_all(engine)
        print("Success: All tables created successfully.")
    except Exception as e:
        print(f"Error during table creation: {e}")


if __name__ == "__main__":
    create_tables()

===============================================================================
FILE: ./main.py
------------------------------------------------------------------------------
META: 18197 bytes | modified: 2026-02-24 15:17:39
===============================================================================

"""
Entry point for the Epic Events CRM application.
Manages the main loop and coordinate between controllers and views.
"""

from datetime import datetime

import sentry_sdk
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from config.config import Config

from app.repositories.employee_repository import EmployeeRepository
from app.repositories.client_repository import ClientRepository
from app.repositories.contract_repository import ContractRepository
from app.repositories.event_repository import EventRepository

from app.controllers.auth_controller import AuthController
from app.controllers.client_controller import ClientController
from app.controllers.contract_controller import ContractController
from app.controllers.event_controller import EventController
from app.controllers.employee_controller import EmployeeController

from app.views.auth_view import AuthView
from app.views.main_menu_view import MainMenuView
from app.views.client_view import ClientView
from app.views.contract_view import ContractView
from app.views.event_view import EventView
from app.views.employee_view import EmployeeView

# Initialize Sentry
sentry_sdk.init(
    dsn=Config.SENTRY_DSN,
    # Set the environment (default to development if not specified in Config)
    environment=getattr(Config, "ENVIRONMENT", "development"),
    traces_sample_rate=1.0,
    profiles_sample_rate=1.0,
)


def main():
    """Main application execution logic."""
    try:
        # Database Setup
        engine = create_engine(Config.get_db_url())
        session_factory = sessionmaker(bind=engine)
        session = session_factory()

        # Initialize Repositories
        emp_repo = EmployeeRepository(session)
        client_repo = ClientRepository(session)
        contract_repo = ContractRepository(session)
        event_repo = EventRepository(session)

        # Initialize Controllers
        auth_ctrl = AuthController(emp_repo)
        client_ctrl = ClientController(client_repo, auth_ctrl)
        contract_ctrl = ContractController(contract_repo, auth_ctrl)
        event_ctrl = EventController(event_repo, auth_ctrl)
        emp_ctrl = EmployeeController(emp_repo, auth_ctrl)

        # Initialize Views
        auth_view = AuthView()
        menu_view = MainMenuView()
        client_view = ClientView()
        contract_view = ContractView()
        event_view = EventView()
        emp_view = EmployeeView()

        # 1. Authentication Check
        user_data = auth_ctrl.get_logged_in_user()
        if not user_data:
            email, password = auth_view.ask_login_details()
            # Capture user_data directly from login()
            user_data = auth_ctrl.login(email, password)
            if not user_data:
                auth_view.display_login_failure()
                return

        auth_view.display_login_success()

        # 2. Application Loop
        while True:

            menu_view.display_menu(user_data["department"])
            choice = menu_view.ask_menu_option()

            if choice == "1":
                # Pass user_data to satisfy the @require_auth decorator
                data = client_ctrl.list_all_clients(user_data=user_data)
                client_view.display_clients(data)
            elif choice == "2":
                # Pass user_data to satisfy the @require_auth decorator
                data = contract_ctrl.list_all_contracts(user_data=user_data)
                contract_view.display_contracts(data)
            elif choice == "3":
                # Pass user_data to satisfy the @require_auth decorator
                data = event_ctrl.list_all_events(user_data=user_data)
                event_view.display_events(data)
            elif choice == "4":
                if user_data["department"] != "MANAGEMENT":
                    print("Invalid option. Please try again.")
                    continue
                data = emp_ctrl.list_all_employees(user_data=user_data)
                emp_view.display_employees(data)
            elif choice == "5":
                if user_data["department"] != "MANAGEMENT":
                    print("Invalid option. Please try again.")
                    continue
                details = emp_view.ask_employee_details()
                emp_ctrl.create_employee(user_data=user_data, employee_data=details)
            elif choice == "6":
                if user_data["department"] != "MANAGEMENT":
                    print("Invalid option. Please try again.")
                    continue
                emp_id = emp_view.ask_input("Enter Employee ID to update")
                if emp_id.isdigit():
                    updates = emp_view.ask_update_details()
                    emp_ctrl.update_employee(
                        user_data=user_data,
                        emp_id=int(emp_id),
                        update_data=updates
                    )
            elif choice == "7":
                if user_data["department"] != "MANAGEMENT":
                    print("Invalid option. Please try again.")
                    continue

                contract_data = contract_view.ask_contract_details()

                client_id_raw = str(contract_data.get("client_id", "")).strip()
                if not client_id_raw.isdigit():
                    continue
                client = client_ctrl.repository.get_by_id(int(client_id_raw))
                if not client:
                    print("Client not found.")
                    continue

                try:
                    total_amount = float(str(contract_data["total_amount"]).strip())
                    remaining_amount = float(
                        str(contract_data["remaining_amount"]).strip()
                    )
                except (KeyError, ValueError, TypeError):
                    continue

                is_signed_raw = str(contract_data.get("is_signed", "")).strip()
                is_signed = is_signed_raw.lower() in ["y", "yes"]

                payload = {
                    "client_id": client.id,
                    "sales_contact_id": client.sales_contact_id,
                    "total_amount": total_amount,
                    "remaining_amount": remaining_amount,
                    "is_signed": is_signed,
                }
                contract_ctrl.create_contract(
                    user_data=user_data,
                    contract_data=payload,
                )
            elif choice == "8":
                if user_data["department"] != "MANAGEMENT":
                    print("Invalid option. Please try again.")
                    continue

                contract_id = contract_view.ask_input("Enter Contract ID")
                if not contract_id.isdigit():
                    continue

                raw = contract_view.ask_contract_update_details()
                updates = {}

                total_amount_raw = str(raw.get("total_amount", "")).strip()
                if total_amount_raw:
                    try:
                        updates["total_amount"] = float(total_amount_raw)
                    except ValueError:
                        updates.pop("total_amount", None)

                remaining_raw = str(raw.get("remaining_amount", "")).strip()
                if remaining_raw:
                    try:
                        updates["remaining_amount"] = float(remaining_raw)
                    except ValueError:
                        updates.pop("remaining_amount", None)

                is_signed_raw = str(raw.get("is_signed", "")).strip().lower()
                if is_signed_raw in ["y", "yes"]:
                    updates["is_signed"] = True
                elif is_signed_raw in ["n", "no"]:
                    updates["is_signed"] = False

                if updates:
                    contract_ctrl.update_contract(
                        user_data=user_data,
                        contract_id=int(contract_id),
                        updates=updates,
                    )
            elif choice == "9":
                if user_data["department"] != "MANAGEMENT":
                    print("Invalid option. Please try again.")
                    continue
                event_id = event_view.ask_input("Enter Event ID")
                support_id = event_view.ask_input("Enter Support Employee ID")
                if not event_id.isdigit() or not support_id.isdigit():
                    continue
                updates = {"support_contact_id": int(support_id)}
                event_ctrl.update_event(
                    user_data=user_data,
                    event_id=int(event_id),
                    updates=updates,
                )
            elif choice == "10":
                if user_data["department"] != "MANAGEMENT":
                    print("Invalid option. Please try again.")
                    continue
                events = event_ctrl.list_events_without_support(
                    user_data=user_data
                ) or []
                event_view.display_events(events)
            elif choice == "20":
                if user_data["department"] != "SALES":
                    print("Invalid option. Please try again.")
                    continue
                details = client_view.ask_client_details()
                last_contact = details.get("last_contact", "").strip()
                if not last_contact:
                    details.pop("last_contact", None)
                else:
                    try:
                        details["last_contact"] = datetime.strptime(
                            last_contact,
                            "%Y-%m-%d %H:%M:%S",
                        )
                    except ValueError:
                        details.pop("last_contact", None)
                client_ctrl.create_client(user_data=user_data, client_data=details)
            elif choice == "21":
                if user_data["department"] != "SALES":
                    print("Invalid option. Please try again.")
                    continue

                client_id = client_view.ask_input("Enter Client ID to update")
                if not client_id.isdigit():
                    continue

                raw = client_view.ask_client_update_details()
                updates = {}

                full_name = str(raw.get("full_name", "")).strip()
                email = str(raw.get("email", "")).strip()
                phone = str(raw.get("phone", "")).strip()
                company_name = str(raw.get("company_name", "")).strip()

                if full_name:
                    updates["full_name"] = full_name
                if email:
                    updates["email"] = email
                if phone:
                    updates["phone"] = phone
                if company_name:
                    updates["company_name"] = company_name

                last_contact = str(raw.get("last_contact", "")).strip()
                if last_contact:
                    try:
                        updates["last_contact"] = datetime.strptime(
                            last_contact,
                            "%Y-%m-%d %H:%M:%S",
                        )
                    except ValueError:
                        updates.pop("last_contact", None)

                if updates:
                    client_ctrl.update_client(
                        user_data=user_data,
                        client_id=int(client_id),
                        updates=updates,
                    )
            elif choice == "22":
                if user_data["department"] != "SALES":
                    print("Invalid option. Please try again.")
                    continue

                contract_id = contract_view.ask_input("Enter Contract ID")
                if not contract_id.isdigit():
                    continue

                raw = contract_view.ask_contract_update_details()
                updates = {}

                total_amount_raw = str(raw.get("total_amount", "")).strip()
                if total_amount_raw:
                    try:
                        updates["total_amount"] = float(total_amount_raw)
                    except ValueError:
                        updates.pop("total_amount", None)

                remaining_raw = str(raw.get("remaining_amount", "")).strip()
                if remaining_raw:
                    try:
                        updates["remaining_amount"] = float(remaining_raw)
                    except ValueError:
                        updates.pop("remaining_amount", None)

                is_signed_raw = str(raw.get("is_signed", "")).strip().lower()
                if is_signed_raw in ["y", "yes"]:
                    updates["is_signed"] = True
                elif is_signed_raw in ["n", "no"]:
                    updates["is_signed"] = False

                if updates:
                    contract_ctrl.update_contract(
                        user_data=user_data,
                        contract_id=int(contract_id),
                        updates=updates,
                    )
            elif choice == "23":
                if user_data["department"] != "SALES":
                    print("Invalid option. Please try again.")
                    continue
                contracts = contract_ctrl.list_unsigned_contracts(
                    user_data=user_data
                ) or []
                contract_view.display_contracts(contracts)
            elif choice == "24":
                if user_data["department"] != "SALES":
                    print("Invalid option. Please try again.")
                    continue
                contracts = contract_ctrl.list_unpaid_contracts(
                    user_data=user_data
                ) or []
                contract_view.display_contracts(contracts)
            elif choice == "25":
                if user_data["department"] != "SALES":
                    print("Invalid option. Please try again.")
                    continue

                contract_id = event_view.ask_input("Enter Contract ID")
                if not contract_id.isdigit():
                    continue

                contract = contract_ctrl.repository.get_by_id(int(contract_id))
                if not contract:
                    print("Contract not found.")
                    continue

                if contract.sales_contact_id != user_data["id"]:
                    print(
                        "Access denied: you are not the sales contact for this "
                        "contract/client."
                    )
                    continue

                if not contract.is_signed:
                    print("Cannot create an event: the contract is not signed.")
                    continue

                raw = event_view.ask_event_details()

                start_raw = str(raw.get("event_date_start", "")).strip()
                end_raw = str(raw.get("event_date_end", "")).strip()
                try:
                    start_dt = datetime.strptime(start_raw, "%Y-%m-%d %H:%M:%S")
                    end_dt = datetime.strptime(end_raw, "%Y-%m-%d %H:%M:%S")
                except ValueError:
                    continue

                attendees_raw = str(raw.get("attendees", "")).strip()
                try:
                    attendees = int(attendees_raw)
                except ValueError:
                    continue

                event_data = {
                    "name": str(raw.get("name", "")).strip(),
                    "event_date_start": start_dt,
                    "event_date_end": end_dt,
                    "location": str(raw.get("location", "")).strip(),
                    "attendees": attendees,
                    "notes": str(raw.get("notes", "")).strip(),
                    "client_id": contract.client_id,
                    "contract_id": contract.id,
                    "support_contact_id": None,
                }
                event_ctrl.create_event(
                    user_data=user_data,
                    event_data=event_data,
                    contract=contract,
                )
            elif choice == "30":
                if user_data["department"] != "SUPPORT":
                    print("Invalid option. Please try again.")
                    continue
                events = event_ctrl.list_my_events(user_data=user_data) or []
                event_view.display_events(events)
            elif choice == "31":
                if user_data["department"] != "SUPPORT":
                    print("Invalid option. Please try again.")
                    continue
                events = event_ctrl.list_my_events(user_data=user_data) or []
                event_view.display_events(events)

                event_id = event_view.ask_input("Enter Event ID to update")
                if not event_id.isdigit():
                    continue

                raw = event_view.ask_event_update_details()
                updates = {}

                notes = str(raw.get("notes", "")).strip()
                location = str(raw.get("location", "")).strip()
                attendees_raw = str(raw.get("attendees", "")).strip()

                if notes:
                    updates["notes"] = notes
                if location:
                    updates["location"] = location
                if attendees_raw:
                    try:
                        updates["attendees"] = int(attendees_raw)
                    except ValueError:
                        updates.pop("attendees", None)

                if updates:
                    event_ctrl.update_event(
                        user_data=user_data,
                        event_id=int(event_id),
                        updates=updates,
                    )
            elif choice == "0":
                auth_ctrl.logout()
                print("Goodbye!")
                break
            else:
                print("Invalid option. Please try again.")

    except Exception as e:
        # Catch and report any fatal application errors
        sentry_sdk.capture_exception(e)
        print(f"A fatal error occurred: {e}")
        raise e


if __name__ == "__main__":
    main()

===============================================================================
FILE: ./pytest.ini
------------------------------------------------------------------------------
META: 334 bytes | modified: 2026-02-19 13:40:15
===============================================================================

[pytest]
pythonpath = .
testpaths = tests
python_files = test_*.py

; -v: Detailed output for each test
; --tb=short: Simplified error stack traces
; --cov=app: Measure code coverage for the app directory
; --cov-report=term-missing: List specific lines not covered by tests
addopts = -v --tb=short --cov=app --cov-report=term-missing

===============================================================================
FILE: ./requirements.txt
------------------------------------------------------------------------------
META: 498 bytes | modified: 2026-02-21 19:22:00
===============================================================================

asgiref==3.11.0
blinker==1.9.0
certifi==2026.1.4
click==8.3.1
distlib==0.4.0
Django==5.2.8
filelock==3.20.3
flake8==7.3.0
flake8-html==0.4.3
Flask==3.1.2
iniconfig==2.3.0
itsdangerous==2.2.0
Jinja2==3.1.6
MarkupSafe==3.0.2
mccabe==0.7.0
packaging==25.0
pillow==12.0.0
pipenv==2026.0.3
platformdirs==4.5.1
pluggy==1.6.0
pycodestyle==2.14.0
pyflakes==3.4.0
Pygments==2.19.2
pytest==9.0.2
pytest-flask==1.3.0
python-dotenv==1.2.1
setuptools==80.9.0
sqlparse==0.5.3
virtualenv==20.36.1
Werkzeug==3.1.5


===============================================================================
FILE: ./result.txt
------------------------------------------------------------------------------
META: 177089 bytes | modified: 2026-02-21 21:46:14
===============================================================================

============================= test session starts ==============================
platform darwin -- Python 3.13.3, pytest-9.0.2, pluggy-1.6.0 -- /Users/carrasd/Develp/OCR/Projets/P12/CRM/env/bin/python
cachedir: .pytest_cache
rootdir: /Users/carrasd/Develp/OCR/Projets/P12/CRM
configfile: pytest.ini
plugins: cov-7.0.0
collecting ... collected 66 items

tests/test_auth_utils.py::test_password_hashing PASSED                   [  1%]
tests/test_auth_utils.py::test_password_verification_fail PASSED         [  3%]
tests/test_auth_utils.py::test_token_lifecycle PASSED                    [  4%]
tests/test_business_validation.py::test_contract_amounts_logic ERROR     [  6%]
tests/test_business_validation.py::test_event_date_coherence ERROR       [  7%]
tests/test_business_validation.py::test_attendees_positive ERROR         [  9%]
tests/test_functional_auth.py::test_auth_controller_full_flow ERROR      [ 10%]
tests/test_functional_auth.py::test_auth_login_success ERROR             [ 12%]
tests/test_functional_management.py::test_list_employees_as_management ERROR [ 13%]
tests/test_functional_management.py::test_create_employee_as_management ERROR [ 15%]
tests/test_functional_management.py::test_create_employee_as_sales_denied ERROR [ 16%]
tests/test_functional_management.py::test_list_contracts_permission ERROR [ 18%]
tests/test_functional_permissions.py::test_management_can_create_employee ERROR [ 19%]
tests/test_functional_permissions.py::test_sales_cannot_create_employee ERROR [ 21%]
tests/test_functional_permissions.py::test_sales_can_create_client ERROR [ 22%]
tests/test_functional_permissions.py::test_support_restrictions ERROR    [ 24%]
tests/test_functional_sales.py::test_sales_can_create_client ERROR       [ 25%]
tests/test_functional_sales.py::test_support_cannot_create_client ERROR  [ 27%]
tests/test_functional_sales.py::test_sales_can_update_own_client ERROR   [ 28%]
tests/test_functional_sales.py::test_sales_cannot_update_other_client ERROR [ 30%]
tests/test_functional_sales.py::test_management_can_create_contract ERROR [ 31%]
tests/test_functional_sales.py::test_sales_can_sign_own_contract ERROR   [ 33%]
tests/test_functional_sales.py::test_sales_can_create_event_for_signed_contract ERROR [ 34%]
tests/test_functional_sales.py::test_sales_cannot_create_event_for_unsigned_contract ERROR [ 36%]
tests/test_functional_sales.py::test_support_can_update_assigned_event ERROR [ 37%]
tests/test_functional_sales.py::test_sales_list_unsigned_contracts_filtered_by_owner ERROR [ 39%]
tests/test_functional_sales.py::test_sales_list_unpaid_contracts_filtered_by_owner 

==================================== ERRORS ====================================
________________ ERROR at setup of test_contract_amounts_logic _________________
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
_________________ ERROR at setup of test_event_date_coherence __________________
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
__________________ ERROR at setup of test_attendees_positive ___________________
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
_______________ ERROR at setup of test_auth_controller_full_flow _______________
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
__________________ ERROR at setup of test_auth_login_success ___________________
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
_____________ ERROR at setup of test_list_employees_as_management ______________
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
_____________ ERROR at setup of test_create_employee_as_management _____________
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
____________ ERROR at setup of test_create_employee_as_sales_denied ____________
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
_______________ ERROR at setup of test_list_contracts_permission _______________
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
____________ ERROR at setup of test_management_can_create_employee _____________
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
_____________ ERROR at setup of test_sales_cannot_create_employee ______________
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
________________ ERROR at setup of test_sales_can_create_client ________________
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
_________________ ERROR at setup of test_support_restrictions __________________
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
________________ ERROR at setup of test_sales_can_create_client ________________
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
_____________ ERROR at setup of test_support_cannot_create_client ______________
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
______________ ERROR at setup of test_sales_can_update_own_client ______________
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
___________ ERROR at setup of test_sales_cannot_update_other_client ____________
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
____________ ERROR at setup of test_management_can_create_contract _____________
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
______________ ERROR at setup of test_sales_can_sign_own_contract ______________
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
______ ERROR at setup of test_sales_can_create_event_for_signed_contract _______
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
____ ERROR at setup of test_sales_cannot_create_event_for_unsigned_contract ____
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
___________ ERROR at setup of test_support_can_update_assigned_event ___________
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
____ ERROR at setup of test_sales_list_unsigned_contracts_filtered_by_owner ____
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:354: in _open_connection
    self._cmysql.connect(**cnx_kwargs)
E   _mysql_connector.MySQLInterfaceError: Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   mysql.connector.errors.ProgrammingError: 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)

The above exception was the direct cause of the following exception:
tests/conftest.py:38: in db_engine
    Base.metadata.drop_all(engine)
env/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3259: in _run_ddl_visitor
    with self.begin() as conn:
         ^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
env/lib/python3.13/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/pooling.py:322: in connect
    return CMySQLConnection(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:142: in __init__
    self.connect(**kwargs)
env/lib/python3.13/site-packages/mysql/connector/abstracts.py:1604: in connect
    self._open_connection()
env/lib/python3.13/site-packages/mysql/connector/connection_cext.py:360: in _open_connection
    raise get_mysql_exception(
E   sqlalchemy.exc.ProgrammingError: (mysql.connector.errors.ProgrammingError) 1045 (28000): Access denied for user 'crm_user'@'localhost' (using password: YES)
E   (Background on this error at: https://sqlalche.me/e/20/f405)
=========================== short test summary info ============================
ERROR tests/test_business_validation.py::test_contract_amounts_logic - sqlalc...
ERROR tests/test_business_validation.py::test_event_date_coherence - sqlalche...
ERROR tests/test_business_validation.py::test_attendees_positive - sqlalchemy...
ERROR tests/test_functional_auth.py::test_auth_controller_full_flow - sqlalch...
ERROR tests/test_functional_auth.py::test_auth_login_success - sqlalchemy.exc...
ERROR tests/test_functional_management.py::test_list_employees_as_management
ERROR tests/test_functional_management.py::test_create_employee_as_management
ERROR tests/test_functional_management.py::test_create_employee_as_sales_denied
ERROR tests/test_functional_management.py::test_list_contracts_permission - s...
ERROR tests/test_functional_permissions.py::test_management_can_create_employee
ERROR tests/test_functional_permissions.py::test_sales_cannot_create_employee
ERROR tests/test_functional_permissions.py::test_sales_can_create_client - sq...
ERROR tests/test_functional_permissions.py::test_support_restrictions - sqlal...
ERROR tests/test_functional_sales.py::test_sales_can_create_client - sqlalche...
ERROR tests/test_functional_sales.py::test_support_cannot_create_client - sql...
ERROR tests/test_functional_sales.py::test_sales_can_update_own_client - sqla...
ERROR tests/test_functional_sales.py::test_sales_cannot_update_other_client
ERROR tests/test_functional_sales.py::test_management_can_create_contract - s...
ERROR tests/test_functional_sales.py::test_sales_can_sign_own_contract - sqla...
ERROR tests/test_functional_sales.py::test_sales_can_create_event_for_signed_contract
ERROR tests/test_functional_sales.py::test_sales_cannot_create_event_for_unsigned_contract
ERROR tests/test_functional_sales.py::test_support_can_update_assigned_event
ERROR tests/test_functional_sales.py::test_sales_list_unsigned_contracts_filtered_by_owner
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! KeyboardInterrupt !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/ast.py:301: KeyboardInterrupt
(to show a full traceback on KeyboardInterrupt use --full-trace)
========================= 3 passed, 23 errors in 9.07s =========================


===============================================================================
FILE: ./tests/__init__.py
------------------------------------------------------------------------------
META: 0 bytes | modified: 2026-02-19 13:34:23
===============================================================================



===============================================================================
FILE: ./tests/conftest.py
------------------------------------------------------------------------------
META: 1799 bytes | modified: 2026-02-21 19:59:53
===============================================================================

# tests/conftest.py
"""
Pytest configuration and global fixtures.
Provides database engine and session management for tests.
Initializes Sentry for error tracking during tests.
"""

import os
import pytest
import sentry_sdk
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker
from config.config import Config
from app.models import Base
from app.utils.token_storage import TOKEN_FILE

try:
    from dotenv import load_dotenv
except ModuleNotFoundError:
    load_dotenv = None

if load_dotenv is not None:
    load_dotenv()


@pytest.fixture(scope="session", autouse=True)
def init_sentry():
    sentry_sdk.init(
        dsn=Config.SENTRY_DSN,
        environment="testing",
        traces_sample_rate=1.0
    )


@pytest.fixture(scope="session")
def db_engine():
    engine = create_engine(Config.get_db_url())
    Base.metadata.drop_all(engine)
    Base.metadata.create_all(engine)
    yield engine
    engine.dispose()


@pytest.fixture(scope="function")
def db_session(db_engine):
    """
    Provide a fully clean database for each test.
    Hard reset using TRUNCATE and AUTO_INCREMENT reset.
    Also clears TOKEN_FILE to avoid auth leakage.
    """
    # Remove persisted token between tests
    if os.path.exists(TOKEN_FILE):
        os.remove(TOKEN_FILE)

    connection = db_engine.connect()
    Session = sessionmaker(bind=connection)
    session = Session()

    session.execute(text("SET FOREIGN_KEY_CHECKS=0;"))

    tables = [
        "event",
        "contract",
        "client",
        "employee",
        "department",
    ]

    for table in tables:
        session.execute(text(f"TRUNCATE TABLE {table};"))

    session.execute(text("SET FOREIGN_KEY_CHECKS=1;"))
    session.commit()

    yield session

    session.close()
    connection.close()

===============================================================================
FILE: ./tests/test_auth_controller_session_restore.py
------------------------------------------------------------------------------
META: 3402 bytes | modified: 2026-02-22 04:24:19
===============================================================================

"""
tests/test_auth_controller_session_restore.py

Covers AuthController session restoration via token_storage + jwt_handler,
and Sentry user scope restore/reset behavior.

Non-regression: assertions match current implementation:
- get_logged_in_user() sets Sentry user with {"id": str(id), "department": dept}
  (no username restoration)
"""

import pytest
from app.controllers.auth_controller import AuthController
from app.repositories.employee_repository import EmployeeRepository


@pytest.fixture
def auth_ctrl(db_session):
    """AuthController wired with a real repository (DB not used in these tests)."""
    return AuthController(EmployeeRepository(db_session))


def test_get_logged_in_user_no_token(monkeypatch, auth_ctrl):
    """If no token exists, return None and do not touch current_user_data."""
    from app.controllers import auth_controller as auth_mod

    monkeypatch.setattr(auth_mod, "get_token", lambda: None)

    out = auth_ctrl.get_logged_in_user()
    assert out is None
    assert auth_ctrl.current_user_data is None


def test_get_logged_in_user_valid_token_restores_sentry(monkeypatch, auth_ctrl):
    """
    Valid token -> returns payload, sets current_user_data,
    and restores Sentry user with id coerced to string.
    """
    from app.controllers import auth_controller as auth_mod

    sentry = {"value": None}

    def _fake_set_user(value):
        sentry["value"] = value

    monkeypatch.setattr(auth_mod, "get_token", lambda: "dummy.jwt.token")
    monkeypatch.setattr(
        auth_mod,
        "decode_token",
        lambda _t: {"id": 1, "department": "SALES"},
    )
    monkeypatch.setattr(auth_mod.sentry_sdk, "set_user", _fake_set_user)

    payload = auth_ctrl.get_logged_in_user()
    assert payload == {"id": 1, "department": "SALES"}
    assert auth_ctrl.current_user_data == {"id": 1, "department": "SALES"}

    # Non-regression: implementation sets string id and does not include username
    assert sentry["value"] == {"id": "1", "department": "SALES"}


def test_get_logged_in_user_invalid_token_deletes_token(monkeypatch, auth_ctrl):
    """Invalid/expired token -> delete_token is called and None is returned."""
    from app.controllers import auth_controller as auth_mod

    deleted = {"called": False}

    def _fake_delete():
        deleted["called"] = True

    monkeypatch.setattr(auth_mod, "get_token", lambda: "dummy.jwt.token")
    monkeypatch.setattr(auth_mod, "decode_token", lambda _t: None)
    monkeypatch.setattr(auth_mod, "delete_token", _fake_delete)

    payload = auth_ctrl.get_logged_in_user()
    assert payload is None
    assert deleted["called"] is True


def test_logout_clears_sentry_and_session(monkeypatch, auth_ctrl):
    """logout() clears token, clears Sentry user, and resets current_user_data."""
    from app.controllers import auth_controller as auth_mod

    deleted = {"called": False}
    sentry = {"value": "not-none"}

    def _fake_delete():
        deleted["called"] = True

    def _fake_set_user(value):
        sentry["value"] = value

    auth_ctrl.current_user_data = {"id": 99, "department": "MANAGEMENT"}

    monkeypatch.setattr(auth_mod, "delete_token", _fake_delete)
    monkeypatch.setattr(auth_mod.sentry_sdk, "set_user", _fake_set_user)

    auth_ctrl.logout()

    assert deleted["called"] is True
    assert sentry["value"] is None
    assert auth_ctrl.current_user_data is None

===============================================================================
FILE: ./tests/test_auth_utils.py
------------------------------------------------------------------------------
META: 1429 bytes | modified: 2026-02-19 15:22:06
===============================================================================

# tests/test_auth_utils.py
"""
Unit tests for authentication utilities.

Tests included:
- test_password_hashing: Verify Argon2 hashing and verification.
- test_password_verification_fail: Ensure incorrect passwords are rejected.
- test_token_lifecycle: Save, retrieve, and delete token from storage.
"""

import os
from app.utils.auth import hash_password, verify_password
from app.utils.token_storage import save_token, get_token, delete_token, TOKEN_FILE


def test_password_hashing():
    """Test that hashing and verification work correctly with Argon2."""
    raw_password = "secure_password_2026"
    hashed = hash_password(raw_password)

    assert hashed != raw_password
    assert verify_password(hashed, raw_password) is True


def test_password_verification_fail():
    """Test that verification fails with a wrong password."""
    hashed = hash_password("correct_one")
    assert verify_password("wrong_one", hashed) is False


def test_token_lifecycle():
    """Test the full lifecycle: saving, getting, and deleting a token."""
    # Ensure a clean state
    if os.path.exists(TOKEN_FILE):
        os.remove(TOKEN_FILE)

    test_token = "abc.123.jwt.token"

    # Save
    save_token(test_token)
    assert os.path.exists(TOKEN_FILE)

    # Get
    retrieved = get_token()
    assert retrieved == test_token

    # Delete
    delete_token()
    assert not os.path.exists(TOKEN_FILE)
    assert get_token() is None

===============================================================================
FILE: ./tests/test_business_validation.py
------------------------------------------------------------------------------
META: 3136 bytes | modified: 2026-02-19 18:13:10
===============================================================================

# tests/test_business_validation.py
"""
Functional tests for business data validation and constraints.

Tests included:
- test_contract_amounts_logic: Verify remaining amount <= total amount.
- test_event_date_coherence: Verify event end date is after start date.
- test_attendees_positive: Verify number of attendees is not negative.
"""

import uuid
import pytest
from datetime import datetime, timedelta
from app.models.contract import Contract
from app.models.event import Event
from app.models.client import Client
from app.models.employee import Employee
from app.models.department import Department
from app.repositories.base_repository import BaseRepository


@pytest.fixture
def validation_setup(db_session):
    """Setup minimal data for validation tests."""
    dept_repo = BaseRepository(db_session, Department)
    dept = dept_repo.add(Department(name=f"VAL_{uuid.uuid4().hex[:6]}"))

    sales = Employee(
        full_name="Sales", email=f"s_{uuid.uuid4().hex[:6]}@test.com",
        password="h", employee_number=f"S{uuid.uuid4().hex[:4]}",
        department_id=dept.id
    )
    db_session.add(sales)
    db_session.commit()

    client = Client(
        full_name="C", email=f"c_{uuid.uuid4().hex[:6]}@test.com",
        phone="0", company_name="C", sales_contact_id=sales.id
    )
    db_session.add(client)
    db_session.commit()

    return {"sales": sales, "client": client}


def test_contract_amounts_logic(db_session, validation_setup):
    """Verify state of a contract with logically inconsistent amounts."""
    s = validation_setup
    contract = Contract(
        total_amount=100.00,
        remaining_amount=150.00,
        is_signed=True,
        client_id=s["client"].id,
        sales_contact_id=s["sales"].id
    )
    # This highlights that the model currently accepts the inconsistency
    assert contract.remaining_amount > contract.total_amount


def test_event_date_coherence(db_session, validation_setup):
    """Verify state of an event with non-chronological dates."""
    s = validation_setup
    start = datetime.now()
    end = start - timedelta(hours=1)

    # Create contract for the event
    contract = Contract(
        total_amount=100, remaining_amount=0, is_signed=True,
        client_id=s["client"].id, sales_contact_id=s["sales"].id
    )
    db_session.add(contract)
    db_session.commit()

    event = Event(
        name="Invalid Date Event",
        event_date_start=start,
        event_date_end=end,
        location="Paris",
        attendees=10,
        notes="Testing",
        client_id=s["client"].id,
        contract_id=contract.id
    )
    assert event.event_date_end < event.event_date_start


def test_attendees_positive(db_session, validation_setup):
    """Verify state of an event with negative attendees."""
    s = validation_setup
    event = Event(
        name="Negative Attendees",
        event_date_start=datetime.now(),
        event_date_end=datetime.now(),
        location="L",
        attendees=-5,
        notes="N",
        client_id=s["client"].id,
        contract_id=1 # Using dummy ID for unit check
    )
    assert event.attendees < 0

===============================================================================
FILE: ./tests/test_controllers_more_more_coverage.py
------------------------------------------------------------------------------
META: 9290 bytes | modified: 2026-02-23 22:35:42
===============================================================================

# tests/test_controllers_more_more_coverage.py
"""
Extra controller tests to push coverage further (happy-path + extra branches),
without breaking non-regression.

Important:
- Fixtures are defined locally (pytest does NOT share fixtures across test files
  unless they are in conftest.py).
- Keep data compliant with DB constraints (e.g. Client.phone is NOT NULL).
"""

from __future__ import annotations

from datetime import datetime, timedelta
import uuid

import pytest

from app.controllers.client_controller import ClientController
from app.controllers.contract_controller import ContractController
from app.controllers.employee_controller import EmployeeController
from app.controllers.event_controller import EventController

from app.models.client import Client
from app.models.contract import Contract
from app.models.department import Department
from app.models.employee import Employee
from app.models.event import Event

from app.repositories.client_repository import ClientRepository
from app.repositories.contract_repository import ContractRepository
from app.repositories.employee_repository import EmployeeRepository
from app.repositories.event_repository import EventRepository

from app.utils.auth import verify_password


class DummyAuthController:
    """Minimal auth controller to drive controller permission branches."""

    def __init__(self, allowed: set[str]):
        self.allowed = allowed
        self.current_user_data: dict | None = None

    def check_user_permission(self, permission: str) -> bool:
        return permission in self.allowed


@pytest.fixture
def seeded_staff(db_session):
    """Create SALES / SUPPORT / MANAGEMENT employees."""
    sales_dept = Department(name=f"SALES_{uuid.uuid4().hex[:6]}")
    support_dept = Department(name=f"SUPPORT_{uuid.uuid4().hex[:6]}")
    mgmt_dept = Department(name=f"MANAGEMENT_{uuid.uuid4().hex[:6]}")
    db_session.add_all([sales_dept, support_dept, mgmt_dept])
    db_session.flush()

    sales = Employee(
        full_name="Sales User",
        email=f"sales_{uuid.uuid4().hex[:6]}@t.com",
        password="pw",
        employee_number=f"S{uuid.uuid4().hex[:6]}",
        department_id=sales_dept.id,
    )
    support = Employee(
        full_name="Support User",
        email=f"support_{uuid.uuid4().hex[:6]}@t.com",
        password="pw",
        employee_number=f"U{uuid.uuid4().hex[:6]}",
        department_id=support_dept.id,
    )
    mgmt = Employee(
        full_name="Mgmt User",
        email=f"mgmt_{uuid.uuid4().hex[:6]}@t.com",
        password="pw",
        employee_number=f"M{uuid.uuid4().hex[:6]}",
        department_id=mgmt_dept.id,
    )

    db_session.add_all([sales, support, mgmt])
    db_session.commit()

    return {"sales": sales, "support": support, "mgmt": mgmt}


@pytest.fixture
def seeded_business(db_session, seeded_staff):
    """Create a client + 2 contracts + 1 event for controller tests."""
    staff = seeded_staff
    sales = staff["sales"]
    support = staff["support"]

    client = Client(
        full_name="Client Seed",
        email=f"client_{uuid.uuid4().hex[:6]}@t.com",
        phone="0102030405",
        company_name="Corp",
        sales_contact_id=sales.id,
    )
    db_session.add(client)
    db_session.commit()

    signed_contract = Contract(
        total_amount=1000,
        remaining_amount=100,
        is_signed=True,
        client_id=client.id,
        sales_contact_id=sales.id,
    )
    unsigned_contract = Contract(
        total_amount=500,
        remaining_amount=500,
        is_signed=False,
        client_id=client.id,
        sales_contact_id=sales.id,
    )
    db_session.add_all([signed_contract, unsigned_contract])
    db_session.commit()

    event = Event(
        name="Event Seed",
        event_date_start=datetime.now() + timedelta(days=1),
        event_date_end=datetime.now() + timedelta(days=2),
        location="Paris",
        attendees=10,
        notes="n",
        client_id=client.id,
        contract_id=signed_contract.id,
        support_contact_id=support.id,
    )
    db_session.add(event)
    db_session.commit()

    return {
        "client": client,
        "signed_contract": signed_contract,
        "unsigned_contract": unsigned_contract,
        "event": event,
    }


def test_client_controller_list_all_clients_allowed_returns_clients(
    db_session, seeded_business
):
    auth = DummyAuthController(allowed={"read_client"})
    ctrl = ClientController(ClientRepository(db_session), auth)

    out = ctrl.list_all_clients(user_data={"id": 1, "department": "SALES"})
    assert isinstance(out, list)
    assert len(out) >= 1


def test_client_controller_create_success_sets_last_contact_and_prints(
    db_session, seeded_staff, capsys
):
    auth = DummyAuthController(allowed={"create_client"})
    ctrl = ClientController(ClientRepository(db_session), auth)

    sales = seeded_staff["sales"]
    created = ctrl.create_client(
        user_data={"id": sales.id, "department": "SALES"},
        client_data={
            "full_name": "New Client",
            "email": f"new_{uuid.uuid4().hex[:6]}@t.com",
            "phone": "0600000000",
            "company_name": "NewCorp",
        },
    )
    captured = capsys.readouterr().out

    assert created is not None
    assert created.sales_contact_id == sales.id
    assert created.last_contact is not None
    assert "client" in captured.lower()
    assert "created" in captured.lower()


def test_client_controller_update_success_as_owner_prints(
    db_session, seeded_business, capsys
):
    auth = DummyAuthController(allowed={"update_client"})
    ctrl = ClientController(ClientRepository(db_session), auth)

    client = seeded_business["client"]
    updated = ctrl.update_client(
        user_data={"id": client.sales_contact_id, "department": "SALES"},
        client_id=client.id,
        updates={"phone": "0999999999"},
    )
    captured = capsys.readouterr().out

    assert updated is not None
    assert updated.phone == "0999999999"
    assert "updated" in captured.lower()


def test_contract_controller_create_infers_sales_contact_from_client(
    db_session, seeded_business, seeded_staff
):
    auth = DummyAuthController(allowed={"create_contract"})
    ctrl = ContractController(ContractRepository(db_session), auth)

    client = seeded_business["client"]
    mgmt = seeded_staff["mgmt"]

    contract = ctrl.create_contract(
        user_data={"id": mgmt.id, "department": "MANAGEMENT"},
        contract_data={
            "total_amount": 2500,
            "remaining_amount": 2500,
            "is_signed": False,
            "client_id": client.id,
            # intentionally omit sales_contact_id to hit the "infer" branch
        },
    )

    assert contract is not None
    assert contract.client_id == client.id
    assert contract.sales_contact_id == client.sales_contact_id


def test_contract_controller_create_missing_client_id_returns_none(
    db_session, seeded_staff
):
    auth = DummyAuthController(allowed={"create_contract"})
    ctrl = ContractController(ContractRepository(db_session), auth)

    mgmt = seeded_staff["mgmt"]
    out = ctrl.create_contract(
        user_data={"id": mgmt.id, "department": "MANAGEMENT"},
        contract_data={"total_amount": 10, "remaining_amount": 10},
    )
    assert out is None


def test_contract_controller_update_denied_when_not_owner_and_not_mgmt(
    db_session, seeded_business, seeded_staff
):
    auth = DummyAuthController(allowed={"update_contract"})
    ctrl = ContractController(ContractRepository(db_session), auth)

    contract = seeded_business["signed_contract"]
    other_sales = seeded_staff["support"]  # wrong user + wrong dept for ownership

    out = ctrl.update_contract(
        user_data={"id": other_sales.id, "department": "SUPPORT"},
        contract_id=contract.id,
        updates={"total_amount": 9999},
    )
    assert out is None


def test_employee_controller_update_hashes_password(db_session, seeded_staff):
    auth = DummyAuthController(allowed={"update_employee"})
    ctrl = EmployeeController(EmployeeRepository(db_session), auth)

    mgmt = seeded_staff["mgmt"]
    target = seeded_staff["support"]

    updated = ctrl.update_employee(
        user_data={"id": mgmt.id, "department": "MANAGEMENT"},
        emp_id=target.id,
        update_data={"password": "new_password"},
    )

    assert updated is not None
    assert updated.password != "new_password"
    # check password not seen
    assert updated.password != "new_password"

    # check Argon2 format
    assert updated.password.startswith("$argon2")


def test_event_controller_update_denied_when_not_assigned_support(
    db_session, seeded_business, seeded_staff, capsys
):
    auth = DummyAuthController(allowed={"update_event"})
    ctrl = EventController(EventRepository(db_session), auth)

    event = seeded_business["event"]
    other_support = seeded_staff["mgmt"]  # not assigned, not SUPPORT, not MANAGEMENT?

    out = ctrl.update_event(
        user_data={"id": other_support.id, "department": "SALES"},
        event_id=event.id,
        updates={"notes": "hack"},
    )
    captured = capsys.readouterr().out

    assert out is None
    assert "access denied" in captured.lower() or "denied" in captured.lower()

===============================================================================
FILE: ./tests/test_controllers_negative_paths.py
------------------------------------------------------------------------------
META: 10435 bytes | modified: 2026-02-22 04:41:42
===============================================================================

# tests/test_controllers_negative_paths.py
"""
Extra controller tests to cover negative/early-return branches:
- permission denied
- not found
- business rule denials (ownership, unsigned contract, support assignment)

Goal: increase controller coverage without changing production code.
"""

from __future__ import annotations

from datetime import datetime, timedelta
import uuid

import pytest

from app.controllers.client_controller import ClientController
from app.controllers.contract_controller import ContractController
from app.controllers.employee_controller import EmployeeController
from app.controllers.event_controller import EventController

from app.models.client import Client
from app.models.contract import Contract
from app.models.department import Department
from app.models.employee import Employee
from app.models.event import Event

from app.repositories.base_repository import BaseRepository
from app.repositories.client_repository import ClientRepository
from app.repositories.contract_repository import ContractRepository
from app.repositories.employee_repository import EmployeeRepository
from app.repositories.event_repository import EventRepository


class DummyAuthController:
    """
    Minimal auth controller stub.
    Controllers only rely on:
      - current_user_data attribute
      - check_user_permission(action) -> bool
    """

    def __init__(self, allowed: set[str] | None = None):
        self.allowed = allowed or set()
        self.current_user_data = None

    def check_user_permission(self, action: str) -> bool:
        return action in self.allowed


@pytest.fixture
def seeded_staff(db_session):
    """Create departments + a few employees to use in controller tests."""
    dept_repo = BaseRepository(db_session, Department)

    d_sales = dept_repo.add(Department(name=f"SALES_{uuid.uuid4().hex[:6]}"))
    d_support = dept_repo.add(Department(name=f"SUPPORT_{uuid.uuid4().hex[:6]}"))
    d_mgmt = dept_repo.add(Department(name=f"MANAGEMENT_{uuid.uuid4().hex[:6]}"))

    sales = Employee(
        full_name="Sales User",
        email=f"sales_{uuid.uuid4().hex[:6]}@t.com",
        password="hashed",
        employee_number=f"S{uuid.uuid4().hex[:6]}",
        department_id=d_sales.id,
    )
    support = Employee(
        full_name="Support User",
        email=f"support_{uuid.uuid4().hex[:6]}@t.com",
        password="hashed",
        employee_number=f"U{uuid.uuid4().hex[:6]}",
        department_id=d_support.id,
    )
    mgmt = Employee(
        full_name="Mgmt User",
        email=f"mgmt_{uuid.uuid4().hex[:6]}@t.com",
        password="hashed",
        employee_number=f"M{uuid.uuid4().hex[:6]}",
        department_id=d_mgmt.id,
    )

    db_session.add_all([sales, support, mgmt])
    db_session.commit()

    return {"sales": sales, "support": support, "mgmt": mgmt}


@pytest.fixture
def seeded_business(db_session, seeded_staff):
    """Create a client + contracts + event to test controller rules."""
    staff = seeded_staff
    sales = staff["sales"]
    support = staff["support"]

    client = Client(
        full_name="Client A",
        email=f"client_{uuid.uuid4().hex[:6]}@t.com",
        phone="0102030405",
        company_name="Corp",
        sales_contact_id=sales.id,
    )
    db_session.add(client)
    db_session.commit()

    signed_contract = Contract(
        total_amount=1000,
        remaining_amount=100,
        is_signed=True,
        client_id=client.id,
        sales_contact_id=sales.id,
    )
    unsigned_contract = Contract(
        total_amount=500,
        remaining_amount=500,
        is_signed=False,
        client_id=client.id,
        sales_contact_id=sales.id,
    )
    db_session.add_all([signed_contract, unsigned_contract])
    db_session.commit()

    event = Event(
        name="Event A",
        event_date_start=datetime.now() + timedelta(days=1),
        event_date_end=datetime.now() + timedelta(days=2),
        location="Paris",
        attendees=10,
        notes="n",
        client_id=client.id,
        contract_id=signed_contract.id,
        support_contact_id=support.id,
    )
    db_session.add(event)
    db_session.commit()

    return {
        "client": client,
        "signed_contract": signed_contract,
        "unsigned_contract": unsigned_contract,
        "event": event,
    }


def test_client_controller_list_denied_returns_empty(db_session):
    auth = DummyAuthController(allowed=set())
    ctrl = ClientController(ClientRepository(db_session), auth)

    out = ctrl.list_all_clients(user_data={"id": 1, "department": "SALES"})
    assert out == []


def test_client_controller_update_denied_returns_none(db_session, seeded_business):
    auth = DummyAuthController(allowed=set())
    ctrl = ClientController(ClientRepository(db_session), auth)

    client = seeded_business["client"]
    out = ctrl.update_client(
        user_data={"id": client.sales_contact_id, "department": "SALES"},
        client_id=client.id,
        updates={"phone": "0999"},
    )
    assert out is None


def test_client_controller_update_not_found_returns_none(db_session):
    auth = DummyAuthController(allowed={"update_client"})
    ctrl = ClientController(ClientRepository(db_session), auth)

    out = ctrl.update_client(
        user_data={"id": 1, "department": "SALES"},
        client_id=999999,
        updates={"phone": "0999"},
    )
    assert out is None


def test_client_controller_update_denied_when_not_owner_and_not_mgmt(
    db_session, seeded_staff, seeded_business
):
    auth = DummyAuthController(allowed={"update_client"})
    ctrl = ClientController(ClientRepository(db_session), auth)

    client = seeded_business["client"]
    other_sales = seeded_staff["mgmt"]  # id differs from sales_contact_id
    user = {"id": other_sales.id, "department": "SALES"}

    out = ctrl.update_client(user_data=user, client_id=client.id, updates={"phone": "0999"})
    assert out is None


def test_contract_controller_create_denied_returns_none(db_session, seeded_business):
    auth = DummyAuthController(allowed=set())
    ctrl = ContractController(ContractRepository(db_session), auth)

    client = seeded_business["client"]
    out = ctrl.create_contract(
        user_data={"id": client.sales_contact_id, "department": "SALES"},
        contract_data={
            "total_amount": 100,
            "remaining_amount": 50,
            "is_signed": False,
            "client_id": client.id,
            "sales_contact_id": client.sales_contact_id,
        },
    )
    assert out is None


def test_contract_controller_update_not_found_returns_none(db_session):
    auth = DummyAuthController(allowed={"update_contract"})
    ctrl = ContractController(ContractRepository(db_session), auth)

    out = ctrl.update_contract(
        user_data={"id": 1, "department": "SALES"},
        contract_id=999999,
        updates={"remaining_amount": 0},
    )
    assert out is None


def test_employee_controller_create_denied_returns_none(db_session):
    auth = DummyAuthController(allowed=set())
    ctrl = EmployeeController(EmployeeRepository(db_session), auth)

    out = ctrl.create_employee(
        user_data={"id": 1, "department": "SALES"},
        employee_data={
            "full_name": "X",
            "email": f"x_{uuid.uuid4().hex[:6]}@t.com",
            "password": "pw",
            "employee_number": f"E{uuid.uuid4().hex[:6]}",
            "department_id": 1,
        },
    )
    assert out is None


def test_employee_controller_update_not_found_returns_none(db_session):
    auth = DummyAuthController(allowed={"update_employee"})
    ctrl = EmployeeController(EmployeeRepository(db_session), auth)

    out = ctrl.update_employee(
        user_data={"id": 1, "department": "MANAGEMENT"},
        emp_id=999999,
        update_data={"full_name": "New"},
    )
    assert out is None


def test_event_controller_create_denied_when_not_owner(db_session, seeded_staff, seeded_business):
    auth = DummyAuthController(allowed={"create_event"})
    ctrl = EventController(EventRepository(db_session), auth)

    contract = seeded_business["signed_contract"]
    not_owner = seeded_staff["support"]

    out = ctrl.create_event(
        user_data={"id": not_owner.id, "department": "SUPPORT"},
        event_data={
            "name": "Denied Event",
            "event_date_start": datetime.now() + timedelta(days=1),
            "event_date_end": datetime.now() + timedelta(days=2),
            "location": "Paris",
            "attendees": 10,
            "notes": "n",
            "client_id": contract.client_id,
            "contract_id": contract.id,
        },
        contract=contract,
    )
    assert out is None


def test_event_controller_create_denied_when_contract_unsigned(db_session, seeded_staff, seeded_business):
    auth = DummyAuthController(allowed={"create_event"})
    ctrl = EventController(EventRepository(db_session), auth)

    contract = seeded_business["unsigned_contract"]
    owner = seeded_staff["sales"]

    out = ctrl.create_event(
        user_data={"id": owner.id, "department": "SALES"},
        event_data={
            "name": "Denied Unsigned",
            "event_date_start": datetime.now() + timedelta(days=1),
            "event_date_end": datetime.now() + timedelta(days=2),
            "location": "Paris",
            "attendees": 10,
            "notes": "n",
            "client_id": contract.client_id,
            "contract_id": contract.id,
        },
        contract=contract,
    )
    assert out is None


def test_event_controller_update_denied_when_not_assigned_and_not_mgmt(
    db_session, seeded_staff, seeded_business
):
    auth = DummyAuthController(allowed={"update_event"})
    ctrl = EventController(EventRepository(db_session), auth)

    event = seeded_business["event"]
    not_assigned = seeded_staff["sales"]  # event.support_contact_id is support

    out = ctrl.update_event(
        user_data={"id": not_assigned.id, "department": "SALES"},
        event_id=event.id,
        updates={"notes": "x"},
    )
    assert out is None


def test_event_controller_update_not_found_returns_none(db_session):
    auth = DummyAuthController(allowed={"update_event"})
    ctrl = EventController(EventRepository(db_session), auth)

    out = ctrl.update_event(
        user_data={"id": 1, "department": "MANAGEMENT"},
        event_id=999999,
        updates={"notes": "x"},
    )
    assert out is None

===============================================================================
FILE: ./tests/test_functional_auth.py
------------------------------------------------------------------------------
META: 1647 bytes | modified: 2026-02-21 19:13:56
===============================================================================

"""
Functional tests for authentication controller flows.

List of tests:
- test_auth_controller_full_flow: Covers logout and failed login logic.
- test_auth_login_success: Covers successful login and user data structure.
"""

import pytest
from app.controllers.auth_controller import AuthController
from app.repositories.employee_repository import EmployeeRepository
from app.models.department import Department
from app.models.employee import Employee
from app.utils.auth import hash_password


@pytest.fixture
def auth_ctrl(db_session):
    """Fixture for AuthController."""
    return AuthController(EmployeeRepository(db_session))


def test_auth_controller_full_flow(auth_ctrl):
    """Covers logout and failed login logic."""
    auth_ctrl.logout()
    assert auth_ctrl.current_user_data is None
    assert auth_ctrl.login("ghost@missing.com", "password") is None
    assert auth_ctrl.check_user_permission("read") is False


def test_auth_login_success(db_session, auth_ctrl):
    """Covers successful login and user data structure."""
    dept = Department(name="AUTH_DEPT")
    db_session.add(dept)
    db_session.flush()

    pwd = hash_password("secret123")
    emp = Employee(
        full_name="Auth Success",
        email="success@test.com",
        password=pwd,
        employee_number="EMP_OK",
        department_id=dept.id
    )
    db_session.add(emp)
    db_session.commit()

    user = auth_ctrl.login("success@test.com", "secret123")
    assert user is not None
    # AuthController.login does not return 'email' in user_data dict
    assert user["full_name"] == "Auth Success"
    assert user["department"] == "AUTH_DEPT"

===============================================================================
FILE: ./tests/test_functional_management.py
------------------------------------------------------------------------------
META: 3459 bytes | modified: 2026-02-19 18:25:44
===============================================================================

# tests/test_functional_management.py
"""
Functional tests for Management (T12) operations.

Tests included:
- test_list_employees_as_management: Success for authorized users.
- test_create_employee_as_management: Success for authorized users.
- test_create_employee_as_sales_denied: Access control check.
- test_list_contracts_permission: Verify role-based contract access.
"""

import uuid
import pytest
from sqlalchemy import select
from app.controllers.employee_controller import EmployeeController
from app.controllers.contract_controller import ContractController
from app.controllers.auth_controller import AuthController
from app.repositories.employee_repository import EmployeeRepository
from app.repositories.contract_repository import ContractRepository
from app.models.department import Department
from app.repositories.base_repository import BaseRepository


@pytest.fixture
def management_suite(db_session):
    """Setup repositories and controllers with duplicate check."""
    dept_repo = BaseRepository(db_session, Department)
    emp_repo = EmployeeRepository(db_session)
    cont_repo = ContractRepository(db_session)
    auth_ctrl = AuthController(emp_repo)

    existing_dept = db_session.execute(
        select(Department).filter_by(name="MANAGEMENT")
    ).scalar_one_or_none()

    if existing_dept:
        test_dept = existing_dept
    else:
        test_dept = dept_repo.add(Department(name="MANAGEMENT"))

    emp_ctrl = EmployeeController(emp_repo, auth_ctrl)
    cont_ctrl = ContractController(cont_repo, auth_ctrl)

    return {
        "emp_ctrl": emp_ctrl,
        "cont_ctrl": cont_ctrl,
        "dept_id": test_dept.id
    }


def test_list_employees_as_management(management_suite):
    """Verify management can list employees."""
    ctrl = management_suite["emp_ctrl"]
    user_data = {"id": 1, "department": "MANAGEMENT"}

    result = ctrl.list_all_employees(user_data=user_data)
    assert isinstance(result, list)


def test_create_employee_as_management(management_suite):
    """Verify management can create a new employee."""
    ctrl = management_suite["emp_ctrl"]
    user_data = {"id": 1, "department": "MANAGEMENT"}

    email = f"manager_{uuid.uuid4().hex[:6]}@crm.com"
    emp_data = {
        "full_name": "New Manager",
        "email": email,
        "password": "securepassword",
        "employee_number": f"MGT_{uuid.uuid4().hex[:4]}",
        "department_id": management_suite["dept_id"]
    }

    new_emp = ctrl.create_employee(user_data=user_data, employee_data=emp_data)
    assert new_emp is not None
    assert new_emp.email == email


def test_create_employee_as_sales_denied(management_suite):
    """Verify sales role cannot create an employee."""
    ctrl = management_suite["emp_ctrl"]
    user_data = {"id": 2, "department": "SALES"}
    emp_data = {
        "full_name": "Unauthorized",
        "email": f"bad_{uuid.uuid4().hex[:4]}@crm.com",
        "password": "p",
        "employee_number": f"BAD_{uuid.uuid4().hex[:4]}",
        "department_id": management_suite["dept_id"]
    }

    result = ctrl.create_employee(user_data=user_data, employee_data=emp_data)
    assert result is None


def test_list_contracts_permission(management_suite):
    """Verify contract listing access for management."""
    ctrl = management_suite["cont_ctrl"]
    user_data = {"id": 1, "department": "MANAGEMENT"}

    result = ctrl.list_all_contracts(user_data=user_data)
    assert result is not None

===============================================================================
FILE: ./tests/test_functional_permissions.py
------------------------------------------------------------------------------
META: 1897 bytes | modified: 2026-02-19 18:07:46
===============================================================================

# tests/test_functional_permissions.py
"""
Functional tests for Role-Based Access Control (RBAC).

Tests included:
- test_management_can_create_employee: Verify high-level admin rights.
- test_sales_cannot_create_employee: Verify restriction for non-admin roles.
- test_sales_can_create_client: Verify role-specific creation rights.
- test_support_restrictions: Verify support agent cannot create contracts.
"""

import pytest
from app.controllers.auth_controller import AuthController
from app.repositories.employee_repository import EmployeeRepository


@pytest.fixture
def auth_controller(db_session):
    """Provides an AuthController instance."""
    return AuthController(EmployeeRepository(db_session))


def test_management_can_create_employee(auth_controller):
    """Verify Management role has administrative permissions."""
    auth_controller.current_user_data = {"department": "MANAGEMENT"}
    assert auth_controller.check_user_permission("create_employee") is True


def test_sales_cannot_create_employee(auth_controller):
    """Verify Sales role is restricted from administrative tasks."""
    auth_controller.current_user_data = {"department": "SALES"}
    assert auth_controller.check_user_permission("create_employee") is False


def test_sales_can_create_client(auth_controller):
    """Verify Sales role can perform their core business tasks."""
    auth_controller.current_user_data = {"department": "SALES"}
    assert auth_controller.check_user_permission("create_client") is True


def test_support_restrictions(auth_controller):
    """Verify Support role cannot perform Sales or Management tasks."""
    auth_controller.current_user_data = {"department": "SUPPORT"}
    # Can update events
    assert auth_controller.check_user_permission("update_event") is True
    # Cannot create contracts
    assert auth_controller.check_user_permission("create_contract") is False

===============================================================================
FILE: ./tests/test_functional_sales.py
------------------------------------------------------------------------------
META: 15246 bytes | modified: 2026-02-20 22:23:37
===============================================================================

"""
Functional tests for Sales (T13) operations.

List of tests:
- test_sales_can_create_client: Verify client creation and auto-assignment (6.8).
- test_support_cannot_create_client: Verify permission restriction for creation.
- test_sales_can_update_own_client: Success for assigned contact (6.9).
- test_sales_cannot_update_other_client: Denied for non-assigned contact.
- test_management_can_create_contract: Verify contract creation by management (6.10).
- test_sales_can_sign_own_contract: Verify sales can update their assigned
  contracts (6.11).
- test_sales_can_create_event_for_signed_contract: Success if signed and owner
  (6.12).
- test_sales_cannot_create_event_for_unsigned_contract: Denied if not signed
  (6.12).
- test_support_can_update_assigned_event: Verify support can update their event
  (6.13).
- test_sales_list_unsigned_contracts_filtered_by_owner: Verify sales sees only
  their unsigned contracts.
- test_sales_list_unpaid_contracts_filtered_by_owner: Verify sales sees only
  their unpaid contracts.
"""

import uuid
import pytest
from datetime import datetime, timedelta
from sqlalchemy import select
from app.controllers.client_controller import ClientController
from app.controllers.contract_controller import ContractController
from app.controllers.event_controller import EventController
from app.controllers.auth_controller import AuthController
from app.repositories.client_repository import ClientRepository
from app.repositories.contract_repository import ContractRepository
from app.repositories.event_repository import EventRepository
from app.repositories.employee_repository import EmployeeRepository
from app.models.department import Department
from app.models.employee import Employee
from app.models.client import Client
from app.models.contract import Contract
from app.models.event import Event
from app.repositories.base_repository import BaseRepository


@pytest.fixture
def sales_suite(db_session):
    """Setup repositories and controllers for sales tests."""
    dept_repo = BaseRepository(db_session, Department)
    emp_repo = EmployeeRepository(db_session)
    client_repo = ClientRepository(db_session)
    contract_repo = ContractRepository(db_session)
    event_repo = EventRepository(db_session)

    auth_ctrl = AuthController(emp_repo)
    client_ctrl = ClientController(client_repo, auth_ctrl)
    contract_ctrl = ContractController(contract_repo, auth_ctrl)
    event_ctrl = EventController(event_repo, auth_ctrl)

    # Setup departments
    for name in ["SALES", "MANAGEMENT", "SUPPORT"]:
        if not db_session.execute(
            select(Department).filter_by(name=name)
        ).scalar():
            dept_repo.add(Department(name=name))

    sales_dept = db_session.execute(
        select(Department).filter_by(name="SALES")
    ).scalar()
    mgmt_dept = db_session.execute(
        select(Department).filter_by(name="MANAGEMENT")
    ).scalar()
    supp_dept = db_session.execute(
        select(Department).filter_by(name="SUPPORT")
    ).scalar()

    # Employees
    unique_s1 = uuid.uuid4().hex[:4]
    s1 = emp_repo.add(Employee(
        full_name="Sales One", email=f"s1_{unique_s1}@crm.com",
        password="p", employee_number=f"S1_{unique_s1}",
        department_id=sales_dept.id
    ))

    unique_s2 = uuid.uuid4().hex[:4]
    s2 = emp_repo.add(Employee(
        full_name="Sales Two", email=f"s2_{unique_s2}@crm.com",
        password="p", employee_number=f"S2_{unique_s2}",
        department_id=sales_dept.id
    ))

    unique_m = uuid.uuid4().hex[:4]
    mgmt = emp_repo.add(Employee(
        full_name="Mgmt User", email=f"m1_{unique_m}@crm.com",
        password="p", employee_number=f"M1_{unique_m}",
        department_id=mgmt_dept.id
    ))

    unique_supp = uuid.uuid4().hex[:4]
    supp = emp_repo.add(Employee(
        full_name="Support User", email=f"supp_{unique_supp}@crm.com",
        password="p", employee_number=f"SUP_{unique_supp}",
        department_id=supp_dept.id
    ))

    # Seed baseline client/contract used by tests with hardcoded IDs
    baseline_client = client_repo.add(Client(
        full_name="Baseline Client",
        email=f"baseline_{uuid.uuid4().hex[:6]}@crm.com",
        phone="000",
        company_name="Baseline Corp",
        sales_contact_id=s1.id
    ))

    contract_repo.add(Contract(
        total_amount=1000,
        remaining_amount=1000,
        is_signed=True,
        client_id=baseline_client.id,
        sales_contact_id=s1.id
    ))

    return {
        "client_ctrl": client_ctrl,
        "contract_ctrl": contract_ctrl,
        "event_ctrl": event_ctrl,
        "sales_1": s1,
        "sales_2": s2,
        "mgmt_user": mgmt,
        "supp_user": supp
    }


def test_sales_can_create_client(sales_suite):
    """Verify that a SALES user can create a client with auto-assignment."""
    ctrl = sales_suite["client_ctrl"]
    user = sales_suite["sales_1"]
    user_data = {"id": user.id, "department": "SALES"}
    client_data = {
        "full_name": "Test Client Inc",
        "email": f"contact_{uuid.uuid4().hex[:6]}@client.com",
        "phone": "0102030405",
        "company_name": "Test Corp"
    }
    new_client = ctrl.create_client(user_data=user_data, client_data=client_data)
    assert new_client is not None
    assert new_client.sales_contact_id == user.id


def test_support_cannot_create_client(sales_suite):
    """Verify that a SUPPORT user cannot create a client."""
    ctrl = sales_suite["client_ctrl"]
    user_data = {"id": 999, "department": "SUPPORT"}
    client_data = {
        "full_name": "Forbidden",
        "email": "f@client.com",
        "phone": "0000",
        "company_name": "No Access"
    }
    result = ctrl.create_client(user_data=user_data, client_data=client_data)
    assert result is None


def test_sales_can_update_own_client(sales_suite):
    """Verify sales can update their assigned client."""
    ctrl = sales_suite["client_ctrl"]
    s1 = sales_suite["sales_1"]
    user_data = {"id": s1.id, "department": "SALES"}

    client_data = {
        "full_name": "Owned Client",
        "email": f"c_{uuid.uuid4().hex[:4]}@c.com",
        "phone": "12345",
        "company_name": "Own Corp",
        "sales_contact_id": s1.id
    }
    client = ctrl.create_client(user_data=user_data, client_data=client_data)

    updated = ctrl.update_client(
        user_data=user_data,
        client_id=client.id,
        updates={"phone": "99999"}
    )
    assert updated is not None
    assert updated.phone == "99999"


def test_sales_cannot_update_other_client(sales_suite):
    """Verify sales cannot update a client assigned to someone else."""
    ctrl = sales_suite["client_ctrl"]
    s1 = sales_suite["sales_1"]
    s2 = sales_suite["sales_2"]

    client_data = {
        "full_name": "S1 Client",
        "email": f"c_{uuid.uuid4().hex[:4]}@c.com",
        "phone": "123",
        "company_name": "S1 Corp",
        "sales_contact_id": s1.id
    }
    client = ctrl.create_client(
        user_data={"id": s1.id, "department": "SALES"},
        client_data=client_data
    )

    result = ctrl.update_client(
        user_data={"id": s2.id, "department": "SALES"},
        client_id=client.id,
        updates={"phone": "000"}
    )
    assert result is None


def test_management_can_create_contract(sales_suite):
    """Verify that MANAGEMENT can create a contract for a client."""
    client_ctrl = sales_suite["client_ctrl"]
    contract_ctrl = sales_suite["contract_ctrl"]
    sales_user = sales_suite["sales_1"]
    mgmt_user = sales_suite["mgmt_user"]

    client = client_ctrl.create_client(
        user_data={"id": sales_user.id, "department": "SALES"},
        client_data={
            "full_name": "Contract Client",
            "email": f"c_{uuid.uuid4().hex[:4]}@c.com",
            "phone": "0600000000",
            "company_name": "Contract Corp"
        }
    )

    contract_data = {
        "total_amount": 1000.00,
        "remaining_amount": 1000.00,
        "is_signed": False,
        "client_id": client.id,
        "sales_contact_id": sales_user.id
    }

    new_contract = contract_ctrl.create_contract(
        user_data={"id": mgmt_user.id, "department": "MANAGEMENT"},
        contract_data=contract_data
    )

    assert new_contract is not None
    assert float(new_contract.total_amount) == 1000.00


def test_sales_can_sign_own_contract(sales_suite):
    """Verify that sales can sign a contract assigned to them."""
    client_ctrl = sales_suite["client_ctrl"]
    contract_ctrl = sales_suite["contract_ctrl"]
    sales_user = sales_suite["sales_1"]
    user_data = {"id": sales_user.id, "department": "SALES"}

    client = client_ctrl.create_client(
        user_data=user_data,
        client_data={
            "full_name": "Sign Client",
            "email": f"c_{uuid.uuid4().hex[:4]}@c.com",
            "phone": "0611111111",
            "company_name": "Sign Corp"
        }
    )

    contract = contract_ctrl.repository.add(Contract(
        total_amount=500,
        remaining_amount=500,
        is_signed=False,
        client_id=client.id,
        sales_contact_id=sales_user.id
    ))

    updated = contract_ctrl.update_contract(
        user_data=user_data,
        contract_id=contract.id,
        updates={"is_signed": True}
    )

    assert updated is not None
    assert updated.is_signed is True


def test_sales_can_create_event_for_signed_contract(sales_suite):
    """Verify event creation works for a signed contract (6.12)."""
    event_ctrl = sales_suite["event_ctrl"]
    contract_ctrl = sales_suite["contract_ctrl"]
    sales_user = sales_suite["sales_1"]
    user_data = {"id": sales_user.id, "department": "SALES"}

    client = sales_suite["client_ctrl"].create_client(
        user_data=user_data,
        client_data={
            "full_name": "Event Client",
            "email": f"e_{uuid.uuid4().hex[:4]}@c.com",
            "phone": "06",
            "company_name": "Event Corp"
        }
    )

    contract = contract_ctrl.repository.add(Contract(
        total_amount=1000,
        remaining_amount=1000,
        is_signed=True,
        client_id=client.id,
        sales_contact_id=sales_user.id
    ))

    event_data = {
        "name": "Launch Party",
        "event_date_start": datetime.now(),
        "event_date_end": datetime.now() + timedelta(hours=2),
        "location": "Paris",
        "attendees": 50,
        "notes": "Test notes",
        "client_id": client.id,
        "contract_id": contract.id
    }

    event = event_ctrl.create_event(
        user_data=user_data,
        event_data=event_data,
        contract=contract
    )
    assert event is not None
    assert event.name == "Launch Party"


def test_sales_cannot_create_event_for_unsigned_contract(sales_suite):
    """Verify event creation is blocked if contract is not signed (6.12)."""
    event_ctrl = sales_suite["event_ctrl"]
    sales_user = sales_suite["sales_1"]
    user_data = {"id": sales_user.id, "department": "SALES"}

    contract = Contract(is_signed=False, sales_contact_id=sales_user.id)

    event = event_ctrl.create_event(
        user_data=user_data,
        event_data={},
        contract=contract
    )
    assert event is None


def test_support_can_update_assigned_event(sales_suite):
    """Verify support can update an event assigned to them (6.13)."""
    event_ctrl = sales_suite["event_ctrl"]
    supp_user = sales_suite["supp_user"]
    user_data = {"id": supp_user.id, "department": "SUPPORT"}

    # Setup: Create manual event assigned to supp_user
    new_event = event_ctrl.repository.add(Event(
        name="Update Test",
        event_date_start=datetime.now(),
        event_date_end=datetime.now(),
        location="Lyon",
        attendees=10,
        notes="Initial",
        client_id=1,
        contract_id=1,
        support_contact_id=supp_user.id
    ))

    updated = event_ctrl.update_event(
        user_data=user_data,
        event_id=new_event.id,
        updates={"notes": "Updated notes"}
    )

    assert updated is not None
    assert updated.notes == "Updated notes"


def test_sales_list_unsigned_contracts_filtered_by_owner(sales_suite):
    """Verify sales sees only their unsigned contracts."""
    client_ctrl = sales_suite["client_ctrl"]
    contract_ctrl = sales_suite["contract_ctrl"]
    s1 = sales_suite["sales_1"]
    s2 = sales_suite["sales_2"]

    s1_user = {"id": s1.id, "department": "SALES"}
    s2_user = {"id": s2.id, "department": "SALES"}

    s1_client = client_ctrl.create_client(
        user_data=s1_user,
        client_data={
            "full_name": "Unsigned S1 Client",
            "email": f"u1_{uuid.uuid4().hex[:6]}@c.com",
            "phone": "01",
            "company_name": "U1 Corp",
        },
    )
    s2_client = client_ctrl.create_client(
        user_data=s2_user,
        client_data={
            "full_name": "Unsigned S2 Client",
            "email": f"u2_{uuid.uuid4().hex[:6]}@c.com",
            "phone": "02",
            "company_name": "U2 Corp",
        },
    )

    s1_contract = contract_ctrl.repository.add(Contract(
        total_amount=100,
        remaining_amount=100,
        is_signed=False,
        client_id=s1_client.id,
        sales_contact_id=s1.id,
    ))
    contract_ctrl.repository.add(Contract(
        total_amount=200,
        remaining_amount=200,
        is_signed=False,
        client_id=s2_client.id,
        sales_contact_id=s2.id,
    ))

    results = contract_ctrl.list_unsigned_contracts(user_data=s1_user) or []
    result_ids = {c.id for c in results}

    assert s1_contract.id in result_ids
    assert all(c.sales_contact_id == s1.id for c in results)


def test_sales_list_unpaid_contracts_filtered_by_owner(sales_suite):
    """Verify sales sees only their unpaid contracts."""
    client_ctrl = sales_suite["client_ctrl"]
    contract_ctrl = sales_suite["contract_ctrl"]
    s1 = sales_suite["sales_1"]
    s2 = sales_suite["sales_2"]

    s1_user = {"id": s1.id, "department": "SALES"}
    s2_user = {"id": s2.id, "department": "SALES"}

    s1_client = client_ctrl.create_client(
        user_data=s1_user,
        client_data={
            "full_name": "Unpaid S1 Client",
            "email": f"p1_{uuid.uuid4().hex[:6]}@c.com",
            "phone": "03",
            "company_name": "P1 Corp",
        },
    )
    s2_client = client_ctrl.create_client(
        user_data=s2_user,
        client_data={
            "full_name": "Unpaid S2 Client",
            "email": f"p2_{uuid.uuid4().hex[:6]}@c.com",
            "phone": "04",
            "company_name": "P2 Corp",
        },
    )

    s1_contract = contract_ctrl.repository.add(Contract(
        total_amount=300,
        remaining_amount=50,
        is_signed=True,
        client_id=s1_client.id,
        sales_contact_id=s1.id,
    ))
    contract_ctrl.repository.add(Contract(
        total_amount=400,
        remaining_amount=10,
        is_signed=True,
        client_id=s2_client.id,
        sales_contact_id=s2.id,
    ))

    results = contract_ctrl.list_unpaid_contracts(user_data=s1_user) or []
    result_ids = {c.id for c in results}

    assert s1_contract.id in result_ids
    assert all(c.sales_contact_id == s1.id for c in results)

===============================================================================
FILE: ./tests/test_integration_business_repos.py
------------------------------------------------------------------------------
META: 3949 bytes | modified: 2026-02-19 17:37:13
===============================================================================

# tests/test_integration_business_repos.py
"""
Integration tests for Business Repositories (Client, Contract, Event).

Tests included:
- test_client_contract_event_chain: Verify the full creation chain with FKs.
- test_contract_integrity_violation: Verify error when client is missing.
- test_event_logic_queries: Verify business filters (unsigned, unpaid, etc.).
"""

import uuid
import pytest
from sqlalchemy.exc import IntegrityError
from app.repositories.client_repository import ClientRepository
from app.repositories.contract_repository import ContractRepository
from app.repositories.event_repository import EventRepository
from app.repositories.employee_repository import EmployeeRepository
from app.repositories.base_repository import BaseRepository
from app.models.department import Department
from app.models.employee import Employee
from app.models.client import Client
from app.models.contract import Contract
from app.models.event import Event
from datetime import datetime, timedelta


@pytest.fixture
def business_setup(db_session):
    """Fixture to provide staff and repositories for business integration."""
    dept_repo = BaseRepository(db_session, Department)
    emp_repo = EmployeeRepository(db_session)

    dept = dept_repo.add(Department(name=f"BIZ_{uuid.uuid4().hex[:6]}"))
    sales = emp_repo.add(Employee(
        full_name="Sales Rep",
        email=f"sales_{uuid.uuid4().hex[:6]}@epic.com",
        password="hash",
        employee_number=f"S_{uuid.uuid4().hex[:6]}",
        department_id=dept.id
    ))

    return {
        "sales": sales,
        "client_repo": ClientRepository(db_session),
        "contract_repo": ContractRepository(db_session),
        "event_repo": EventRepository(db_session)
    }


def test_client_contract_event_chain(business_setup):
    """Test the creation chain: Client -> Contract -> Event."""
    s = business_setup

    # 1. Create Client
    client = s["client_repo"].add(Client(
        full_name="Biz Client",
        email=f"biz_{uuid.uuid4().hex[:6]}@corp.com",
        phone="010203",
        company_name="BizCorp",
        sales_contact_id=s["sales"].id
    ))

    # 2. Create Contract
    contract = s["contract_repo"].add(Contract(
        total_amount=2000.0,
        remaining_amount=1000.0,
        is_signed=True,
        client_id=client.id,
        sales_contact_id=s["sales"].id
    ))

    # 3. Create Event
    event = s["event_repo"].add(Event(
        name="Biz Event",
        event_date_start=datetime.now(),
        event_date_end=datetime.now() + timedelta(hours=2),
        location="Paris",
        attendees=50,
        notes="Notes",
        client_id=client.id,
        contract_id=contract.id
    ))

    assert event.id is not None
    assert event.contract.total_amount == 2000.0
    assert event.client.full_name == "Biz Client"


def test_contract_integrity_violation(business_setup):
    """Verify that a contract cannot be created without a valid client."""
    s = business_setup
    invalid_contract = Contract(
        total_amount=100,
        remaining_amount=100,
        client_id=9999,  # Non-existent
        sales_contact_id=s["sales"].id
    )

    with pytest.raises(IntegrityError):
        s["contract_repo"].add(invalid_contract)


def test_event_logic_queries(business_setup):
    """Verify that specific repository filters return correct data."""
    s = business_setup

    # Create an unsigned contract
    client = s["client_repo"].add(Client(
        full_name="Filter Client",
        email=f"f_{uuid.uuid4().hex[:6]}@test.com",
        phone="0", company_name="F", sales_contact_id=s["sales"].id
    ))

    s["contract_repo"].add(Contract(
        total_amount=500, remaining_amount=500, is_signed=False,
        client_id=client.id, sales_contact_id=s["sales"].id
    ))

    unsigned = s["contract_repo"].get_unsigned_contracts()
    assert len(unsigned) >= 1
    assert any(c.is_signed is False for c in unsigned)

===============================================================================
FILE: ./tests/test_integration_staff_repos.py
------------------------------------------------------------------------------
META: 2580 bytes | modified: 2026-02-19 17:33:03
===============================================================================

# tests/test_integration_staff_repos.py
"""
Integration tests for Staff Repositories (Department & Employee).

Tests included:
- test_staff_creation_flow: Create a department then an employee linked to it.
- test_employee_unique_constraints_repo: Verify IntegrityError via Repository.
- test_department_lookup: Verify fetching department by name.
"""

import uuid
import pytest
from sqlalchemy.exc import IntegrityError
from app.repositories.department_repository import DepartmentRepository
from app.repositories.employee_repository import EmployeeRepository
from app.models.department import Department
from app.models.employee import Employee


@pytest.fixture
def staff_repos(db_session):
    """Fixture providing both staff repositories."""
    return DepartmentRepository(db_session), EmployeeRepository(db_session)


def test_staff_creation_flow(staff_repos):
    """Test full integration: creating a department and a linked employee."""
    dept_repo, emp_repo = staff_repos

    # 1. Create Department
    dept_name = f"DEPT_{uuid.uuid4().hex[:6]}"
    dept = Department(name=dept_name)
    dept_repo.add(dept)

    # 2. Create Employee linked to Dept
    emp_email = f"staff_{uuid.uuid4().hex[:6]}@epic.com"
    emp = Employee(
        full_name="Staff Member",
        email=emp_email,
        password="secure_hash",
        employee_number=f"EMP_{uuid.uuid4().hex[:6]}",
        department_id=dept.id
    )
    emp_repo.add(emp)

    # 3. Verify Integration
    fetched_emp = emp_repo.get_by_email(emp_email)
    assert fetched_emp.department.name == dept_name


def test_employee_unique_constraints_repo(staff_repos):
    """Verify that repositories correctly handle DB unique constraints."""
    dept_repo, emp_repo = staff_repos

    dept = Department(name=f"UNIQUE_DEPT_{uuid.uuid4().hex[:6]}")
    dept_repo.add(dept)

    shared_email = "duplicate@epic.com"
    emp1 = Employee(
        full_name="User 1", email=shared_email, password="h",
        employee_number="N1", department_id=dept.id
    )
    emp_repo.add(emp1)

    emp2 = Employee(
        full_name="User 2", email=shared_email, password="h",
        employee_number="N2", department_id=dept.id
    )

    with pytest.raises(IntegrityError):
        emp_repo.add(emp2)


def test_department_lookup(staff_repos):
    """Test the specific get_by_name method in DepartmentRepository."""
    dept_repo, _ = staff_repos
    name = "SUPPORT_TEAM"
    dept = Department(name=name)
    dept_repo.add(dept)

    found = dept_repo.get_by_name(name)
    assert found is not None
    assert found.id == dept.id

===============================================================================
FILE: ./tests/test_jwt_handler.py
------------------------------------------------------------------------------
META: 1244 bytes | modified: 2026-02-19 15:05:56
===============================================================================

# tests/test_jwt_handler.py
"""
Unit tests for JWT handler.

Tests included:
- test_create_and_decode_valid_token: Verify generation and decoding.
- test_decode_invalid_token: Ensure invalid strings return None.
- test_expired_token: Verify expiration logic returns None.
"""

import datetime
import jwt
from app.utils.jwt_handler import create_token, decode_token, SECRET_KEY, ALGORITHM


def test_create_and_decode_valid_token():
    """Verify that a generated token can be correctly decoded."""
    token = create_token(1, "Management")
    decoded = decode_token(token)

    assert decoded is not None
    assert decoded["sub"] == "1"
    assert decoded["department"] == "Management"


def test_decode_invalid_token():
    """Ensure that an invalid token returns None."""
    assert decode_token("invalid.token.string") is None


def test_expired_token():
    """Verify that an expired token returns None."""
    now = datetime.datetime.now(datetime.UTC)
    payload = {
        "sub": "1",
        "department": "Sales",
        "exp": int((now - datetime.timedelta(seconds=1)).timestamp())
    }
    expired_token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

    decoded = decode_token(expired_token)
    assert decoded is None

===============================================================================
FILE: ./tests/test_logic_filters.py
------------------------------------------------------------------------------
META: 5323 bytes | modified: 2026-02-19 17:44:00
===============================================================================

# tests/test_logic_filters.py
"""
Unit tests for specialized repository filtering logic.

Tests included:
- test_filter_unpaid_contracts: Verify only contracts with remaining_amount > 0 are returned.
- test_filter_events_without_support: Verify events with support_contact_id=None are returned.
- test_filter_unsigned_contracts: Verify only is_signed=False contracts are returned.
- test_filter_my_events: Verify support agents only see their assigned events.
"""

import uuid
import pytest
from datetime import datetime
from app.repositories.contract_repository import ContractRepository
from app.repositories.event_repository import EventRepository
from app.repositories.client_repository import ClientRepository
from app.repositories.employee_repository import EmployeeRepository
from app.repositories.base_repository import BaseRepository
from app.models.department import Department
from app.models.employee import Employee
from app.models.client import Client
from app.models.contract import Contract
from app.models.event import Event


@pytest.fixture
def filter_setup(db_session):
    """Setup a batch of data with various states for filtering tests."""
    dept_repo = BaseRepository(db_session, Department)
    emp_repo = EmployeeRepository(db_session)
    client_repo = ClientRepository(db_session)
    contract_repo = ContractRepository(db_session)

    dept = dept_repo.add(Department(name=f"FILT_{uuid.uuid4().hex[:6]}"))
    sales = emp_repo.add(Employee(
        full_name="Sales",
        email=f"s_{uuid.uuid4().hex[:6]}@test.com",
        password="h",
        employee_number=f"S{uuid.uuid4().hex[:4]}",
        department_id=dept.id
    ))
    support = emp_repo.add(Employee(
        full_name="Support",
        email=f"p_{uuid.uuid4().hex[:6]}@test.com",
        password="h",
        employee_number=f"P{uuid.uuid4().hex[:4]}",
        department_id=dept.id
    ))
    client = client_repo.add(Client(
        full_name="C",
        email=f"c_{uuid.uuid4().hex[:6]}@test.com",
        phone="0",
        company_name="C",
        sales_contact_id=sales.id
    ))
    # Create default contract for events
    contract = contract_repo.add(Contract(
        total_amount=1000,
        remaining_amount=500,
        is_signed=True,
        client_id=client.id,
        sales_contact_id=sales.id
    ))

    return {
        "db": db_session,
        "sales": sales,
        "support": support,
        "client": client,
        "contract": contract,
        "contract_repo": contract_repo,
        "event_repo": EventRepository(db_session)
    }


def test_filter_unpaid_contracts(filter_setup):
    """Verify that only contracts with a remaining balance are fetched."""
    repo = filter_setup["contract_repo"]
    client_id = filter_setup["client"].id
    sales_id = filter_setup["sales"].id

    repo.add(Contract(
        total_amount=1000, remaining_amount=0, is_signed=True,
        client_id=client_id, sales_contact_id=sales_id
    ))
    repo.add(Contract(
        total_amount=1000, remaining_amount=500, is_signed=True,
        client_id=client_id, sales_contact_id=sales_id
    ))

    unpaid = repo.get_unpaid_contracts()
    assert all(c.remaining_amount > 0 for c in unpaid)


def test_filter_events_without_support(filter_setup):
    """Verify that we can find events that need a support assignment."""
    repo = filter_setup["event_repo"]
    client_id = filter_setup["client"].id
    contract_id = filter_setup["contract"].id

    # Event with support
    repo.add(Event(
        name="E1", event_date_start=datetime.now(),
        event_date_end=datetime.now(), location="L", attendees=10,
        notes="N", client_id=client_id, contract_id=contract_id,
        support_contact_id=filter_setup["support"].id
    ))
    # Event without support
    repo.add(Event(
        name="E2", event_date_start=datetime.now(),
        event_date_end=datetime.now(), location="L", attendees=10,
        notes="N", client_id=client_id, contract_id=contract_id,
        support_contact_id=None
    ))

    no_support = repo.get_events_without_support()
    assert any(e.name == "E2" for e in no_support)
    assert all(e.support_contact_id is None for e in no_support)


def test_filter_unsigned_contracts(filter_setup):
    """Verify filtering of unsigned contracts."""
    repo = filter_setup["contract_repo"]
    client_id = filter_setup["client"].id
    sales_id = filter_setup["sales"].id

    repo.add(Contract(
        total_amount=100, remaining_amount=100, is_signed=False,
        client_id=client_id, sales_contact_id=sales_id
    ))

    unsigned = repo.get_unsigned_contracts()
    assert any(c.is_signed is False for c in unsigned)


def test_filter_my_events(filter_setup):
    """Verify support agents only see their assigned events."""
    repo = filter_setup["event_repo"]
    client_id = filter_setup["client"].id
    contract_id = filter_setup["contract"].id
    support_id = filter_setup["support"].id

    repo.add(Event(
        name="My Event", event_date_start=datetime.now(),
        event_date_end=datetime.now(), location="L", attendees=5,
        notes="N", client_id=client_id, contract_id=contract_id,
        support_contact_id=support_id
    ))

    my_events = repo.get_my_events(support_id)
    assert all(e.support_contact_id == support_id for e in my_events)

===============================================================================
FILE: ./tests/test_models_business.py
------------------------------------------------------------------------------
META: 4776 bytes | modified: 2026-02-19 17:13:27
===============================================================================

# tests/test_models_business.py
"""
Unit tests for Business models (Client, Contract, and Event).

Tests included:
- test_create_client: Verify client creation and relationship with sales.
- test_create_contract: Verify contract linked to client and sales contact.
- test_create_event: Verify event linked to contract, client and support.
- test_client_email_uniqueness: Ensure client emails are unique.
"""

import uuid
from datetime import datetime, timedelta
import pytest
from sqlalchemy.exc import IntegrityError
from app.models.department import Department
from app.models.employee import Employee
from app.models.client import Client
from app.models.contract import Contract
from app.models.event import Event


@pytest.fixture
def test_setup(db_session):
    """Fixture to provide a department and employees for business tests."""
    dept_sales = Department(name=f"SALES_{uuid.uuid4().hex[:6]}")
    dept_support = Department(name=f"SUPPORT_{uuid.uuid4().hex[:6]}")
    db_session.add_all([dept_sales, dept_support])
    db_session.commit()

    sales = Employee(
        full_name="Sales Guy",
        email=f"sales_{uuid.uuid4().hex[:6]}@epic.com",
        password="hash",
        employee_number=f"S_{uuid.uuid4().hex[:6]}",
        department_id=dept_sales.id
    )
    support = Employee(
        full_name="Support Guy",
        email=f"support_{uuid.uuid4().hex[:6]}@epic.com",
        password="hash",
        employee_number=f"SUP_{uuid.uuid4().hex[:6]}",
        department_id=dept_support.id
    )
    db_session.add_all([sales, support])
    db_session.commit()
    return sales, support


def test_create_client(db_session, test_setup):
    """Test client creation linked to a sales employee."""
    sales, _ = test_setup
    unique_email = f"client_{uuid.uuid4().hex[:6]}@corp.com"
    client = Client(
        full_name="Alice Client",
        email=unique_email,
        phone="0123456789",
        company_name="Alice Corp",
        sales_contact_id=sales.id
    )
    db_session.add(client)
    db_session.commit()

    assert client.id is not None
    assert client.sales_contact.full_name == "Sales Guy"
    assert str(client) == "<Client(name=Alice Client, company=Alice Corp)>"


def test_create_contract(db_session, test_setup):
    """Test contract creation with amounts and signature status."""
    sales, _ = test_setup
    client = Client(
        full_name="Contract Client",
        email=f"c_{uuid.uuid4().hex[:6]}@test.com",
        phone="000",
        company_name="C-Corp",
        sales_contact_id=sales.id
    )
    db_session.add(client)
    db_session.commit()

    contract = Contract(
        total_amount=1000.50,
        remaining_amount=500.00,
        is_signed=True,
        client_id=client.id,
        sales_contact_id=sales.id
    )
    db_session.add(contract)
    db_session.commit()

    assert contract.id is not None
    assert float(contract.total_amount) == 1000.50
    assert contract.client.full_name == "Contract Client"


def test_create_event(db_session, test_setup):
    """Test full event chain link: Client -> Contract -> Event."""
    sales, support = test_setup
    client = Client(
        full_name="Event Client",
        email=f"e_{uuid.uuid4().hex[:6]}@event.com",
        phone="111",
        company_name="E-Events",
        sales_contact_id=sales.id
    )
    db_session.add(client)
    db_session.commit()

    contract = Contract(
        total_amount=5000,
        remaining_amount=0,
        is_signed=True,
        client_id=client.id,
        sales_contact_id=sales.id
    )
    db_session.add(contract)
    db_session.commit()

    start_date = datetime.now() + timedelta(days=7)
    event = Event(
        name="Epic Party",
        event_date_start=start_date,
        event_date_end=start_date + timedelta(hours=5),
        location="Paris",
        attendees=100,
        notes="Important event",
        client_id=client.id,
        contract_id=contract.id,
        support_contact_id=support.id
    )
    db_session.add(event)
    db_session.commit()

    assert event.id is not None
    assert event.contract.is_signed is True
    assert event.support_contact.full_name == "Support Guy"


def test_client_email_uniqueness(db_session, test_setup):
    """Verify that two clients cannot share the same email."""
    sales, _ = test_setup
    email = "duplicate@test.com"
    c1 = Client(
        full_name="C1", email=email, phone="1",
        company_name="A", sales_contact_id=sales.id
    )
    db_session.add(c1)
    db_session.commit()

    c2 = Client(
        full_name="C2", email=email, phone="2",
        company_name="B", sales_contact_id=sales.id
    )
    db_session.add(c2)
    with pytest.raises(IntegrityError):
        db_session.commit()
    db_session.rollback()

===============================================================================
FILE: ./tests/test_models_staff.py
------------------------------------------------------------------------------
META: 2732 bytes | modified: 2026-02-19 17:08:14
===============================================================================

# tests/test_models_staff.py
"""
Unit tests for Staff models (Department and Employee).

Tests included:
- test_create_department: Validate department creation with unique names.
- test_department_unique_name: Ensure department names are unique.
- test_create_employee: Validate employee creation and relations.
- test_employee_unique_constraints: Validate email and employee_number uniqueness.
"""

import uuid
import pytest
from sqlalchemy.exc import IntegrityError
from app.models.department import Department
from app.models.employee import Employee


def test_create_department(db_session):
    """Test creating a department and its representation."""
    unique_name = f"DEPT_{uuid.uuid4().hex[:8]}"
    dept = Department(name=unique_name)
    db_session.add(dept)
    db_session.commit()

    assert dept.id is not None
    assert str(dept) == f"<Department(name={unique_name})>"


def test_department_unique_name(db_session):
    """Ensure that two departments cannot have the same name."""
    unique_name = f"UNIQUE_{uuid.uuid4().hex[:8]}"
    dept1 = Department(name=unique_name)
    db_session.add(dept1)
    db_session.commit()

    dept2 = Department(name=unique_name)
    db_session.add(dept2)
    with pytest.raises(IntegrityError):
        db_session.commit()
    db_session.rollback()


def test_create_employee(db_session):
    """Test creating an employee associated with a department."""
    unique_dept = f"SUPPORT_{uuid.uuid4().hex[:8]}"
    dept = Department(name=unique_dept)
    db_session.add(dept)
    db_session.commit()

    unique_email = f"user_{uuid.uuid4().hex[:8]}@test.com"
    emp = Employee(
        full_name="John Doe",
        email=unique_email,
        password="hashed_password",
        employee_number=f"EMP_{uuid.uuid4().hex[:8]}",
        department_id=dept.id
    )
    db_session.add(emp)
    db_session.commit()

    assert emp.id is not None
    assert emp.department.name == unique_dept


def test_employee_unique_constraints(db_session):
    """Test uniqueness of email and employee_number."""
    dept = Department(name=f"ADMIN_{uuid.uuid4().hex[:8]}")
    db_session.add(dept)
    db_session.commit()

    email = f"same_{uuid.uuid4().hex[:8]}@test.com"
    emp1 = Employee(
        full_name="User 1",
        email=email,
        password="pwd",
        employee_number="ID_STATIC",
        department_id=dept.id
    )
    db_session.add(emp1)
    db_session.commit()

    # Duplicate email
    emp2 = Employee(
        full_name="User 2",
        email=email,
        password="pwd",
        employee_number="ID_NEW",
        department_id=dept.id
    )
    db_session.add(emp2)
    with pytest.raises(IntegrityError):
        db_session.commit()
    db_session.rollback()


===============================================================================
FILE: ./tests/test_permissions.py
------------------------------------------------------------------------------
META: 1670 bytes | modified: 2026-02-19 17:29:15
===============================================================================

# tests/test_permissions.py
"""
Unit tests for the authorization system.

Tests included:
- test_management_permissions: Validate all actions for MANAGEMENT.
- test_sales_permissions: Validate allowed and restricted actions for SALES.
- test_support_permissions: Validate allowed and restricted actions for SUPPORT.
- test_unknown_department_permissions: Ensure unknown departments have no access.
"""

from app.utils.permissions import has_permission


def test_management_permissions():
    """Verify that MANAGEMENT has all its assigned permissions."""
    dept = "MANAGEMENT"
    assert has_permission("create_employee", dept) is True
    assert has_permission("delete_employee", dept) is True
    assert has_permission("update_contract", dept) is True


def test_sales_permissions():
    """Verify SALES permissions and restrictions."""
    dept = "SALES"
    # Allowed
    assert has_permission("create_client", dept) is True
    assert has_permission("create_event", dept) is True
    # Restricted
    assert has_permission("create_employee", dept) is False
    assert has_permission("delete_employee", dept) is False


def test_support_permissions():
    """Verify SUPPORT permissions and restrictions."""
    dept = "SUPPORT"
    # Allowed
    assert has_permission("read_event", dept) is True
    assert has_permission("update_event", dept) is True
    # Restricted
    assert has_permission("create_client", dept) is False
    assert has_permission("create_contract", dept) is False


def test_unknown_department_permissions():
    """Ensure that a non-existent department has no permissions."""
    assert has_permission("read_client", "GHOST_DEPT") is False

===============================================================================
FILE: ./tests/test_repositories.py
------------------------------------------------------------------------------
META: 2650 bytes | modified: 2026-02-19 17:23:12
===============================================================================

# tests/test_repositories.py
"""
Unit tests for Repositories.

Tests included:
- test_employee_repo_get_by_email: Verify lookup by email.
- test_employee_repo_add: Verify adding an employee via repo.
- test_repo_rollback_on_error: Ensure BaseRepository rolls back on failure.
"""

import uuid
import pytest
from sqlalchemy.exc import IntegrityError
from app.models.employee import Employee
from app.models.department import Department
from app.repositories.employee_repository import EmployeeRepository


@pytest.fixture
def employee_repo(db_session):
    """Fixture to provide the employee repository."""
    return EmployeeRepository(db_session)


def test_employee_repo_add(employee_repo, db_session):
    """Test adding an employee using the repository method."""
    # Setup department
    dept = Department(name=f"TECH_{uuid.uuid4().hex[:6]}")
    db_session.add(dept)
    db_session.commit()

    emp = Employee(
        full_name="Test Repo",
        email=f"repo_{uuid.uuid4().hex[:6]}@test.com",
        password="hash",
        employee_number=f"ID_{uuid.uuid4().hex[:6]}",
        department_id=dept.id
    )

    # Action via le repository
    employee_repo.add(emp)

    # Verification
    fetched = employee_repo.get_by_id(emp.id)
    assert fetched is not None
    assert fetched.full_name == "Test Repo"


def test_employee_repo_get_by_email(employee_repo, db_session):
    """Test finding an employee by email via the repository."""
    dept = Department(name=f"HR_{uuid.uuid4().hex[:6]}")
    db_session.add(dept)
    db_session.commit()

    email = f"findme_{uuid.uuid4().hex[:6]}@test.com"
    emp = Employee(
        full_name="Search Target",
        email=email,
        password="hash",
        employee_number=f"SN_{uuid.uuid4().hex[:6]}",
        department_id=dept.id
    )
    employee_repo.add(emp)

    found = employee_repo.get_by_email(email)
    assert found is not None
    assert found.id == emp.id


def test_repo_rollback_on_error(employee_repo, db_session):
    """Verify that BaseRepository handles IntegrityError and rolls back."""
    dept = Department(name=f"VOID_{uuid.uuid4().hex[:6]}")
    db_session.add(dept)
    db_session.commit()

    email = "duplicate@test.com"
    emp1 = Employee(
        full_name="User 1", email=email, password="h",
        employee_number="N1", department_id=dept.id
    )
    employee_repo.add(emp1)

    emp2 = Employee(
        full_name="User 2", email=email, password="h",
        employee_number="N2", department_id=dept.id
    )

    # Le BaseRepository doit lever l'erreur et faire le rollback
    with pytest.raises(IntegrityError):
        employee_repo.add(emp2)

===============================================================================
FILE: ./tests/test_repository_and_decorators_coverage.py
------------------------------------------------------------------------------
META: 5235 bytes | modified: 2026-02-22 04:30:31
===============================================================================

"""
tests/test_repository_and_decorators_coverage.py

Covers:
- BaseRepository rollback paths (add/update/delete)
- require_auth decorator user_data resolution paths

Non-regression: require_auth is used WITHOUT parameters (it's not a factory).
Non-regression: user_data is provided via kwargs / controller session / token,
not via positional args (current implementation doesn't support that).
"""

import pytest
from sqlalchemy.exc import SQLAlchemyError

from app.models.client import Client
from app.repositories.base_repository import BaseRepository
from app.utils.decorators import require_auth


class _DummyAuthCtrl:
    """Minimal auth controller stub used by require_auth fallback logic."""

    def __init__(self):
        self.current_user_data = None


class _DummyController:
    """Controller-like object holding auth_controller for @require_auth."""

    def __init__(self, auth_ctrl):
        self.auth_controller = auth_ctrl

    @require_auth
    def action(self, *args, user_data=None, **kwargs):
        """Return resolved user_data so tests can assert injection works."""
        return user_data

    @require_auth
    def action_with_arg(self, value, *args, user_data=None, **kwargs):
        """Ensures decorator doesn't break positional parameters."""
        return {"value": value, "user_data": user_data}


def _make_valid_client(index: int = 1) -> Client:
    """
    Create a Client respecting DB constraints.
    Adjust here if your model has additional NOT NULL constraints.
    """
    return Client(
        full_name=f"Client {index}",
        email=f"client{index}@example.com",
        phone=f"06000000{index}",
        company_name=f"Company {index}",
    )


def test_base_repository_update_rollback_on_sqlalchemy_error(db_session):
    """If commit fails during update, the session should rollback and raise."""
    repo = BaseRepository(db_session, Client)
    client = repo.add(_make_valid_client(1))

    rolled = {"called": False}

    def _fake_rollback():
        rolled["called"] = True

    def _fake_commit():
        raise SQLAlchemyError("boom")

    db_session.rollback = _fake_rollback
    db_session.commit = _fake_commit

    with pytest.raises(SQLAlchemyError):
        repo.update(client.id, {"phone": "0699999999"})

    assert rolled["called"] is True


def test_base_repository_delete_rollback_on_sqlalchemy_error(db_session):
    """If commit fails during delete, the session should rollback and raise."""
    repo = BaseRepository(db_session, Client)
    client = repo.add(_make_valid_client(2))

    rolled = {"called": False}

    def _fake_rollback():
        rolled["called"] = True

    def _fake_commit():
        raise SQLAlchemyError("boom")

    db_session.rollback = _fake_rollback
    db_session.commit = _fake_commit

    with pytest.raises(SQLAlchemyError):
        repo.delete(client)

    assert rolled["called"] is True


def test_require_auth_accepts_user_data_from_kwargs():
    """user_data provided explicitly via kwargs is passed through unchanged."""
    auth = _DummyAuthCtrl()
    ctrl = _DummyController(auth)

    user = {"id": 1, "department": "SALES"}
    out = ctrl.action(user_data=user)
    assert out == user


def test_require_auth_uses_controller_current_user_data():
    """If no explicit user_data, decorator falls back to auth_controller.current_user_data."""
    auth = _DummyAuthCtrl()
    auth.current_user_data = {"id": 3, "department": "MANAGEMENT"}
    ctrl = _DummyController(auth)

    out = ctrl.action()
    assert out == {"id": 3, "department": "MANAGEMENT"}


def test_require_auth_uses_token_payload(monkeypatch):
    """If no user_data anywhere, decorator uses token -> decode_token payload."""
    from app.utils import decorators as dec_mod

    auth = _DummyAuthCtrl()
    ctrl = _DummyController(auth)

    monkeypatch.setattr(dec_mod, "get_token", lambda: "dummy.jwt.token")
    monkeypatch.setattr(dec_mod, "decode_token", lambda _t: {"id": 7, "department": "SALES"})

    out = ctrl.action()
    assert out == {"id": 7, "department": "SALES"}


def test_require_auth_denies_when_no_user_and_no_token(monkeypatch):
    """If no user_data and no token, decorator returns None."""
    from app.utils import decorators as dec_mod

    auth = _DummyAuthCtrl()
    ctrl = _DummyController(auth)

    monkeypatch.setattr(dec_mod, "get_token", lambda: None)

    out = ctrl.action()
    assert out is None


def test_require_auth_denies_when_token_invalid(monkeypatch):
    """If token exists but decode_token returns None, decorator returns None."""
    from app.utils import decorators as dec_mod

    auth = _DummyAuthCtrl()
    ctrl = _DummyController(auth)

    monkeypatch.setattr(dec_mod, "get_token", lambda: "dummy.jwt.token")
    monkeypatch.setattr(dec_mod, "decode_token", lambda _t: None)

    out = ctrl.action()
    assert out is None


def test_require_auth_does_not_break_positional_args():
    """Decorator must preserve normal positional args and inject user_data."""
    auth = _DummyAuthCtrl()
    ctrl = _DummyController(auth)

    user = {"id": 10, "department": "SALES"}
    out = ctrl.action_with_arg("hello", user_data=user)

    assert out["value"] == "hello"
    assert out["user_data"] == user

===============================================================================
FILE: ./tests/test_robustness_edge_cases.py
------------------------------------------------------------------------------
META: 8855 bytes | modified: 2026-02-21 19:14:18
===============================================================================

"""
Integration tests for edge cases, permission denials, and coverage optimization.

List of tests:
- test_auth_controller_full_flow: Covers logout and failed login logic.
- test_auth_login_success: Covers successful login and session management.
- test_client_controller_unauthorized: Covers permission denial branches.
- test_contract_controller_ownership: Covers ownership and not found logic.
- test_event_controller_complex_rules: Covers unsigned contracts and support.
- test_controllers_list_methods: Covers list_all methods for all controllers.
- test_employee_management_denials: Covers admin-only creation/update logic.
- test_repository_integrity_failure: Covers DB constraints and rollbacks.
- test_repository_delete_logic: Covers the delete method in BaseRepository.
- test_repository_specialized_filters: Covers specific repository lookups.
- test_models_string_representation: Covers __repr__ methods for all models.
"""

from datetime import datetime
import pytest
from sqlalchemy.exc import IntegrityError
from app.controllers.auth_controller import AuthController
from app.controllers.client_controller import ClientController
from app.controllers.contract_controller import ContractController
from app.controllers.event_controller import EventController
from app.controllers.employee_controller import EmployeeController
from app.repositories.employee_repository import EmployeeRepository
from app.repositories.client_repository import ClientRepository
from app.repositories.contract_repository import ContractRepository
from app.repositories.event_repository import EventRepository
from app.models.employee import Employee
from app.models.client import Client
from app.models.contract import Contract
from app.models.event import Event
from app.models.department import Department
from app.utils.auth import hash_password


@pytest.fixture
def auth_ctrl(db_session):
    """Fixture for AuthController."""
    return AuthController(EmployeeRepository(db_session))


def test_auth_controller_full_flow(auth_ctrl):
    """Covers logout and failed login logic."""
    auth_ctrl.logout()
    assert auth_ctrl.current_user_data is None
    assert auth_ctrl.login("ghost@missing.com", "password") is None
    assert auth_ctrl.check_user_permission("read") is False


def test_auth_login_success(db_session, auth_ctrl):
    """Covers successful login and user data structure."""
    dept = Department(name="AUTH_DEPT")
    db_session.add(dept)
    db_session.flush()

    pwd = hash_password("secret123")
    emp = Employee(
        full_name="Auth Success",
        email="success@test.com",
        password=pwd,
        employee_number="EMP_OK",
        department_id=dept.id
    )
    db_session.add(emp)
    db_session.commit()

    user = auth_ctrl.login("success@test.com", "secret123")
    assert user is not None
    # AuthController.login does not return 'email' in user_data dict
    assert user["full_name"] == "Auth Success"
    assert user["department"] == "AUTH_DEPT"


def test_client_controller_unauthorized(db_session, auth_ctrl):
    """Covers permission denial branches using manual session injection."""
    client_repo = ClientRepository(db_session)
    ctrl = ClientController(client_repo, auth_ctrl)

    # Support cannot create clients
    auth_ctrl.current_user_data = {"id": 1, "department": "SUPPORT"}
    assert ctrl.create_client({"full_name": "Fail", "phone": "123"}) is None

    # Sales cannot update unknown clients or others' clients
    auth_ctrl.current_user_data = {"id": 2, "department": "SALES"}
    assert ctrl.update_client(9999, {"full_name": "New"}) is None


def test_contract_controller_ownership(db_session, auth_ctrl):
    """Covers ownership and not found logic."""
    contract_repo = ContractRepository(db_session)
    ctrl = ContractController(contract_repo, auth_ctrl)

    sales_dept = Department(name="SALES")
    db_session.add(sales_dept)
    db_session.flush()

    emp5 = Employee(
        id=5, full_name="S1", email="s5@t.com", password="p",
        employee_number="E5", department_id=sales_dept.id
    )
    emp10 = Employee(
        id=10, full_name="S2", email="s10@t.com", password="p",
        employee_number="E10", department_id=sales_dept.id
    )
    db_session.add_all([emp5, emp10])
    db_session.flush()

    cl = Client(full_name="X", email="x@t.com", phone="1",
                company_name="X", sales_contact_id=5)
    db_session.add(cl)
    db_session.flush()

    c = Contract(id=102, sales_contact_id=10, client_id=cl.id,
                 total_amount=1000, remaining_amount=1000)
    db_session.add(c)
    db_session.flush()

    # User 5 tries to update user 10's contract
    auth_ctrl.current_user_data = {"id": 5, "department": "SALES"}
    assert ctrl.update_contract(102, {"total_amount": 2000}) is None


def test_event_controller_complex_rules(db_session, auth_ctrl):
    """Covers unsigned contracts and support assigned logic."""
    event_repo = EventRepository(db_session)
    ctrl = EventController(event_repo, auth_ctrl)

    s_dept = Department(name="SALES")
    sup_dept = Department(name="SUPPORT")
    db_session.add_all([s_dept, sup_dept])
    db_session.flush()

    s_emp = Employee(id=20, full_name="S1", email="s20@t.com", password="p",
                     employee_number="E20", department_id=s_dept.id)
    sup_emp = Employee(id=21, full_name="Sup1", email="s21@t.com", password="p",
                       employee_number="E21", department_id=sup_dept.id)
    db_session.add_all([s_emp, sup_emp])
    db_session.flush()

    cl = Client(full_name="Y", email="y@t.com", phone="2",
                company_name="Y", sales_contact_id=20)
    db_session.add(cl)
    db_session.flush()

    c = Contract(id=202, sales_contact_id=20, is_signed=False,
                 total_amount=0, remaining_amount=0, client_id=cl.id)
    db_session.add(c)
    db_session.flush()

    # Cannot create event for unsigned contract
    auth_ctrl.current_user_data = {"id": 20, "department": "SALES"}
    assert ctrl.create_event({"name": "X"}, c) is None

    ev = Event(id=302, name="Ev", location="P", attendees=5, notes="N",
               client_id=cl.id, contract_id=c.id, support_contact_id=sup_emp.id,
               event_date_start=datetime.now(), event_date_end=datetime.now())
    db_session.add(ev)
    db_session.flush()

    # Different support user cannot update
    auth_ctrl.current_user_data = {"id": 99, "department": "SUPPORT"}
    assert ctrl.update_event(302, {"notes": "hack"}) is None


def test_controllers_list_methods(db_session, auth_ctrl):
    """Covers list_all methods."""
    auth_ctrl.current_user_data = {"id": 1, "department": "MANAGEMENT"}

    cl_ctrl = ClientController(ClientRepository(db_session), auth_ctrl)
    assert isinstance(cl_ctrl.list_all_clients(), list)

    co_ctrl = ContractController(ContractRepository(db_session), auth_ctrl)
    assert co_ctrl.list_all_contracts() is not None

    ev_ctrl = EventController(EventRepository(db_session), auth_ctrl)
    assert ev_ctrl.list_all_events() is not None


def test_employee_management_denials(db_session, auth_ctrl):
    """Covers admin-only creation logic."""
    emp_repo = EmployeeRepository(db_session)
    ctrl = EmployeeController(emp_repo, auth_ctrl)
    auth_ctrl.current_user_data = {"department": "SALES"}
    assert ctrl.create_employee({"full_name": "Ghost"}) is None


def test_repository_integrity_failure(db_session):
    """Covers BaseRepository IntegrityError handling."""
    repo = ClientRepository(db_session)
    c1 = Client(full_name="A", email="dup@t.com", phone="1", company_name="C")
    db_session.add(c1)
    db_session.commit()

    c2 = Client(full_name="B", email="dup@t.com", phone="2", company_name="C")
    with pytest.raises(IntegrityError):
        repo.add(c2)


def test_repository_delete_logic(db_session):
    """Covers the delete method in BaseRepository."""
    repo = ClientRepository(db_session)
    cl = Client(full_name="Del", email="del@t.com", phone="0", company_name="D")
    db_session.add(cl)
    db_session.flush()
    repo.delete(cl)
    assert repo.get_by_id(cl.id) is None


def test_repository_specialized_filters(db_session):
    """Covers specific filter methods in repositories."""
    e_repo = EmployeeRepository(db_session)
    assert e_repo.get_by_email("none@t.com") is None

    c_repo = ContractRepository(db_session)
    assert isinstance(c_repo.get_unsigned_contracts(), list)

    ev_repo = EventRepository(db_session)
    assert isinstance(ev_repo.get_events_without_support(), list)


def test_models_string_representation():
    """Covers __repr__ for all models."""
    assert "Client" in repr(Client(full_name="Test"))
    assert "Contract" in repr(Contract(id=1))
    assert "Event" in repr(Event(name="Party"))
    assert "Employee" in repr(Employee(full_name="T", email="t@t.com"))

END SECTION 2

================================================================================
END OF REVIEW BUNDLE
================================================================================
