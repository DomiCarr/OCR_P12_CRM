Generated 2026-02-19 14:06:38

===============================================================================
    ./.pytest_cache/README.md
===============================================================================
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.


===============================================================================
    ./README.md
===============================================================================
# OCR_P12_CRM


===============================================================================
    ./app/controllers/auth_controller.py
===============================================================================
# app/controllers/auth_controller.py
"""
This module handles the authentication logic, integrating JWT generation
and local storage to provide persistent user sessions.
"""

from typing import Optional
import sentry_sdk
from app.repositories.employee_repository import EmployeeRepository
from app.utils.auth import verify_password
from app.utils.permissions import has_permission
from app.utils.jwt_handler import create_token, decode_token
from app.utils.token_storage import save_token, get_token, delete_token


class AuthController:
    """
    Controller managing login, logout, and persistent session validation.
    """

    def __init__(self, employee_repository: EmployeeRepository):
        self.repository = employee_repository
        self.current_user_data: Optional[dict] = None

    def login(self, email: str, password: str) -> Optional[dict]:
        """
        Authenticate user and save a JWT locally if successful.
        """
        employee = self.repository.get_by_email(email)

        if employee and verify_password(employee.password, password):
            # Generate and save token locally
            token = create_token(employee.id, employee.department.name)
            save_token(token)

            # Return user data for main.py session management
            user_data = {
                "id": employee.id,
                "full_name": employee.full_name,
                "department": employee.department.name
            }

            # Attach user identity to Sentry scope for error tracking
            sentry_sdk.set_user({
                "id": str(employee.id),
                "username": employee.full_name,
                "department": employee.department.name
            })

            self.current_user_data = user_data
            return user_data

        return None

    def logout(self) -> None:
        """
        Clear the session by deleting the local token.
        """
        delete_token()
        # Clear Sentry user context to avoid cross-user error reporting
        sentry_sdk.set_user(None)
        self.current_user_data = None

    def get_logged_in_user(self) -> Optional[dict]:
        """
        Validate the local token and return user data if still valid.
        """
        token = get_token()
        if not token:
            return None

        payload = decode_token(token)
        if payload:
            # Restore Sentry user identity for persistent sessions
            sentry_sdk.set_user({
                "id": str(payload.get("id")),
                "department": payload.get("department")
            })
            self.current_user_data = payload
            return payload

        # Token expired or invalid
        delete_token()
        return None

    def check_user_permission(self, action: str) -> bool:
        """
        Check if the currently logged-in user has permission for an action.
        """
        if not self.current_user_data:
            return False

        dept = self.current_user_data.get("department")
        return has_permission(action, dept)

===============================================================================
    ./app/controllers/client_controller.py
===============================================================================
# app/controllers/client_controller.py
"""
Controller handling business logic for Client management.
Ensures authentication and permission checks before data access.
"""

from datetime import datetime
from app.repositories.client_repository import ClientRepository
from app.utils.decorators import require_auth


class ClientController:
    """Manages client-related operations."""

    def __init__(self, repository: ClientRepository, auth_controller):
        self.repository = repository
        self.auth_controller = auth_controller

    @require_auth
    def list_all_clients(self, user_data: dict):
        """Fetch all clients if the user has the 'read_client' permission."""
        self.auth_controller.current_user_data = user_data
        permission = "read_client"
        if self.auth_controller.check_user_permission(permission):
            return self.repository.get_all_clients()
        return []

    @require_auth
    def create_client(self, user_data: dict, client_data: dict):
        """Create a new client and associate with the current sales person."""
        self.auth_controller.current_user_data = user_data
        if self.auth_controller.check_user_permission("create_client"):
            # Set sales_contact_id from the current logged-in user
            client_data["sales_contact_id"] = user_data["id"]

            # Set last_contact to now if not provided
            if not client_data.get("last_contact"):
                client_data["last_contact"] = datetime.now()

            new_client = self.repository.add_client(client_data)
            print(f"Client '{new_client.full_name}' created successfully.")
            return new_client
        print("Access denied: You do not have permission to create a client.")
        return None

===============================================================================
    ./app/controllers/contract_controller.py
===============================================================================
# app/controllers/contract_controller.py
"""
Controller handling business logic for Contract management.
"""

from app.repositories.contract_repository import ContractRepository
from app.utils.decorators import require_auth


class ContractController:
    """Manages contract-related operations."""

    def __init__(self, repository: ContractRepository, auth_controller):
        self.repository = repository
        self.auth_controller = auth_controller

    @require_auth
    def list_all_contracts(self, user_data: dict):
        """
        Fetch all contracts if allowed.
        """
        self.auth_controller.current_user_data = user_data
        if self.auth_controller.check_user_permission("read_contract"):
            return self.repository.get_all_contracts()
        return None

===============================================================================
    ./app/controllers/employee_controller.py
===============================================================================
# app/controllers/employee_controller.py
"""
Controller handling business logic for Employee management.
"""

from app.models.employee import Employee
from app.repositories.employee_repository import EmployeeRepository
from app.utils.decorators import require_auth
from app.utils.auth import hash_password


class EmployeeController:
    """Manages employee-related operations."""

    def __init__(self, repository: EmployeeRepository, auth_controller):
        self.repository = repository
        self.auth_controller = auth_controller

    @require_auth
    def list_all_employees(self, user_data: dict):
        """
        Fetch all employees if the user has the 'read_employee' permission.
        """
        self.auth_controller.current_user_data = user_data

        if self.auth_controller.check_user_permission("read_employee"):
            return self.repository.get_all()

        return []

    @require_auth
    def create_employee(self, user_data: dict, employee_data: dict):
        """
        Create a new employee after permission check and password hashing.
        """
        self.auth_controller.current_user_data = user_data

        if not self.auth_controller.check_user_permission("create_employee"):
            return None

        # Hash the password before storage
        employee_data["password"] = hash_password(employee_data["password"])

        # Create the instance
        new_employee = Employee(**employee_data)

        # Pass the instance (not the dict) to the repository
        created_employee = self.repository.add(new_employee)
        return created_employee

    @require_auth
    def update_employee(self, user_data: dict, emp_id: int, update_data: dict):
        """
        Update an existing employee's data.
        """
        self.auth_controller.current_user_data = user_data

        if not self.auth_controller.check_user_permission("update_employee"):
            return None

        if "password" in update_data:
            update_data["password"] = hash_password(update_data["password"])

        updated_emp = self.repository.update(emp_id, update_data)
        return updated_emp

===============================================================================
    ./app/controllers/event_controller.py
===============================================================================
# app/controllers/event_controller.py
"""
Controller handling business logic for Event management.
"""

from app.repositories.event_repository import EventRepository
from app.utils.decorators import require_auth


class EventController:
    """Manages event-related operations."""

    def __init__(self, repository: EventRepository, auth_controller):
        self.repository = repository
        self.auth_controller = auth_controller

    @require_auth
    def list_all_events(self, user_data: dict):
        """
        Fetch all events if allowed.
        """
        self.auth_controller.current_user_data = user_data
        if self.auth_controller.check_user_permission("read_event"):
            return self.repository.get_all_events()
        return None

===============================================================================
    ./app/models/__init__.py
===============================================================================
# app/models/__init__.py
"""
This module centralizes all SQLAlchemy models to facilitate imports
and ensure they are registered with the Base metadata for migrations.
"""

from app.models.base import Base
from app.models.department import Department
from app.models.employee import Employee
from app.models.client import Client
from app.models.contract import Contract
from app.models.event import Event

__all__ = [
    "Base",
    "Department",
    "Employee",
    "Client",
    "Contract",
    "Event"
]

===============================================================================
    ./app/models/base.py
===============================================================================
# app/models/base.py
"""
This module serves as the foundation for the ORM layer.
- Provides a centralized DeclarativeBase for model registration.
- Defines custom type aliases (Annotated) to standardize SQL constraints
  (String lengths, Primary Keys, and Timestamps) across the entire schema.
- Uses server-side functions for automated audit trails (created_at, updated_at).
"""
import datetime
from typing import Annotated
from sqlalchemy import String, Text, func
from sqlalchemy.orm import DeclarativeBase, mapped_column


# Type aliases to ensure consistency across all models
# Primary keys with auto-increment
pk_id = Annotated[int, mapped_column(primary_key=True, autoincrement=True)]

# Standard string lengths for database columns
str_20 = Annotated[str, mapped_column(String(20))]
str_50 = Annotated[str, mapped_column(String(50))]
str_100 = Annotated[str, mapped_column(String(100))]
str_255 = Annotated[str, mapped_column(String(255))]

# Long text for descriptions or notes
text_type = Annotated[str, mapped_column(Text)]

# Automatically managed timestamps
timestamp_now = Annotated[
    datetime.datetime,
    mapped_column(server_default=func.now())
]
timestamp_update = Annotated[
    datetime.datetime,
    mapped_column(server_default=func.now(), onupdate=func.now())
]


class Base(DeclarativeBase):
    """
    Base class for declarative models.
    Maintains a registry of all mapped classes.
    """
    pass

===============================================================================
    ./app/models/client.py
===============================================================================
# app/models/client.py
"""
This module defines the Client model, which stores customer information,
contact details, and handles relationships with sales employees,
contracts, and events.
"""

from typing import TYPE_CHECKING
from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import (
    Base,
    pk_id,
    str_50,
    str_100,
    str_20,
    timestamp_now,
    timestamp_update
)

if TYPE_CHECKING:
    from app.models.employee import Employee
    from app.models.event import Event
    from app.models.contract import Contract


class Client(Base):
    """
    Represents a customer in the CRM system.
    """

    __tablename__ = "client"

    id: Mapped[pk_id]
    full_name: Mapped[str_50]
    email: Mapped[str_100] = mapped_column(unique=True)
    phone: Mapped[str_20]
    company_name: Mapped[str_50]

    # New field for last business contact
    last_contact: Mapped[timestamp_now]

    # Audit timestamps
    creation_date: Mapped[timestamp_now]
    last_update: Mapped[timestamp_update]

    # Foreign Key to the Sales Contact (Employee)
    sales_contact_id: Mapped[int] = mapped_column(
        ForeignKey("employee.id")
    )

    # Relationships
    sales_contact: Mapped["Employee"] = relationship(
        back_populates="managed_clients"
    )
    contracts: Mapped[list["Contract"]] = relationship(
        back_populates="client"
    )
    events: Mapped[list["Event"]] = relationship(
        back_populates="client"
    )

    def __repr__(self) -> str:
        return (
            f"<Client(name={self.full_name}, "
            f"company={self.company_name})>"
        )

===============================================================================
    ./app/models/contract.py
===============================================================================
# app/models/contract.py
"""
This module defines the Contract model, which stores financial agreements
with clients, including amounts, payment status, and audit timestamps.
"""

from typing import TYPE_CHECKING
from sqlalchemy import ForeignKey, Boolean, Numeric
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import (
    Base,
    pk_id,
    timestamp_now,
    timestamp_update
)

if TYPE_CHECKING:
    from app.models.client import Client
    from app.models.event import Event
    from app.models.employee import Employee


class Contract(Base):
    """
    Represents a financial agreement with a client.
    """

    __tablename__ = "contract"

    id: Mapped[pk_id]
    total_amount: Mapped[float] = mapped_column(Numeric(10, 2))
    remaining_amount: Mapped[float] = mapped_column(Numeric(10, 2))
    is_signed: Mapped[bool] = mapped_column(Boolean, default=False)

    # Audit timestamps
    creation_date: Mapped[timestamp_now]
    last_update: Mapped[timestamp_update]

    # Foreign Keys
    client_id: Mapped[int] = mapped_column(ForeignKey("client.id"))
    sales_contact_id: Mapped[int] = mapped_column(ForeignKey("employee.id"))

    # Relationships
    client: Mapped["Client"] = relationship(back_populates="contracts")
    sales_contact: Mapped["Employee"] = relationship(
        back_populates="managed_contracts"
    )
    event: Mapped["Event"] = relationship(back_populates="contract")

    def __repr__(self) -> str:
        return (
            f"<Contract(id={self.id}, "
            f"remaining={self.remaining_amount}, "
            f"signed={self.is_signed})>"
        )

===============================================================================
    ./app/models/department.py
===============================================================================
# app/models/department.py
"""
This module defines the Department model, which represents the different
business units within the company and manages their relationship with employees.
"""

from typing import TYPE_CHECKING
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import Base, pk_id, str_50

if TYPE_CHECKING:
    from app.models.employee import Employee


class Department(Base):
    """
    Represents a business unit (MANAGEMENT, SALES, or SUPPORT).
    """

    __tablename__ = "department"

    id: Mapped[pk_id]
    name: Mapped[str_50] = mapped_column(unique=True)

    # Relationships
    employees: Mapped[list["Employee"]] = relationship(
        back_populates="department"
    )

    def __repr__(self) -> str:
        return f"<Department(name={self.name})>"

===============================================================================
    ./app/models/employee.py
===============================================================================
# app/models/employee.py
"""
This module defines the Employee model, which stores staff member information,
credentials, and their association with departments and managed entities
such as clients and events.
"""

from typing import TYPE_CHECKING
from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import Base, pk_id, str_50, str_100, str_255, str_20

if TYPE_CHECKING:
    from app.models.department import Department
    from app.models.client import Client
    from app.models.event import Event
    from app.models.contract import Contract


class Employee(Base):
    """
    Represents a staff member of Epic Events.
    """

    __tablename__ = "employee"

    id: Mapped[pk_id]
    full_name: Mapped[str_50]
    email: Mapped[str_100] = mapped_column(unique=True)
    password: Mapped[str_255]
    employee_number: Mapped[str_20] = mapped_column(unique=True)

    # Foreign Key to Department
    department_id: Mapped[int] = mapped_column(ForeignKey("department.id"))

    # Relationships
    department: Mapped["Department"] = relationship(back_populates="employees")

    # Managed entities (Sales/Support roles)
    managed_clients: Mapped[list["Client"]] = relationship(
        back_populates="sales_contact"
    )
    managed_contracts: Mapped[list["Contract"]] = relationship(
        back_populates="sales_contact"
    )
    assigned_events: Mapped[list["Event"]] = relationship(
        back_populates="support_contact"
    )

    def __repr__(self) -> str:
        return (
            f"<Employee(name={self.full_name}, "
            f"department_id={self.department_id})>"
        )

===============================================================================
    ./app/models/event.py
===============================================================================
# app/models/event.py
"""
This module defines the Event model, representing a scheduled event
linked to a client, a contract, and potentially a support employee.
"""

from typing import TYPE_CHECKING, Optional
from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import (
    Base,
    pk_id,
    str_50,
    text_type,
    timestamp_now,
    timestamp_update
)

if TYPE_CHECKING:
    from app.models.client import Client
    from app.models.employee import Employee
    from app.models.contract import Contract


class Event(Base):
    """
    Represents a scheduled event for a specific client and contract.
    """

    __tablename__ = "event"

    id: Mapped[pk_id]
    name: Mapped[str_50]
    event_date_start: Mapped[timestamp_now]
    event_date_end: Mapped[timestamp_now]
    location: Mapped[str_50]
    attendees: Mapped[int]
    notes: Mapped[text_type]

    # Audit timestamps
    creation_date: Mapped[timestamp_now]
    last_update: Mapped[timestamp_update]

    # Foreign Keys
    client_id: Mapped[int] = mapped_column(ForeignKey("client.id"))
    contract_id: Mapped[int] = mapped_column(ForeignKey("contract.id"))
    support_contact_id: Mapped[Optional[int]] = mapped_column(
        ForeignKey("employee.id"), nullable=True
    )

    # Relationships
    client: Mapped["Client"] = relationship(back_populates="events")
    contract: Mapped["Contract"] = relationship(back_populates="event")
    support_contact: Mapped["Employee"] = relationship(
        back_populates="assigned_events"
    )

    def __repr__(self) -> str:
        return f"<Event(name={self.name}, start={self.event_date_start})>"

===============================================================================
    ./app/repositories/base_repository.py
===============================================================================
# app/repositories/base_repository.py
"""
This module defines the BaseRepository class using Generics.
It provides a standardized interface for common database operations (CRUD)
shared across all specific repositories.
"""

from typing import Generic, TypeVar, Type, Optional, List
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
import sentry_sdk
from app.models.base import Base

T = TypeVar("T", bound=Base)


class BaseRepository(Generic[T]):
    """
    Base class for data access logic.
    """

    def __init__(self, session: Session, model: Type[T]):
        self.session = session
        self.model = model

    def get_by_id(self, obj_id: int) -> Optional[T]:
        """Fetch a single record by its primary key."""
        return self.session.query(self.model).filter(
            self.model.id == obj_id
        ).first()

    def get_all(self) -> List[T]:
        """Fetch all records for this model."""
        return self.session.query(self.model).all()

    def add(self, obj: T) -> T:
        """Add a new object and commit the transaction."""
        try:
            self.session.add(obj)
            self.session.commit()
            self.session.refresh(obj)
            return obj
        except IntegrityError as e:
            # Capture database constraint violations (e.g., duplicate email)
            self.session.rollback()
            sentry_sdk.capture_exception(e)
            raise e
        except SQLAlchemyError as e:
            # Capture any other database-related errors
            self.session.rollback()
            sentry_sdk.capture_exception(e)
            raise e

    def update(self, obj_id: int, update_data: dict) -> Optional[T]:
        """Update a record and commit the transaction."""
        obj = self.get_by_id(obj_id)
        if obj:
            try:
                for key, value in update_data.items():
                    if hasattr(obj, key):
                        setattr(obj, key, value)
                self.session.commit()
                self.session.refresh(obj)
                return obj
            except SQLAlchemyError as e:
                self.session.rollback()
                sentry_sdk.capture_exception(e)
                raise e
        return None

    def delete(self, obj: T) -> None:
        """Remove an object and commit the transaction."""
        try:
            self.session.delete(obj)
            self.session.commit()
        except SQLAlchemyError as e:
            self.session.rollback()
            sentry_sdk.capture_exception(e)
            raise e

===============================================================================
    ./app/repositories/client_repository.py
===============================================================================
# app/repositories/client_repository.py
"""
Data access layer for Client-specific operations.
"""

from sqlalchemy.orm import Session
from app.models.client import Client
from app.repositories.base_repository import BaseRepository


class ClientRepository(BaseRepository[Client]):
    """
    Repository handling Client database queries.
    """

    def __init__(self, session: Session):
        super().__init__(session, Client)

    def get_all_clients(self):
        """
        Fetch all clients by calling the inherited get_all method.
        """
        return self.get_all()

    def get_by_email(self, email: str):
        """
        Fetch a client by its unique email.
        """
        return self.session.query(self.model).filter(
            self.model.email == email
        ).first()

===============================================================================
    ./app/repositories/contract_repository.py
===============================================================================
# app/repositories/contract_repository.py
"""
Data access layer for Contract-specific operations.
"""

from sqlalchemy.orm import Session
from app.models.contract import Contract
from app.repositories.base_repository import BaseRepository


class ContractRepository(BaseRepository[Contract]):
    """
    Repository handling Contract database queries.
    """

    def __init__(self, session: Session):
        super().__init__(session, Contract)

    def get_all_contracts(self):
        """
        Fetch all contracts using the base repository method.
        """
        return self.get_all()

===============================================================================
    ./app/repositories/employee_repository.py
===============================================================================
# app/repositories/employee_repository.py
"""
This module specializes the BaseRepository for the Employee model.
It provides specific lookup methods necessary for authentication
and staff management.
"""

from typing import Optional
from sqlalchemy.orm import Session
from app.models.employee import Employee
from app.repositories.base_repository import BaseRepository


class EmployeeRepository(BaseRepository[Employee]):
    """
    Data access layer for Employee-specific operations.
    """

    def __init__(self, session: Session):
        super().__init__(session, Employee)

    def get_all_employees(self):
        """
        Fetch all employees using the base repository method.
        """
        return self.get_all()

    def get_by_email(self, email: str) -> Optional[Employee]:
        """
        Fetch an employee by their unique email address.
        Used for authentication.
        """
        return self.session.query(self.model).filter(
            self.model.email == email
        ).first()

    def get_by_employee_number(self, emp_number: str) -> Optional[Employee]:
        """
        Fetch an employee by their unique employee number.
        """
        return self.session.query(self.model).filter(
            self.model.employee_number == emp_number
        ).first()

===============================================================================
    ./app/repositories/event_repository.py
===============================================================================
# app/repositories/event_repository.py
"""
Data access layer for Event-specific operations.
"""

from sqlalchemy.orm import Session
from app.models.event import Event
from app.repositories.base_repository import BaseRepository


class EventRepository(BaseRepository[Event]):
    """
    Repository handling Event database queries.
    """

    def __init__(self, session: Session):
        super().__init__(session, Event)

    def get_all_events(self):
        """
        Fetch all events using the base repository method.
        """
        return self.get_all()

===============================================================================
    ./app/utils/auth.py
===============================================================================
# app/utils/auth.py
"""
This module handles secure password management using the Argon2 hashing
algorithm. It provides utilities for hashing plain text passwords and
verifying them against stored hashes.
"""

from argon2 import PasswordHasher
from argon2.exceptions import VerifyMismatchError, InvalidHashError

# Initialize the hasher with default secure parameters
ph = PasswordHasher()


def hash_password(password: str) -> str:
    """
    Hash a password using Argon2.
    """
    return ph.hash(password)


def verify_password(hashed_password: str, plain_password: str) -> bool:
    """
    Verify a password against its Argon2 hash.
    """
    try:
        return ph.verify(hashed_password, plain_password)
    except (VerifyMismatchError, InvalidHashError):
        return False

===============================================================================
    ./app/utils/decorators.py
===============================================================================
# app/utils/decorators.py
"""
Authentication decorators for controller methods.
Ensures user_data is available via token or arguments.
"""

from functools import wraps
from typing import Callable, Any
import sentry_sdk
from app.utils.token_storage import get_token
from app.utils.jwt_handler import decode_token


def require_auth(func: Callable) -> Callable:
    """
    Decorator that ensures a user is authenticated before executing a method.
    Injects user_data into the function arguments.
    """
    @wraps(func)
    def wrapper(self, *args, **kwargs) -> Any:
        # Add a breadcrumb to track the authentication attempt in Sentry
        sentry_sdk.add_breadcrumb(
            category="auth",
            message=f"Checking authentication for {func.__name__}",
            level="info",
        )

        # 1. Check if user_data is already passed
        user_data = kwargs.get("user_data")

        # 2. If not, try to retrieve it from token storage
        if not user_data:
            token = get_token()
            if token:
                user_data = decode_token(token)

        if not user_data:
            sentry_sdk.add_breadcrumb(
                category="auth",
                message="Authentication failed: No user data found",
                level="warning",
            )
            return []

        # 3. Inject user_data for the controller logic
        kwargs["user_data"] = user_data
        return func(self, *args, **kwargs)

    return wrapper

===============================================================================
    ./app/utils/jwt_handler.py
===============================================================================
# app/utils/jwt_handler.py
"""
This module handles JSON Web Token (JWT) generation and validation.
It ensures that user sessions are persistent, secure, and include
expiration logic as required by the technical specifications.
"""

import os
import datetime
from typing import Optional
import jwt
import sentry_sdk


# Configuration from environment variables
SECRET_KEY = os.getenv("JWT_SECRET", "default-secret-key-to-change")
ALGORITHM = os.getenv("JWT_ALGORITHM", "HS256")
TOKEN_EXPIRATION_HOURS = 12


def create_token(employee_id: int, department_name: str) -> str:
    """
    Generate a JWT token containing employee ID and department.
    The token is set to expire in 12 hours.
    """
    now = datetime.datetime.now(datetime.UTC)
    payload = {
        "sub": employee_id,
        "department": department_name,
        "iat": now,
        "exp": now + datetime.timedelta(hours=TOKEN_EXPIRATION_HOURS)
    }
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)


def decode_token(token: str) -> Optional[dict]:
    """
    Decode and validate a JWT token.
    Returns the payload if valid, or None if expired/invalid.
    """
    try:
        return jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    except jwt.ExpiredSignatureError as e:
        # Report expiration to Sentry to monitor session timeouts
        sentry_sdk.capture_exception(e)
        return None
    except jwt.InvalidTokenError as e:
        # Report invalid/tampered tokens as they might indicate security issues
        sentry_sdk.capture_exception(e)
        return None

===============================================================================
    ./app/utils/permissions.py
===============================================================================
# app/utils/permissions.py
"""
This module provides a centralized authorization system mapping
specific actions to departments to determine user permissions.
"""

import sentry_sdk

# Mapping of permissions per department
PERMISSIONS = {
    'MANAGEMENT': [
        'read_client',
        'create_client',
        'update_client',
        'read_contract',
        'create_contract',
        'update_contract',
        'read_event',
        'update_event',
        'read_employee',
        'create_employee',
        'update_employee',
        'delete_employee'
    ],
    'SALES': [
        'read_client',
        'create_client',
        'update_client',
        'read_contract',
        'update_contract',
        'read_event',
        'create_event'
    ],
    'SUPPORT': [
        'read_client',
        'read_contract',
        'read_event',
        'update_event'
    ]
}


def has_permission(action: str, department_name: str) -> bool:
    """
    Check if a specific department has the required permission.
    """
    allowed_actions = PERMISSIONS.get(department_name, [])
    is_allowed = action in allowed_actions

    if not is_allowed:
        # Log unauthorized access attempts to Sentry as a warning
        sentry_sdk.capture_message(
            f"Access denied: Department '{department_name}' "
            f"tried to perform action '{action}'",
            level="warning"
        )

    return is_allowed

===============================================================================
    ./app/utils/token_storage.py
===============================================================================
# app/utils/token_storage.py
"""
This module manages the local persistence of the JWT token.
It provides functions to save, retrieve, and delete the token from
a local file to maintain user sessions across CLI executions.
"""

import os
from typing import Optional

TOKEN_FILE = ".token"


def save_token(token: str) -> None:
    """
    Save the JWT token to a local hidden file.
    """
    with open(TOKEN_FILE, "w", encoding="utf-8") as f:
        f.write(token)


def get_token() -> Optional[str]:
    """
    Retrieve the JWT token from the local file if it exists.
    """
    if os.path.exists(TOKEN_FILE):
        with open(TOKEN_FILE, "r", encoding="utf-8") as f:
            return f.read().strip()
    return None


def delete_token() -> None:
    """
    Remove the local token file to log out the user.
    """
    if os.path.exists(TOKEN_FILE):
        os.remove(TOKEN_FILE)

===============================================================================
    ./app/views/auth_view.py
===============================================================================
# app/views/auth_view.py
"""
View for authentication related interactions.
Handles login inputs and success/failure messages.
"""

from app.views.base_view import BaseView


class AuthView(BaseView):
    """Handles login inputs."""

    def ask_login_details(self) -> tuple[str, str]:
        """Prompt user for email and password."""
        print("\n=== Epic Events CRM - Login ===")
        email = self.ask_input("Email")
        password = self.ask_input("Password")
        return email, password

    def display_login_success(self):
        """Confirm successful login."""
        self.display_message("Login successful! Welcome.")

    def display_login_failure(self):
        """Warn about failed credentials."""
        self.display_error("Invalid email or password.")

===============================================================================
    ./app/views/base_view.py
===============================================================================
# app/views/base_view.py
"""
Base class for all views in the application.
Provides common display methods and input validation for CLI interaction.
"""

import re
from datetime import datetime


class BaseView:
    """Provides common display methods and input validation for CLI."""

    def display_message(self, message: str):
        """Display a simple text message."""
        print(f"\n{message}")

    def display_error(self, message: str):
        """Display an error message formatted for visibility."""
        print(f"\n[ERROR] {message}")

    def ask_input(self, prompt: str) -> str:
        """Helper to get user input."""
        return input(f"{prompt}: ").strip()

    def validate_email(self, email: str) -> bool:
        """Check if the email format is valid."""
        pattern = r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$"
        if re.match(pattern, email):
            return True
        self.display_error("Invalid email format (ex: name@domain.com).")
        return False

    def validate_amount(self, amount: str) -> bool:
        """Check if the amount is a positive number."""
        try:
            val = float(amount)
            if val >= 0:
                return True
            self.display_error("Amount must be a positive value.")
        except ValueError:
            self.display_error("Amount must be a numeric value.")
        return False

    def validate_date(self, date_str: str) -> bool:
        """Check if the date format is valid (DD-MM-YYYY)."""
        try:
            datetime.strptime(date_str, "%d-%m-%Y")
            return True
        except ValueError:
            self.display_error("Invalid date format. Please use DD-MM-YYYY.")
            return False

===============================================================================
    ./app/views/client_view.py
===============================================================================
# app/views/client_view.py
"""
View for Client related interactions.
"""
from app.views.base_view import BaseView


class ClientView(BaseView):
    """Handles client display and inputs."""

    def display_clients(self, clients: list):
        """Print the list of all clients."""
        print("\n=== Clients List ===")
        if not clients:
            print("No clients found.")
            return
        for client in clients:
            print(
                f"ID: {client.id} | Name: {client.full_name} | "
                f"Email: {client.email} | Company: {client.company_name} | "
                f"Last Contact: {client.last_contact}"
            )

    def ask_client_details(self) -> dict:
        """Prompt user for new client information."""
        print("\n=== Add New Client ===")
        return {
            "full_name": self.ask_input("Full Name"),
            "email": self.ask_input("Email"),
            "phone": self.ask_input("Phone"),
            "company_name": self.ask_input("Company Name"),
            "last_contact": self.ask_input(
                "Last Contact Date (YYYY-MM-DD HH:MM:SS) "
                "[Leave empty for now]"
            )
        }

===============================================================================
    ./app/views/contract_view.py
===============================================================================
# app/views/contract_view.py
"""
View for Contract related interactions.
"""
from app.views.base_view import BaseView


class ContractView(BaseView):
    """Handles contract display and inputs."""

    def display_contracts(self, contracts: list):
        """Print the list of all contracts."""
        print("\n=== Contracts List ===")
        if not contracts:
            print("No contracts found.")
            return
        for contract in contracts:
            status = "Signed" if contract.is_signed else "Not Signed"
            print(
                f"ID: {contract.id} | Client: {contract.client.full_name} | "
                f"Sales Contact: {contract.sales_contact.full_name} | "
                f"Total: {contract.total_amount} | Status: {status}"
            )

===============================================================================
    ./app/views/employee_view.py
===============================================================================
# app/views/employee_view.py
"""
View for Employee related interactions.
"""
from app.views.base_view import BaseView


class EmployeeView(BaseView):
    """Handles employee display and inputs."""

    def display_employees(self, employees: list):
        """Print the list of all employees."""
        print("\n=== Employees List ===")
        if not employees:
            print("No employees found.")
            return
        for emp in employees:
            dept_name = emp.department.name if emp.department else "N/A"
            print(
                f"ID: {emp.id} | No: {emp.employee_number} | "
                f"Name: {emp.full_name} | Email: {emp.email} | "
                f"Dept: {dept_name}"
            )

    def ask_employee_details(self) -> dict:
        """Prompt user for new employee information."""
        print("\n=== Add New Employee ===")

        full_name = self.ask_input("Full Name")

        while True:
            email = self.ask_input("Email")
            if self.validate_email(email):
                break

        password = self.ask_input("Password")
        employee_number = self.ask_input("Employee Number")
        department_id = self.ask_input(
            "Department ID (1: Sales, 2: Support, 3: Management)"
        )

        return {
            "full_name": full_name,
            "email": email,
            "password": password,
            "employee_number": employee_number,
            "department_id": int(department_id) if department_id.isdigit() else 0
        }

    def ask_update_details(self) -> dict:
        """Prompt user for employee updates (all fields optional)."""
        print("\n=== Update Employee (Leave blank to keep current value) ===")

        full_name = self.ask_input("New Full Name (optional)")
        email = self.ask_input("New Email (optional)")
        password = self.ask_input("New Password (optional)")
        dept_id = self.ask_input("New Dept ID (optional)")

        details = {}
        if full_name:
            details["full_name"] = full_name
        if email:
            details["email"] = email
        if password:
            details["password"] = password
        if dept_id:
            details["department_id"] = int(dept_id) if dept_id.isdigit() else 0

        return details

===============================================================================
    ./app/views/event_view.py
===============================================================================
# app/views/event_view.py
"""
View for Event related interactions.
"""
from app.views.base_view import BaseView


class EventView(BaseView):
    """Handles event display and inputs."""

    def display_events(self, events: list):
        """Print the list of all events."""
        print("\n=== Events List ===")
        if not events:
            print("No events found.")
            return
        for event in events:
            support = (
                event.support_contact.full_name
                if event.support_contact
                else "TBD"
            )
            print(
                f"ID: {event.id} | Name: {event.name} | "
                f"From: {event.event_date_start} To: {event.event_date_end} | "
                f"Support: {support}"
            )

===============================================================================
    ./app/views/main_menu_view.py
===============================================================================
# app/views/main_menu_view.py
"""
Main menu view for the CRM application.
Adapts displayed options based on user department.
"""

from app.views.base_view import BaseView


class MainMenuView(BaseView):
    """Controller view for the main menu."""

    def display_menu(self, department: str):
        """Print the main menu options according to department."""
        print(f"\n=== Epic Events CRM - {department} Menu ===")
        print("1. List all clients")
        print("2. List all contracts")
        print("3. List all events")

        if department == "MANAGEMENT":
            print("4. List all employees")
            print("5. Create new employee")
            print("6. Update an employee")
        elif department == "SALES":
            print("20. Create new client")
        elif department == "SUPPORT":
            print("30. Update my events")

        print("0. Logout and Exit")

    def ask_menu_option(self) -> str:
        """Ask the user for a menu option."""
        return input("\nSelect an option: ").strip()

===============================================================================
    ./check_auth.py
===============================================================================
# check_auth.py
from app.utils.auth import hash_password, verify_password

password_to_test = "admin123"
# Le hash exact que vous avez mis dans le SQL
sql_hash = "$argon2id$v=19$m=65536,t=3,p=4$7Y5Wp8W1S6lF6z1N2q9Q5w$O7N8/v5J8J8"

# 1. Test de vérification
is_valid = verify_password(password_to_test, sql_hash)
print(f"Match SQL hash: {is_valid}")

# 2. Test de génération
new_hash = hash_password(password_to_test)
print(f"New hash generated: {new_hash}")
print(f"Match new hash: {verify_password(password_to_test, new_hash)}")

===============================================================================
    ./config/config.py
===============================================================================
# config/config.py
import os
from dotenv import load_dotenv

# Load variables from .env file
load_dotenv()


class Config:
    """Configuration loader for environment variables."""
    DB_USER = os.getenv("DB_USER")
    DB_PASSWORD = os.getenv("DB_PASSWORD")
    DB_HOST = os.getenv("DB_HOST")
    DB_PORT = os.getenv("DB_PORT")
    DB_NAME = os.getenv("DB_NAME")
    SECRET_KEY = os.getenv("SECRET_KEY")
    SENTRY_DSN = os.getenv("SENTRY_DSN")

    @classmethod
    def get_db_url(cls):
        """Return formatted SQLAlchemy database URL."""
        return (
            f"mysql+mysqlconnector://{cls.DB_USER}:{cls.DB_PASSWORD}@"
            f"{cls.DB_HOST}:{cls.DB_PORT}/{cls.DB_NAME}"
        )

===============================================================================
    ./init_db.py
===============================================================================
# init_db.py
from sqlalchemy import create_engine
from app.models import Base
from config.config import Config


def create_tables():
    """
    Creates all database tables defined in the models.
    """
    engine = create_engine(Config.get_db_url())

    print("Connecting to the database...")
    try:
        # Create all tables stored in the metadata
        Base.metadata.create_all(engine)
        print("Success: All tables created successfully.")
    except Exception as e:
        print(f"Error during table creation: {e}")


if __name__ == "__main__":
    create_tables()

===============================================================================
    ./main.py
===============================================================================
# main.py
"""
Entry point for the Epic Events CRM application.
Manages the main loop and coordinate between controllers and views.
"""

import sentry_sdk
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from config.config import Config

from app.repositories.employee_repository import EmployeeRepository
from app.repositories.client_repository import ClientRepository
from app.repositories.contract_repository import ContractRepository
from app.repositories.event_repository import EventRepository

from app.controllers.auth_controller import AuthController
from app.controllers.client_controller import ClientController
from app.controllers.contract_controller import ContractController
from app.controllers.event_controller import EventController
from app.controllers.employee_controller import EmployeeController

from app.views.auth_view import AuthView
from app.views.main_menu_view import MainMenuView
from app.views.client_view import ClientView
from app.views.contract_view import ContractView
from app.views.event_view import EventView
from app.views.employee_view import EmployeeView

# Initialize Sentry
sentry_sdk.init(
    dsn=Config.SENTRY_DSN,
    # Set the environment (default to development if not specified in Config)
    environment=getattr(Config, "ENVIRONMENT", "development"),
    traces_sample_rate=1.0,
    profiles_sample_rate=1.0,
)


def main():
    """Main application execution logic."""
    try:
        # Database Setup
        engine = create_engine(Config.get_db_url())
        session_factory = sessionmaker(bind=engine)
        session = session_factory()

        # Initialize Repositories
        emp_repo = EmployeeRepository(session)
        client_repo = ClientRepository(session)
        contract_repo = ContractRepository(session)
        event_repo = EventRepository(session)

        # Initialize Controllers
        auth_ctrl = AuthController(emp_repo)
        client_ctrl = ClientController(client_repo, auth_ctrl)
        contract_ctrl = ContractController(contract_repo, auth_ctrl)
        event_ctrl = EventController(event_repo, auth_ctrl)
        emp_ctrl = EmployeeController(emp_repo, auth_ctrl)

        # Initialize Views
        auth_view = AuthView()
        menu_view = MainMenuView()
        client_view = ClientView()
        contract_view = ContractView()
        event_view = EventView()
        emp_view = EmployeeView()

        # 1. Authentication Check
        user_data = auth_ctrl.get_logged_in_user()
        if not user_data:
            email, password = auth_view.ask_login_details()
            # Capture user_data directly from login()
            user_data = auth_ctrl.login(email, password)
            if not user_data:
                auth_view.display_login_failure()
                return

        auth_view.display_login_success()

        # 2. Application Loop
        while True:

            menu_view.display_menu(user_data["department"])
            choice = menu_view.ask_menu_option()

            if choice == "1":
                # Pass user_data to satisfy the @require_auth decorator
                data = client_ctrl.list_all_clients(user_data=user_data)
                client_view.display_clients(data)
            elif choice == "2":
                # Pass user_data to satisfy the @require_auth decorator
                data = contract_ctrl.list_all_contracts(user_data=user_data)
                contract_view.display_contracts(data)
            elif choice == "3":
                # Pass user_data to satisfy the @require_auth decorator
                data = event_ctrl.list_all_events(user_data=user_data)
                event_view.display_events(data)
            elif choice == "4":
                data = emp_ctrl.list_all_employees(user_data=user_data)
                emp_view.display_employees(data)
            elif choice == "5":
                details = emp_view.ask_employee_details()
                emp_ctrl.create_employee(user_data=user_data, employee_data=details)
            elif choice == "6":
                emp_id = emp_view.ask_input("Enter Employee ID to update")
                if emp_id.isdigit():
                    updates = emp_view.ask_update_details()
                    emp_ctrl.update_employee(
                        user_data=user_data,
                        emp_id=int(emp_id),
                        update_data=updates
                    )
            elif choice == "0":
                auth_ctrl.logout()
                print("Goodbye!")
                break
            else:
                print("Invalid option. Please try again.")

    except Exception as e:
        # Catch and report any fatal application errors
        sentry_sdk.capture_exception(e)
        print(f"A fatal error occurred: {e}")
        raise e


if __name__ == "__main__":
    main()

===============================================================================
    ./tests/__init__.py
===============================================================================


===============================================================================
    ./tests/conftest.py
===============================================================================
# tests/conftest.py
"""
Pytest configuration and global fixtures.
Provides database engine and session management for tests.

Tests included:
- N/A (Configuration file)

Changes:
- Removed unused 'os' import to satisfy flake8.
- Added load_dotenv() to ensure environment variables are available.
"""

from dotenv import load_dotenv
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from config.config import Config

# Load environment variables from .env file at startup
load_dotenv()


@pytest.fixture(scope="session")
def db_engine():
    """
    Create a database engine for the test session.
    Uses the connection URL from the project configuration.
    """
    engine = create_engine(Config.get_db_url())
    yield engine
    engine.dispose()


@pytest.fixture(scope="function")
def db_session(db_engine):
    """
    Provide a clean database session for each test.
    Rolls back any changes after the test to keep the DB clean.
    """
    connection = db_engine.connect()
    transaction = connection.begin()

    session_factory = sessionmaker(bind=connection)
    session = session_factory()

    yield session

    session.close()
    transaction.rollback()
    connection.close()

===============================================================================
    ./tests/test_jwt_handler.py
===============================================================================
# tests/test_jwt_handler.py
"""
Unit tests for JWT handler.

Tests included:
- test_create_and_decode_valid_token: Verify generation and decoding.
- test_decode_invalid_token: Ensure invalid strings return None.
- test_expired_token: Verify expiration logic returns None.
"""

import datetime
import jwt
from app.utils.jwt_handler import create_token, decode_token


def test_create_and_decode_valid_token():
    """Verify that a generated token can be correctly decoded."""
    token = create_token(1, "Management")
    decoded = decode_token(token)

    # Debug: si ça échoue encore, on verra pourquoi
    assert decoded is not None, "Token decoding failed: returned None"
    assert decoded["sub"] == 1
    assert decoded["department"] == "Management"


def test_decode_invalid_token():
    """Ensure that an invalid token returns None."""
    assert decode_token("invalid.token.string") is None


def test_expired_token():
    """Verify that an expired token returns None."""
    # Import inside to ensure we use the same config as the app
    from app.utils.jwt_handler import SECRET_KEY, ALGORITHM

    now = datetime.datetime.now(datetime.UTC)
    payload = {
        "sub": 1,
        "department": "Sales",
        "exp": now - datetime.timedelta(seconds=1)
    }
    expired_token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

    decoded = decode_token(expired_token)
    assert decoded is None

