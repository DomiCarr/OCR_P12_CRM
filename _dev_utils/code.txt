Generated 2026-02-20 20:28:44

===============================================================================
    ./.pytest_cache/README.md
===============================================================================
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.


===============================================================================
    ./README.md
===============================================================================
# OCR_P12_CRM


===============================================================================
    ./app/controllers/auth_controller.py
===============================================================================
# app/controllers/auth_controller.py
"""
This module handles the authentication logic, integrating JWT generation
and local storage to provide persistent user sessions.
"""

from typing import Optional
import sentry_sdk
from app.repositories.employee_repository import EmployeeRepository
from app.utils.auth import verify_password
from app.utils.permissions import has_permission
from app.utils.jwt_handler import create_token, decode_token
from app.utils.token_storage import save_token, get_token, delete_token


class AuthController:
    """
    Controller managing login, logout, and persistent session validation.
    """

    def __init__(self, employee_repository: EmployeeRepository):
        self.repository = employee_repository
        self.current_user_data: Optional[dict] = None

    def login(self, email: str, password: str) -> Optional[dict]:
        """
        Authenticate user and save a JWT locally if successful.
        """
        employee = self.repository.get_by_email(email)

        if employee and verify_password(employee.password, password):
            # Generate and save token locally
            token = create_token(employee.id, employee.department.name)
            save_token(token)

            # Return user data for main.py session management
            user_data = {
                "id": employee.id,
                "full_name": employee.full_name,
                "department": employee.department.name
            }

            # Attach user identity to Sentry scope for error tracking
            sentry_sdk.set_user({
                "id": str(employee.id),
                "username": employee.full_name,
                "department": employee.department.name
            })

            self.current_user_data = user_data
            return user_data

        return None

    def logout(self) -> None:
        """
        Clear the session by deleting the local token.
        """
        delete_token()
        # Clear Sentry user context to avoid cross-user error reporting
        sentry_sdk.set_user(None)
        self.current_user_data = None

    def get_logged_in_user(self) -> Optional[dict]:
        """
        Validate the local token and return user data if still valid.
        """
        token = get_token()
        if not token:
            return None

        payload = decode_token(token)
        if payload:
            # Restore Sentry user identity for persistent sessions
            sentry_sdk.set_user({
                "id": str(payload.get("id")),
                "department": payload.get("department")
            })
            self.current_user_data = payload
            return payload

        # Token expired or invalid
        delete_token()
        return None

    def check_user_permission(self, action: str) -> bool:
        """
        Check if the currently logged-in user has permission for an action.
        """
        if not self.current_user_data:
            return False

        dept = self.current_user_data.get("department")
        return has_permission(action, dept)

===============================================================================
    ./app/controllers/client_controller.py
===============================================================================
# app/controllers/client_controller.py
"""
Controller handling business logic for Client management.
Ensures authentication and permission checks before data access.
"""

from datetime import datetime
from app.models.client import Client
from app.repositories.client_repository import ClientRepository
from app.utils.decorators import require_auth


class ClientController:
    """Manages client-related operations."""

    def __init__(self, repository: ClientRepository, auth_controller):
        self.repository = repository
        self.auth_controller = auth_controller

    @require_auth
    def list_all_clients(self, *args, user_data: dict | None = None):
        """Fetch all clients if the user has the 'read_client' permission."""
        if user_data is None and args:
            if isinstance(args[0], dict) and "id" in args[0]:
                user_data = args[0]

        if user_data is None:
            return []

        self.auth_controller.current_user_data = user_data
        permission = "read_client"
        if self.auth_controller.check_user_permission(permission):
            return self.repository.get_all_clients()
        return []

    @require_auth
    def create_client(
        self,
        *args,
        user_data: dict | None = None,
        client_data: dict | None = None,
    ):
        """Create a new client and associate with the current sales person."""
        if client_data is None and args:
            first = args[0]
            if isinstance(first, dict) and "id" in first and "department" in first:
                user_data = first
                if len(args) > 1:
                    client_data = args[1]
            else:
                client_data = first

        if user_data is None:
            user_data = getattr(self.auth_controller, "current_user_data", None)

        if not user_data or not client_data:
            return None

        self.auth_controller.current_user_data = user_data
        if self.auth_controller.check_user_permission("create_client"):
            client_data["sales_contact_id"] = user_data["id"]

            if not client_data.get("last_contact"):
                client_data["last_contact"] = datetime.now()

            new_client = Client(**client_data)
            created_client = self.repository.add(new_client)

            if created_client:
                print(f"Client '{created_client.full_name}' created.")
            return created_client

        print("Access denied: You do not have permission to create a client.")
        return None

    @require_auth
    def update_client(self, user_data: dict, client_id: int, updates: dict):
        """Update client if user is assigned sales contact or management."""
        self.auth_controller.current_user_data = user_data
        if not self.auth_controller.check_user_permission("update_client"):
            print("Access denied: No update permission.")
            return None

        client = self.repository.get_by_id(client_id)
        if not client:
            print("Client not found.")
            return None

        # Logic: Sales can only update their own clients. Management can update all.
        is_owner = client.sales_contact_id == user_data["id"]
        is_management = user_data["department"] == "MANAGEMENT"

        if not (is_owner or is_management):
            print("Access denied: You are not the assigned sales contact.")
            return None

        # Update last_contact timestamp
        updates["last_contact"] = datetime.now()

        # FIXED: Pass 'updates' as a dict to match BaseRepository.update signature
        updated_client = self.repository.update(client_id, updates)
        if updated_client:
            print(f"Client '{updated_client.full_name}' updated.")
        return updated_client


===============================================================================
    ./app/controllers/contract_controller.py
===============================================================================
# app/controllers/contract_controller.py
"""
Controller handling business logic for Contract management.
"""

from app.models.contract import Contract
from app.repositories.contract_repository import ContractRepository
from app.utils.decorators import require_auth


class ContractController:
    """Manages contract-related operations."""

    def __init__(self, repository: ContractRepository, auth_controller):
        self.repository = repository
        self.auth_controller = auth_controller

    @require_auth
    def list_all_contracts(self, user_data: dict):
        """
        Fetch all contracts if allowed.
        """
        self.auth_controller.current_user_data = user_data
        if self.auth_controller.check_user_permission("read_contract"):
            return self.repository.get_all_contracts()
        return None

    @require_auth
    def create_contract(self, user_data: dict, contract_data: dict):
        """Create a new contract for a client."""
        self.auth_controller.current_user_data = user_data
        if self.auth_controller.check_user_permission("create_contract"):
            if "sales_contact_id" not in contract_data:
                contract_data["sales_contact_id"] = user_data["id"]

            new_contract = Contract(**contract_data)
            created_contract = self.repository.add(new_contract)

            if created_contract:
                print(f"Contract {created_contract.id} created successfully.")
            return created_contract

        print("Access denied: You do not have permission to create a contract.")
        return None

    @require_auth
    def update_contract(self, user_data: dict, contract_id: int, updates: dict):
        """Update contract details if user has permission."""
        self.auth_controller.current_user_data = user_data
        if not self.auth_controller.check_user_permission("update_contract"):
            print("Access denied: No update permission for contracts.")
            return None

        contract = self.repository.get_by_id(contract_id)
        if not contract:
            print("Contract not found.")
            return None

        # Logic: Sales can only update their own contracts. Management can update all.
        is_owner = contract.sales_contact_id == user_data["id"]
        is_management = user_data["department"] == "MANAGEMENT"

        if not (is_owner or is_management):
            print("Access denied: You are not the assigned sales contact.")
            return None

        updated_contract = self.repository.update(contract_id, updates)
        if updated_contract:
            print(f"Contract {updated_contract.id} updated.")
        return updated_contract

===============================================================================
    ./app/controllers/employee_controller.py
===============================================================================
# app/controllers/employee_controller.py
"""
Controller handling business logic for Employee management.
"""

from app.models.employee import Employee
from app.repositories.employee_repository import EmployeeRepository
from app.utils.decorators import require_auth
from app.utils.auth import hash_password


class EmployeeController:
    """Manages employee-related operations."""

    def __init__(self, repository: EmployeeRepository, auth_controller):
        self.repository = repository
        self.auth_controller = auth_controller

    @require_auth
    def list_all_employees(self, user_data: dict):
        """
        Fetch all employees if the user has the 'read_employee' permission.
        """
        self.auth_controller.current_user_data = user_data

        if self.auth_controller.check_user_permission("read_employee"):
            return self.repository.get_all()

        return []

    @require_auth
    def create_employee(self, user_data: dict, employee_data: dict):
        """
        Create a new employee after permission check and password hashing.
        """
        self.auth_controller.current_user_data = user_data

        if not self.auth_controller.check_user_permission("create_employee"):
            return None

        # Hash the password before storage
        employee_data["password"] = hash_password(employee_data["password"])

        # Create the instance
        new_employee = Employee(**employee_data)

        # Pass the instance (not the dict) to the repository
        created_employee = self.repository.add(new_employee)
        return created_employee

    @require_auth
    def update_employee(self, user_data: dict, emp_id: int, update_data: dict):
        """
        Update an existing employee's data.
        """
        self.auth_controller.current_user_data = user_data

        if not self.auth_controller.check_user_permission("update_employee"):
            return None

        if "password" in update_data:
            update_data["password"] = hash_password(update_data["password"])

        updated_emp = self.repository.update(emp_id, update_data)
        return updated_emp

===============================================================================
    ./app/controllers/event_controller.py
===============================================================================
# app/controllers/event_controller.py
"""
Controller handling business logic for Event management.
"""

from app.models.event import Event
from app.repositories.event_repository import EventRepository
from app.utils.decorators import require_auth


class EventController:
    """Manages event-related operations."""

    def __init__(self, repository: EventRepository, auth_controller):
        self.repository = repository
        self.auth_controller = auth_controller

    @require_auth
    def list_all_events(self, user_data: dict):
        """
        Fetch all events if allowed.
        """
        self.auth_controller.current_user_data = user_data
        if self.auth_controller.check_user_permission("read_event"):
            return self.repository.get_all_events()
        return None

    @require_auth
    def create_event(self, user_data: dict, event_data: dict, contract):
        """
        Create a new event if the contract is signed and user is the owner.
        """
        self.auth_controller.current_user_data = user_data
        if not self.auth_controller.check_user_permission("create_event"):
            print("Access denied: No permission to create events.")
            return None

        if contract.sales_contact_id != user_data["id"]:
            print("Access denied: You are not the sales contact for this client.")
            return None

        if not contract.is_signed:
            print("Access denied: Cannot create an event for an unsigned contract.")
            return None

        new_event = Event(**event_data)
        created_event = self.repository.add(new_event)

        if created_event:
            print(f"Event '{created_event.name}' created successfully.")
        return created_event

    @require_auth
    def update_event(self, user_data: dict, event_id: int, updates: dict):
        """Update event details if user is assigned support or management."""
        self.auth_controller.current_user_data = user_data
        if not self.auth_controller.check_user_permission("update_event"):
            print("Access denied: No update permission for events.")
            return None

        event = self.repository.get_by_id(event_id)
        if not event:
            print("Event not found.")
            return None

        # Logic: Support assigned or Management can update
        is_assigned = event.support_contact_id == user_data["id"]
        is_management = user_data["department"] == "MANAGEMENT"

        if not (is_assigned or is_management):
            print("Access denied: You are not the assigned support contact.")
            return None

        updated_event = self.repository.update(event_id, updates)
        if updated_event:
            print(f"Event '{updated_event.name}' updated.")
        return updated_event

===============================================================================
    ./app/models/__init__.py
===============================================================================
# app/models/__init__.py
"""
This module centralizes all SQLAlchemy models to facilitate imports
and ensure they are registered with the Base metadata for migrations.
"""

from app.models.base import Base
from app.models.department import Department
from app.models.employee import Employee
from app.models.client import Client
from app.models.contract import Contract
from app.models.event import Event

__all__ = [
    "Base",
    "Department",
    "Employee",
    "Client",
    "Contract",
    "Event"
]

===============================================================================
    ./app/models/base.py
===============================================================================
# app/models/base.py
"""
This module serves as the foundation for the ORM layer.
- Provides a centralized DeclarativeBase for model registration.
- Defines custom type aliases (Annotated) to standardize SQL constraints
  (String lengths, Primary Keys, and Timestamps) across the entire schema.
- Uses server-side functions for automated audit trails (created_at, updated_at).
"""
import datetime
from typing import Annotated
from sqlalchemy import String, Text, func
from sqlalchemy.orm import DeclarativeBase, mapped_column


# Type aliases to ensure consistency across all models
# Primary keys with auto-increment
pk_id = Annotated[int, mapped_column(primary_key=True, autoincrement=True)]

# Standard string lengths for database columns
str_20 = Annotated[str, mapped_column(String(20))]
str_50 = Annotated[str, mapped_column(String(50))]
str_100 = Annotated[str, mapped_column(String(100))]
str_255 = Annotated[str, mapped_column(String(255))]

# Long text for descriptions or notes
text_type = Annotated[str, mapped_column(Text)]

# Automatically managed timestamps
timestamp_now = Annotated[
    datetime.datetime,
    mapped_column(server_default=func.now())
]
timestamp_update = Annotated[
    datetime.datetime,
    mapped_column(server_default=func.now(), onupdate=func.now())
]


class Base(DeclarativeBase):
    """
    Base class for declarative models.
    Maintains a registry of all mapped classes.
    """
    pass

===============================================================================
    ./app/models/client.py
===============================================================================
# app/models/client.py
"""
This module defines the Client model, which stores customer information,
contact details, and handles relationships with sales employees,
contracts, and events.
"""

from typing import TYPE_CHECKING
from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import (
    Base,
    pk_id,
    str_50,
    str_100,
    str_20,
    timestamp_now,
    timestamp_update
)

if TYPE_CHECKING:
    from app.models.employee import Employee
    from app.models.event import Event
    from app.models.contract import Contract


class Client(Base):
    """
    Represents a customer in the CRM system.
    """

    __tablename__ = "client"

    id: Mapped[pk_id]
    full_name: Mapped[str_50]
    email: Mapped[str_100] = mapped_column(unique=True)
    phone: Mapped[str_20]
    company_name: Mapped[str_50]

    # New field for last business contact
    last_contact: Mapped[timestamp_now]

    # Audit timestamps
    creation_date: Mapped[timestamp_now]
    last_update: Mapped[timestamp_update]

    # Foreign Key to the Sales Contact (Employee)
    sales_contact_id: Mapped[int | None] = mapped_column(
        ForeignKey("employee.id"),
        nullable=True,
    )

    # Relationships
    sales_contact: Mapped["Employee"] = relationship(
        back_populates="managed_clients"
    )
    contracts: Mapped[list["Contract"]] = relationship(
        back_populates="client"
    )
    events: Mapped[list["Event"]] = relationship(
        back_populates="client"
    )

    def __repr__(self) -> str:
        return (
            f"<Client(name={self.full_name}, "
            f"company={self.company_name})>"
        )


===============================================================================
    ./app/models/contract.py
===============================================================================
# app/models/contract.py
"""
This module defines the Contract model, which stores financial agreements
with clients, including amounts, payment status, and audit timestamps.
"""

from typing import TYPE_CHECKING
from sqlalchemy import ForeignKey, Boolean, Numeric
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import (
    Base,
    pk_id,
    timestamp_now,
    timestamp_update
)

if TYPE_CHECKING:
    from app.models.client import Client
    from app.models.event import Event
    from app.models.employee import Employee


class Contract(Base):
    """
    Represents a financial agreement with a client.
    """

    __tablename__ = "contract"

    id: Mapped[pk_id]
    total_amount: Mapped[float] = mapped_column(Numeric(10, 2))
    remaining_amount: Mapped[float] = mapped_column(Numeric(10, 2))
    is_signed: Mapped[bool] = mapped_column(Boolean, default=False)

    # Audit timestamps
    creation_date: Mapped[timestamp_now]
    last_update: Mapped[timestamp_update]

    # Foreign Keys
    client_id: Mapped[int] = mapped_column(ForeignKey("client.id"))
    sales_contact_id: Mapped[int] = mapped_column(ForeignKey("employee.id"))

    # Relationships
    client: Mapped["Client"] = relationship(back_populates="contracts")
    sales_contact: Mapped["Employee"] = relationship(
        back_populates="managed_contracts"
    )
    event: Mapped["Event"] = relationship(back_populates="contract")

    def __repr__(self) -> str:
        return (
            f"<Contract(id={self.id}, "
            f"remaining={self.remaining_amount}, "
            f"signed={self.is_signed})>"
        )

===============================================================================
    ./app/models/department.py
===============================================================================
# app/models/department.py
"""
This module defines the Department model, which represents the different
business units within the company and manages their relationship with employees.
"""

from typing import TYPE_CHECKING
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import Base, pk_id, str_50

if TYPE_CHECKING:
    from app.models.employee import Employee


class Department(Base):
    """
    Represents a business unit (MANAGEMENT, SALES, or SUPPORT).
    """

    __tablename__ = "department"

    id: Mapped[pk_id]
    name: Mapped[str_50] = mapped_column(unique=True)

    # Relationships
    employees: Mapped[list["Employee"]] = relationship(
        back_populates="department"
    )

    def __repr__(self) -> str:
        return f"<Department(name={self.name})>"

===============================================================================
    ./app/models/employee.py
===============================================================================
# app/models/employee.py
"""
This module defines the Employee model, which stores staff member information,
credentials, and their association with departments and managed entities
such as clients and events.
"""

from typing import TYPE_CHECKING
from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import Base, pk_id, str_50, str_100, str_255, str_20

if TYPE_CHECKING:
    from app.models.department import Department
    from app.models.client import Client
    from app.models.event import Event
    from app.models.contract import Contract


class Employee(Base):
    """
    Represents a staff member of Epic Events.
    """

    __tablename__ = "employee"

    id: Mapped[pk_id]
    full_name: Mapped[str_50]
    email: Mapped[str_100] = mapped_column(unique=True)
    password: Mapped[str_255]
    employee_number: Mapped[str_20] = mapped_column(unique=True)

    # Foreign Key to Department
    department_id: Mapped[int] = mapped_column(ForeignKey("department.id"))

    # Relationships
    department: Mapped["Department"] = relationship(back_populates="employees")

    # Managed entities (Sales/Support roles)
    managed_clients: Mapped[list["Client"]] = relationship(
        back_populates="sales_contact"
    )
    managed_contracts: Mapped[list["Contract"]] = relationship(
        back_populates="sales_contact"
    )
    assigned_events: Mapped[list["Event"]] = relationship(
        back_populates="support_contact"
    )

    def __repr__(self) -> str:
        return (
            f"<Employee(name={self.full_name}, "
            f"department_id={self.department_id})>"
        )

===============================================================================
    ./app/models/event.py
===============================================================================
# app/models/event.py
"""
This module defines the Event model, representing a scheduled event
linked to a client, a contract, and potentially a support employee.
"""

from typing import TYPE_CHECKING, Optional
from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import (
    Base,
    pk_id,
    str_50,
    text_type,
    timestamp_now,
    timestamp_update
)

if TYPE_CHECKING:
    from app.models.client import Client
    from app.models.employee import Employee
    from app.models.contract import Contract


class Event(Base):
    """
    Represents a scheduled event for a specific client and contract.
    """

    __tablename__ = "event"

    id: Mapped[pk_id]
    name: Mapped[str_50]
    event_date_start: Mapped[timestamp_now]
    event_date_end: Mapped[timestamp_now]
    location: Mapped[str_50]
    attendees: Mapped[int]
    notes: Mapped[text_type]

    # Audit timestamps
    creation_date: Mapped[timestamp_now]
    last_update: Mapped[timestamp_update]

    # Foreign Keys
    client_id: Mapped[int] = mapped_column(ForeignKey("client.id"))
    contract_id: Mapped[int] = mapped_column(ForeignKey("contract.id"))
    support_contact_id: Mapped[Optional[int]] = mapped_column(
        ForeignKey("employee.id"), nullable=True
    )

    # Relationships
    client: Mapped["Client"] = relationship(back_populates="events")
    contract: Mapped["Contract"] = relationship(back_populates="event")
    support_contact: Mapped["Employee"] = relationship(
        back_populates="assigned_events"
    )

    def __repr__(self) -> str:
        return f"<Event(name={self.name}, start={self.event_date_start})>"

===============================================================================
    ./app/repositories/base_repository.py
===============================================================================
# app/repositories/base_repository.py
"""
This module defines the BaseRepository class using Generics.
It provides a standardized interface for common database operations (CRUD)
shared across all specific repositories.
"""

from typing import Generic, TypeVar, Type, Optional, List
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
import sentry_sdk
from app.models.base import Base

T = TypeVar("T", bound=Base)


class BaseRepository(Generic[T]):
    """
    Base class for data access logic.
    """

    def __init__(self, session: Session, model: Type[T]):
        self.session = session
        self.model = model

    def get_by_id(self, obj_id: int) -> Optional[T]:
        """Fetch a single record by its primary key."""
        return self.session.query(self.model).filter(
            self.model.id == obj_id
        ).first()

    def get_all(self) -> List[T]:
        """Fetch all records for this model."""
        return self.session.query(self.model).all()

    def add(self, obj: T) -> T:
        """Add a new object and commit the transaction."""
        try:
            self.session.add(obj)
            self.session.commit()
            self.session.refresh(obj)
            return obj
        except IntegrityError as e:
            # Capture database constraint violations (e.g., duplicate email)
            self.session.rollback()
            sentry_sdk.capture_exception(e)
            raise e
        except SQLAlchemyError as e:
            # Capture any other database-related errors
            self.session.rollback()
            sentry_sdk.capture_exception(e)
            raise e

    def update(self, obj_id: int, update_data: dict) -> Optional[T]:
        """Update a record and commit the transaction."""
        obj = self.get_by_id(obj_id)
        if obj:
            try:
                for key, value in update_data.items():
                    if hasattr(obj, key):
                        setattr(obj, key, value)
                self.session.commit()
                self.session.refresh(obj)
                return obj
            except SQLAlchemyError as e:
                self.session.rollback()
                sentry_sdk.capture_exception(e)
                raise e
        return None

    def delete(self, obj: T) -> None:
        """Remove an object and commit the transaction."""
        try:
            self.session.delete(obj)
            self.session.commit()
        except SQLAlchemyError as e:
            self.session.rollback()
            sentry_sdk.capture_exception(e)
            raise e

===============================================================================
    ./app/repositories/client_repository.py
===============================================================================
# app/repositories/client_repository.py
"""
Data access layer for Client-specific operations.
"""

from typing import Optional, List
from sqlalchemy.orm import Session
from app.models.client import Client
from app.repositories.base_repository import BaseRepository


class ClientRepository(BaseRepository[Client]):
    """
    Repository handling Client database queries.
    """

    def __init__(self, session: Session):
        super().__init__(session, Client)

    def get_all_clients(self) -> List[Client]:
        """
        Fetch all clients by calling the inherited get_all method.
        """
        return self.get_all()

    def get_by_email(self, email: str) -> Optional[Client]:
        """
        Fetch a client by its unique email.
        """
        return self.session.query(self.model).filter(
            self.model.email == email
        ).first()

===============================================================================
    ./app/repositories/contract_repository.py
===============================================================================
# app/repositories/contract_repository.py
"""
Data access layer for Contract-specific operations.
"""

from typing import List, Optional
from sqlalchemy.orm import Session
from app.models.contract import Contract
from app.repositories.base_repository import BaseRepository


class ContractRepository(BaseRepository[Contract]):
    """
    Repository handling Contract database queries.
    """

    def __init__(self, session: Session):
        super().__init__(session, Contract)

    def get_all_contracts(self) -> List[Contract]:
        """
        Fetch all contracts by calling the inherited get_all method.
        """
        return self.get_all()

    def get_unsigned_contracts(self) -> List[Contract]:
        """
        Fetch all contracts that are not yet signed.
        """
        return self.session.query(self.model).filter(
            self.model.is_signed == False  # noqa: E712
        ).all()

    def get_unpaid_contracts(self) -> List[Contract]:
        """
        Fetch contracts where remaining amount is greater than zero.
        """
        return self.session.query(self.model).filter(
            self.model.remaining_amount > 0
        ).all()

===============================================================================
    ./app/repositories/department_repository.py
===============================================================================
# app/repositories/department_repository.py
"""
This module specializes the BaseRepository for the Department model.
"""

from typing import Optional, List
from sqlalchemy.orm import Session
from app.models.department import Department
from app.repositories.base_repository import BaseRepository


class DepartmentRepository(BaseRepository[Department]):
    """
    Data access layer for Department-specific operations.
    """

    def __init__(self, session: Session):
        super().__init__(session, Department)

    def get_all_departments(self) -> List[Department]:
        """
        Fetch all departments using the base repository method.
        """
        return self.get_all()

    def get_by_name(self, name: str) -> Optional[Department]:
        """
        Fetch a department by its unique name.
        """
        return self.session.query(self.model).filter(
            self.model.name == name
        ).first()

===============================================================================
    ./app/repositories/employee_repository.py
===============================================================================
# app/repositories/employee_repository.py
"""
This module specializes the BaseRepository for the Employee model.
It provides specific lookup methods necessary for authentication
and staff management.
"""

from typing import Optional
from sqlalchemy.orm import Session
from app.models.employee import Employee
from app.repositories.base_repository import BaseRepository


class EmployeeRepository(BaseRepository[Employee]):
    """
    Data access layer for Employee-specific operations.
    """

    def __init__(self, session: Session):
        super().__init__(session, Employee)

    def get_all_employees(self):
        """
        Fetch all employees using the base repository method.
        """
        return self.get_all()

    def get_by_email(self, email: str) -> Optional[Employee]:
        """
        Fetch an employee by their unique email address.
        Used for authentication.
        """
        return self.session.query(self.model).filter(
            self.model.email == email
        ).first()

    def get_by_employee_number(self, emp_number: str) -> Optional[Employee]:
        """
        Fetch an employee by their unique employee number.
        """
        return self.session.query(self.model).filter(
            self.model.employee_number == emp_number
        ).first()

===============================================================================
    ./app/repositories/event_repository.py
===============================================================================
# app/repositories/event_repository.py
"""
Data access layer for Event-specific operations.
"""

from typing import List, Optional
from sqlalchemy.orm import Session
from app.models.event import Event
from app.repositories.base_repository import BaseRepository


class EventRepository(BaseRepository[Event]):
    """
    Repository handling Event database queries.
    """

    def __init__(self, session: Session):
        super().__init__(session, Event)

    def get_all_events(self) -> List[Event]:
        """
        Fetch all events by calling the inherited get_all method.
        """
        return self.get_all()

    def get_events_without_support(self) -> List[Event]:
        """
        Fetch all events that have no support contact assigned.
        """
        return self.session.query(self.model).filter(
            self.model.support_contact_id == None  # noqa: E711
        ).all()

    def get_my_events(self, support_id: int) -> List[Event]:
        """
        Fetch events assigned to a specific support employee.
        """
        return self.session.query(self.model).filter(
            self.model.support_contact_id == support_id
        ).all()

===============================================================================
    ./app/utils/auth.py
===============================================================================
# app/utils/auth.py
"""
This module handles secure password management using the Argon2 hashing
algorithm. It provides utilities for hashing plain text passwords and
verifying them against stored hashes.
"""

from argon2 import PasswordHasher
from argon2.exceptions import VerifyMismatchError, InvalidHashError

# Initialize the hasher with default secure parameters
ph = PasswordHasher()


def hash_password(password: str) -> str:
    """
    Hash a password using Argon2.
    """
    return ph.hash(password)


def verify_password(hashed_password: str, plain_password: str) -> bool:
    """
    Verify a password against its Argon2 hash.
    """
    try:
        return ph.verify(hashed_password, plain_password)
    except (VerifyMismatchError, InvalidHashError):
        return False

===============================================================================
    ./app/utils/decorators.py
===============================================================================
# app/utils/decorators.py
"""
Authentication decorators for controller methods.
Ensures user_data is available via token or arguments.
"""

from functools import wraps
from typing import Any, Callable

import sentry_sdk

from app.utils.jwt_handler import decode_token
from app.utils.token_storage import get_token


# Handles dynamic `user_data` injection from kwargs, args, controller state, or token.
def require_auth(func: Callable) -> Callable:
    """
    Decorator that ensures a user is authenticated before executing a method.
    Injects user_data into kwargs to avoid shifting positional arguments.
    """

    def is_user_data(value: Any) -> bool:
        if not isinstance(value, dict):
            return False
        return "id" in value and "department" in value

    @wraps(func)
    def wrapper(self, *args, **kwargs) -> Any:
        sentry_sdk.add_breadcrumb(
            category="auth",
            message=f"Checking authentication for {func.__name__}",
            level="info",
        )

        user_data = kwargs.get("user_data")

        if not user_data and args and is_user_data(args[0]):
            user_data = args[0]

        if not user_data and hasattr(self, "auth_controller"):
            auth_ctrl = getattr(self, "auth_controller")
            current = getattr(auth_ctrl, "current_user_data", None)
            if current:
                user_data = current

        if not user_data:
            token = get_token()
            if token:
                user_data = decode_token(token)

        if not user_data:
            sentry_sdk.add_breadcrumb(
                category="auth",
                message="Authentication failed: No user data found",
                level="warning",
            )
            return None

        if "user_data" in kwargs:
            return func(self, *args, **kwargs)

        if args and is_user_data(args[0]):
            return func(self, *args, **kwargs)

        try:
            return func(self, *args, user_data=user_data, **kwargs)
        except TypeError:
            return func(self, user_data, *args, **kwargs)

    return wrapper


===============================================================================
    ./app/utils/jwt_handler.py
===============================================================================
# app/utils/jwt_handler.py
"""
This module handles JSON Web Token (JWT) generation and validation.
It ensures that user sessions are persistent, secure, and include
expiration logic as required by the technical specifications.
"""

import os
import datetime
from typing import Optional
import jwt
import sentry_sdk


# Configuration from environment variables
SECRET_KEY = os.getenv("JWT_SECRET", "default-secret-key-to-change")
ALGORITHM = os.getenv("JWT_ALGORITHM", "HS256")
TOKEN_EXPIRATION_HOURS = 12


def create_token(employee_id: int, department_name: str) -> str:
    """
    Generate a JWT token containing employee ID and department.
    The token is set to expire in 12 hours.
    """
    now = datetime.datetime.now(datetime.UTC)
    payload = {
        "sub": str(employee_id),
        "id": employee_id,
        "department": department_name,
        "iat": int(now.timestamp()),
        "exp": int(
            (now + datetime.timedelta(hours=TOKEN_EXPIRATION_HOURS)).timestamp()
        ),
    }
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)


def decode_token(token: str) -> Optional[dict]:
    """
    Decode and validate a JWT token.
    Returns the payload if valid, or None if expired/invalid.
    """
    try:
        return jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    except jwt.ExpiredSignatureError as e:
        sentry_sdk.capture_exception(e)
        return None
    except jwt.InvalidTokenError as e:
        # Debug print for development phase
        print(f"DEBUG Decode Error: {e}")
        sentry_sdk.capture_exception(e)
        return None

===============================================================================
    ./app/utils/permissions.py
===============================================================================
# app/utils/permissions.py
"""
This module provides a centralized authorization system mapping
specific actions to departments to determine user permissions.
"""

import sentry_sdk

# Mapping of permissions per department
PERMISSIONS = {
    'MANAGEMENT': [
        'read_client',
        'create_client',
        'update_client',
        'read_contract',
        'create_contract',
        'update_contract',
        'read_event',
        'update_event',
        'read_employee',
        'create_employee',
        'update_employee',
        'delete_employee'
    ],
    'SALES': [
        'read_client',
        'create_client',
        'update_client',
        'read_contract',
        'update_contract',
        'read_event',
        'create_event'
    ],
    'SUPPORT': [
        'read_client',
        'read_contract',
        'read_event',
        'update_event'
    ]
}


def has_permission(action: str, department_name: str) -> bool:
    """
    Check if a specific department has the required permission.
    """
    allowed_actions = PERMISSIONS.get(department_name, [])
    is_allowed = action in allowed_actions

    if not is_allowed:
        # Log unauthorized access attempts to Sentry as a warning
        sentry_sdk.capture_message(
            f"Access denied: Department '{department_name}' "
            f"tried to perform action '{action}'",
            level="warning"
        )

    return is_allowed

===============================================================================
    ./app/utils/token_storage.py
===============================================================================
# app/utils/token_storage.py
"""
This module manages the local persistence of the JWT token.
It provides functions to save, retrieve, and delete the token from
a local file to maintain user sessions across CLI executions.
"""

import os
from typing import Optional

TOKEN_FILE = ".token"


def save_token(token: str) -> None:
    """
    Save the JWT token to a local hidden file.
    """
    with open(TOKEN_FILE, "w", encoding="utf-8") as f:
        f.write(token)


def get_token() -> Optional[str]:
    """
    Retrieve the JWT token from the local file if it exists.
    """
    if os.path.exists(TOKEN_FILE):
        with open(TOKEN_FILE, "r", encoding="utf-8") as f:
            return f.read().strip()
    return None


def delete_token() -> None:
    """
    Remove the local token file to log out the user.
    """
    if os.path.exists(TOKEN_FILE):
        os.remove(TOKEN_FILE)

===============================================================================
    ./app/views/auth_view.py
===============================================================================
# app/views/auth_view.py
"""
View for authentication related interactions.
Handles login inputs and success/failure messages.
"""

from app.views.base_view import BaseView


class AuthView(BaseView):
    """Handles login inputs."""

    def ask_login_details(self) -> tuple[str, str]:
        """Prompt user for email and password."""
        print("\n=== Epic Events CRM - Login ===")
        email = self.ask_input("Email")
        password = self.ask_input("Password")
        return email, password

    def display_login_success(self):
        """Confirm successful login."""
        self.display_message("Login successful! Welcome.")

    def display_login_failure(self):
        """Warn about failed credentials."""
        self.display_error("Invalid email or password.")

===============================================================================
    ./app/views/base_view.py
===============================================================================
# app/views/base_view.py
"""
Base class for all views in the application.
Provides common display methods and input validation for CLI interaction.
"""

import re
from datetime import datetime


class BaseView:
    """Provides common display methods and input validation for CLI."""

    def display_message(self, message: str):
        """Display a simple text message."""
        print(f"\n{message}")

    def display_error(self, message: str):
        """Display an error message formatted for visibility."""
        print(f"\n[ERROR] {message}")

    def ask_input(self, prompt: str) -> str:
        """Helper to get user input."""
        return input(f"{prompt}: ").strip()

    def validate_email(self, email: str) -> bool:
        """Check if the email format is valid."""
        pattern = r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$"
        if re.match(pattern, email):
            return True
        self.display_error("Invalid email format (ex: name@domain.com).")
        return False

    def validate_amount(self, amount: str) -> bool:
        """Check if the amount is a positive number."""
        try:
            val = float(amount)
            if val >= 0:
                return True
            self.display_error("Amount must be a positive value.")
        except ValueError:
            self.display_error("Amount must be a numeric value.")
        return False

    def validate_date(self, date_str: str) -> bool:
        """Check if the date format is valid (DD-MM-YYYY)."""
        try:
            datetime.strptime(date_str, "%d-%m-%Y")
            return True
        except ValueError:
            self.display_error("Invalid date format. Please use DD-MM-YYYY.")
            return False

===============================================================================
    ./app/views/client_view.py
===============================================================================
# app/views/client_view.py
"""
View for Client related interactions.
"""
from app.views.base_view import BaseView


class ClientView(BaseView):
    """Handles client display and inputs."""

    def display_clients(self, clients: list):
        """Print the list of all clients."""
        print("\n=== Clients List ===")
        if not clients:
            print("No clients found.")
            return
        for client in clients:
            print(
                f"ID: {client.id} | Name: {client.full_name} | "
                f"Email: {client.email} | Company: {client.company_name} | "
                f"Last Contact: {client.last_contact}"
            )

    def ask_client_details(self) -> dict:
        """Prompt user for new client information."""
        print("\n=== Add New Client ===")
        return {
            "full_name": self.ask_input("Full Name"),
            "email": self.ask_input("Email"),
            "phone": self.ask_input("Phone"),
            "company_name": self.ask_input("Company Name"),
            "last_contact": self.ask_input(
                "Last Contact Date (YYYY-MM-DD HH:MM:SS) "
                "[Leave empty for now]"
            )
        }

===============================================================================
    ./app/views/contract_view.py
===============================================================================
# app/views/contract_view.py
"""
View for Contract related interactions.
"""
from app.views.base_view import BaseView


class ContractView(BaseView):
    """Handles contract display and inputs."""

    def display_contracts(self, contracts: list):
        """Print the list of all contracts."""
        print("\n=== Contracts List ===")
        if not contracts:
            print("No contracts found.")
            return
        for contract in contracts:
            status = "Signed" if contract.is_signed else "Not Signed"
            print(
                f"ID: {contract.id} | Client: {contract.client.full_name} | "
                f"Sales Contact: {contract.sales_contact.full_name} | "
                f"Total: {contract.total_amount} | Status: {status}"
            )

===============================================================================
    ./app/views/employee_view.py
===============================================================================
# app/views/employee_view.py
"""
View for Employee related interactions.
"""
from app.views.base_view import BaseView


class EmployeeView(BaseView):
    """Handles employee display and inputs."""

    def display_employees(self, employees: list):
        """Print the list of all employees."""
        print("\n=== Employees List ===")
        if not employees:
            print("No employees found.")
            return
        for emp in employees:
            dept_name = emp.department.name if emp.department else "N/A"
            print(
                f"ID: {emp.id} | No: {emp.employee_number} | "
                f"Name: {emp.full_name} | Email: {emp.email} | "
                f"Dept: {dept_name}"
            )

    def ask_employee_details(self) -> dict:
        """Prompt user for new employee information."""
        print("\n=== Add New Employee ===")

        full_name = self.ask_input("Full Name")

        while True:
            email = self.ask_input("Email")
            if self.validate_email(email):
                break

        password = self.ask_input("Password")
        employee_number = self.ask_input("Employee Number")
        department_id = self.ask_input(
            "Department ID (1: Sales, 2: Support, 3: Management)"
        )

        return {
            "full_name": full_name,
            "email": email,
            "password": password,
            "employee_number": employee_number,
            "department_id": int(department_id) if department_id.isdigit() else 0
        }

    def ask_update_details(self) -> dict:
        """Prompt user for employee updates (all fields optional)."""
        print("\n=== Update Employee (Leave blank to keep current value) ===")

        full_name = self.ask_input("New Full Name (optional)")
        email = self.ask_input("New Email (optional)")
        password = self.ask_input("New Password (optional)")
        dept_id = self.ask_input("New Dept ID (optional)")

        details = {}
        if full_name:
            details["full_name"] = full_name
        if email:
            details["email"] = email
        if password:
            details["password"] = password
        if dept_id:
            details["department_id"] = int(dept_id) if dept_id.isdigit() else 0

        return details

===============================================================================
    ./app/views/event_view.py
===============================================================================
# app/views/event_view.py
"""
View for Event related interactions.
"""
from app.views.base_view import BaseView


class EventView(BaseView):
    """Handles event display and inputs."""

    def display_events(self, events: list):
        """Print the list of all events."""
        print("\n=== Events List ===")
        if not events:
            print("No events found.")
            return
        for event in events:
            support = (
                event.support_contact.full_name
                if event.support_contact
                else "TBD"
            )
            print(
                f"ID: {event.id} | Name: {event.name} | "
                f"From: {event.event_date_start} To: {event.event_date_end} | "
                f"Support: {support}"
            )

===============================================================================
    ./app/views/main_menu_view.py
===============================================================================
# app/views/main_menu_view.py
"""
Main menu view for the CRM application.
Adapts displayed options based on user department.
"""

from app.views.base_view import BaseView


class MainMenuView(BaseView):
    """Controller view for the main menu."""

    def display_menu(self, department: str):
        """Print the main menu options according to department."""
        print(f"\n=== Epic Events CRM - {department} Menu ===")
        print("1. List all clients")
        print("2. List all contracts")
        print("3. List all events")

        if department == "MANAGEMENT":
            print("4. List all employees")
            print("5. Create new employee")
            print("6. Update an employee")
            print("7. Create new contract")
            print("8. Update a contract")
            print("9. Assign support to an event")
            print("10. List events without support")
        elif department == "SALES":
            print("20. Create new client")
            print("21. Update a client")
            print("22. Update a contract")
            print("23. List unsigned contracts")
            print("24. List unpaid contracts")
            print("25. Create new event")
        elif department == "SUPPORT":
            print("30. List my events")
            print("31. Update my events")

        print("0. Logout and Exit")

    def ask_menu_option(self) -> str:
        """Ask the user for a menu option."""
        return input("\nSelect an option: ").strip()

===============================================================================
    ./check_auth.py
===============================================================================
# check_auth.py
from app.utils.auth import hash_password, verify_password

password_to_test = "admin123"
# Le hash exact que vous avez mis dans le SQL
sql_hash = "$argon2id$v=19$m=65536,t=3,p=4$7Y5Wp8W1S6lF6z1N2q9Q5w$O7N8/v5J8J8"

# 1. Test de vrification
is_valid = verify_password(password_to_test, sql_hash)
print(f"Match SQL hash: {is_valid}")

# 2. Test de gnration
new_hash = hash_password(password_to_test)
print(f"New hash generated: {new_hash}")
print(f"Match new hash: {verify_password(password_to_test, new_hash)}")

===============================================================================
    ./config/config.py
===============================================================================
# config/config.py
import os
from dotenv import load_dotenv

# Load variables from .env file
load_dotenv()


class Config:
    """Configuration loader for environment variables."""
    DB_USER = os.getenv("DB_USER")
    DB_PASSWORD = os.getenv("DB_PASSWORD")
    DB_HOST = os.getenv("DB_HOST")
    DB_PORT = os.getenv("DB_PORT")
    DB_NAME = os.getenv("DB_NAME")
    SECRET_KEY = os.getenv("SECRET_KEY")
    SENTRY_DSN = os.getenv("SENTRY_DSN")

    @classmethod
    def get_db_url(cls):
        """Return formatted SQLAlchemy database URL."""
        return (
            f"mysql+mysqlconnector://{cls.DB_USER}:{cls.DB_PASSWORD}@"
            f"{cls.DB_HOST}:{cls.DB_PORT}/{cls.DB_NAME}"
        )

===============================================================================
    ./init_db.py
===============================================================================
# init_db.py
from sqlalchemy import create_engine
from app.models import Base
from config.config import Config


def create_tables():
    """
    Creates all database tables defined in the models.
    """
    engine = create_engine(Config.get_db_url())

    print("Connecting to the database...")
    try:
        # Create all tables stored in the metadata
        Base.metadata.create_all(engine)
        print("Success: All tables created successfully.")
    except Exception as e:
        print(f"Error during table creation: {e}")


if __name__ == "__main__":
    create_tables()

===============================================================================
    ./main.py
===============================================================================
# main.py
"""
Entry point for the Epic Events CRM application.
Manages the main loop and coordinate between controllers and views.
"""

from datetime import datetime

import sentry_sdk
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from config.config import Config

from app.repositories.employee_repository import EmployeeRepository
from app.repositories.client_repository import ClientRepository
from app.repositories.contract_repository import ContractRepository
from app.repositories.event_repository import EventRepository

from app.controllers.auth_controller import AuthController
from app.controllers.client_controller import ClientController
from app.controllers.contract_controller import ContractController
from app.controllers.event_controller import EventController
from app.controllers.employee_controller import EmployeeController

from app.views.auth_view import AuthView
from app.views.main_menu_view import MainMenuView
from app.views.client_view import ClientView
from app.views.contract_view import ContractView
from app.views.event_view import EventView
from app.views.employee_view import EmployeeView

# Initialize Sentry
sentry_sdk.init(
    dsn=Config.SENTRY_DSN,
    # Set the environment (default to development if not specified in Config)
    environment=getattr(Config, "ENVIRONMENT", "development"),
    traces_sample_rate=1.0,
    profiles_sample_rate=1.0,
)


def main():
    """Main application execution logic."""
    try:
        # Database Setup
        engine = create_engine(Config.get_db_url())
        session_factory = sessionmaker(bind=engine)
        session = session_factory()

        # Initialize Repositories
        emp_repo = EmployeeRepository(session)
        client_repo = ClientRepository(session)
        contract_repo = ContractRepository(session)
        event_repo = EventRepository(session)

        # Initialize Controllers
        auth_ctrl = AuthController(emp_repo)
        client_ctrl = ClientController(client_repo, auth_ctrl)
        contract_ctrl = ContractController(contract_repo, auth_ctrl)
        event_ctrl = EventController(event_repo, auth_ctrl)
        emp_ctrl = EmployeeController(emp_repo, auth_ctrl)

        # Initialize Views
        auth_view = AuthView()
        menu_view = MainMenuView()
        client_view = ClientView()
        contract_view = ContractView()
        event_view = EventView()
        emp_view = EmployeeView()

        # 1. Authentication Check
        user_data = auth_ctrl.get_logged_in_user()
        if not user_data:
            email, password = auth_view.ask_login_details()
            user_data = auth_ctrl.login(email, password)
            if not user_data:
                auth_view.display_login_failure()
                return

        auth_view.display_login_success()

        # 2. Application Loop
        while True:

            menu_view.display_menu(user_data["department"])
            choice = menu_view.ask_menu_option()

            if choice == "1":
                data = client_ctrl.list_all_clients(user_data=user_data)
                client_view.display_clients(data)

            elif choice == "2":
                data = contract_ctrl.list_all_contracts(user_data=user_data)
                contract_view.display_contracts(data)

            elif choice == "3":
                data = event_ctrl.list_all_events(user_data=user_data)
                event_view.display_events(data)

            elif choice == "4":
                if user_data["department"] != "MANAGEMENT":
                    print("Invalid option. Please try again.")
                    continue
                data = emp_ctrl.list_all_employees(user_data=user_data)
                emp_view.display_employees(data)

            elif choice == "5":
                if user_data["department"] != "MANAGEMENT":
                    print("Invalid option. Please try again.")
                    continue
                details = emp_view.ask_employee_details()
                emp_ctrl.create_employee(
                    user_data=user_data,
                    employee_data=details
                )

            elif choice == "6":
                if user_data["department"] != "MANAGEMENT":
                    print("Invalid option. Please try again.")
                    continue
                emp_id = emp_view.ask_input("Enter Employee ID to update")
                if emp_id.isdigit():
                    updates = emp_view.ask_update_details()
                    emp_ctrl.update_employee(
                        user_data=user_data,
                        emp_id=int(emp_id),
                        update_data=updates
                    )

            elif choice == "7":
                if user_data["department"] != "MANAGEMENT":
                    print("Invalid option. Please try again.")
                    continue
                details = contract_view.ask_contract_details()
                contract_ctrl.create_contract(
                    user_data=user_data,
                    contract_data=details
                )

            elif choice == "8":
                if user_data["department"] != "MANAGEMENT":
                    print("Invalid option. Please try again.")
                    continue
                contract_id = contract_view.ask_input(
                    "Enter Contract ID to update"
                )
                if contract_id.isdigit():
                    updates = contract_view.ask_contract_update_details()
                    contract_ctrl.update_contract(
                        user_data=user_data,
                        contract_id=int(contract_id),
                        updates=updates
                    )

            elif choice == "9":
                if user_data["department"] != "MANAGEMENT":
                    print("Invalid option. Please try again.")
                    continue
                event_id = event_view.ask_input(
                    "Enter Event ID to assign support"
                )
                support_id = event_view.ask_input(
                    "Enter Support Employee ID"
                )
                if event_id.isdigit() and support_id.isdigit():
                    updates = {"support_contact_id": int(support_id)}
                    event_ctrl.update_event(
                        user_data=user_data,
                        event_id=int(event_id),
                        updates=updates
                    )

            elif choice == "10":
                if user_data["department"] != "MANAGEMENT":
                    print("Invalid option. Please try again.")
                    continue
                events = event_ctrl.list_all_events(
                    user_data=user_data
                ) or []
                no_support = [
                    event for event in events
                    if not event.support_contact_id
                ]
                event_view.display_events(no_support)

            elif choice == "20":
                if user_data["department"] != "SALES":
                    print("Invalid option. Please try again.")
                    continue
                details = client_view.ask_client_details()
                last_contact = details.get("last_contact", "").strip()
                if not last_contact:
                    details.pop("last_contact", None)
                else:
                    try:
                        details["last_contact"] = datetime.strptime(
                            last_contact,
                            "%Y-%m-%d %H:%M:%S",
                        )
                    except ValueError:
                        details.pop("last_contact", None)
                client_ctrl.create_client(
                    user_data=user_data,
                    client_data=details
                )

            elif choice == "21":
                if user_data["department"] != "SALES":
                    print("Invalid option. Please try again.")
                    continue
                client_id = client_view.ask_input(
                    "Enter Client ID to update"
                )
                if client_id.isdigit():
                    updates = client_view.ask_update_details()
                    client_ctrl.update_client(
                        user_data=user_data,
                        client_id=int(client_id),
                        updates=updates
                    )

            elif choice == "22":
                if user_data["department"] != "SALES":
                    print("Invalid option. Please try again.")
                    continue
                contract_id = contract_view.ask_input(
                    "Enter Contract ID to update"
                )
                if contract_id.isdigit():
                    updates = contract_view.ask_contract_update_details()
                    contract_ctrl.update_contract(
                        user_data=user_data,
                        contract_id=int(contract_id),
                        updates=updates
                    )

            elif choice == "23":
                if user_data["department"] != "SALES":
                    print("Invalid option. Please try again.")
                    continue
                contracts = contract_ctrl.list_all_contracts(
                    user_data=user_data
                ) or []
                unsigned = [
                    contract for contract in contracts
                    if not contract.is_signed
                ]
                contract_view.display_contracts(unsigned)

            elif choice == "24":
                if user_data["department"] != "SALES":
                    print("Invalid option. Please try again.")
                    continue
                contracts = contract_ctrl.list_all_contracts(
                    user_data=user_data
                ) or []
                unpaid = [
                    contract for contract in contracts
                    if contract.amount_due > 0
                ]
                contract_view.display_contracts(unpaid)

            elif choice == "25":
                if user_data["department"] != "SALES":
                    print("Invalid option. Please try again.")
                    continue
                details = event_view.ask_event_details()
                event_ctrl.create_event(
                    user_data=user_data,
                    event_data=details
                )

            elif choice == "30":
                if user_data["department"] != "SUPPORT":
                    print("Invalid option. Please try again.")
                    continue
                events = event_ctrl.list_all_events(
                    user_data=user_data
                ) or []
                my_events = [
                    event for event in events
                    if event.support_contact_id == user_data["id"]
                ]
                event_view.display_events(my_events)

            elif choice == "31":
                if user_data["department"] != "SUPPORT":
                    print("Invalid option. Please try again.")
                    continue
                event_id = event_view.ask_input(
                    "Enter Event ID to update"
                )
                if event_id.isdigit():
                    updates = event_view.ask_event_update_details()
                    event_ctrl.update_event(
                        user_data=user_data,
                        event_id=int(event_id),
                        updates=updates,
                    )

            elif choice == "0":
                auth_ctrl.logout()
                print("Goodbye!")
                break

            else:
                print("Invalid option. Please try again.")

    except Exception as e:
        sentry_sdk.capture_exception(e)
        print(f"A fatal error occurred: {e}")
        raise e


if __name__ == "__main__":
    main()

===============================================================================
    ./tests/__init__.py
===============================================================================


===============================================================================
    ./tests/conftest.py
===============================================================================
# tests/conftest.py
"""
Pytest configuration and global fixtures.
Provides database engine and session management for tests.
Initializes Sentry for error tracking during tests.
"""

import os
from dotenv import load_dotenv
import pytest
import sentry_sdk
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker
from config.config import Config
from app.models import Base
from app.utils.token_storage import TOKEN_FILE

load_dotenv()


@pytest.fixture(scope="session", autouse=True)
def init_sentry():
    sentry_sdk.init(
        dsn=Config.SENTRY_DSN,
        environment="testing",
        traces_sample_rate=1.0
    )


@pytest.fixture(scope="session")
def db_engine():
    engine = create_engine(Config.get_db_url())
    Base.metadata.drop_all(engine)
    Base.metadata.create_all(engine)
    yield engine
    engine.dispose()


@pytest.fixture(scope="function")
def db_session(db_engine):
    """
    Provide a fully clean database for each test.
    Hard reset using TRUNCATE and AUTO_INCREMENT reset.
    Also clears TOKEN_FILE to avoid auth leakage.
    """
    # Remove persisted token between tests
    if os.path.exists(TOKEN_FILE):
        os.remove(TOKEN_FILE)

    connection = db_engine.connect()
    Session = sessionmaker(bind=connection)
    session = Session()

    session.execute(text("SET FOREIGN_KEY_CHECKS=0;"))

    tables = [
        "event",
        "contract",
        "client",
        "employee",
        "department",
    ]

    for table in tables:
        session.execute(text(f"TRUNCATE TABLE {table};"))

    session.execute(text("SET FOREIGN_KEY_CHECKS=1;"))
    session.commit()

    yield session

    session.close()
    connection.close()


===============================================================================
    ./tests/test_auth_utils.py
===============================================================================
# tests/test_auth_utils.py
"""
Unit tests for authentication utilities.

Tests included:
- test_password_hashing: Verify Argon2 hashing and verification.
- test_password_verification_fail: Ensure incorrect passwords are rejected.
- test_token_lifecycle: Save, retrieve, and delete token from storage.
"""

import os
from app.utils.auth import hash_password, verify_password
from app.utils.token_storage import save_token, get_token, delete_token, TOKEN_FILE


def test_password_hashing():
    """Test that hashing and verification work correctly with Argon2."""
    raw_password = "secure_password_2026"
    hashed = hash_password(raw_password)

    assert hashed != raw_password
    assert verify_password(hashed, raw_password) is True


def test_password_verification_fail():
    """Test that verification fails with a wrong password."""
    hashed = hash_password("correct_one")
    assert verify_password("wrong_one", hashed) is False


def test_token_lifecycle():
    """Test the full lifecycle: saving, getting, and deleting a token."""
    # Ensure a clean state
    if os.path.exists(TOKEN_FILE):
        os.remove(TOKEN_FILE)

    test_token = "abc.123.jwt.token"

    # Save
    save_token(test_token)
    assert os.path.exists(TOKEN_FILE)

    # Get
    retrieved = get_token()
    assert retrieved == test_token

    # Delete
    delete_token()
    assert not os.path.exists(TOKEN_FILE)
    assert get_token() is None

===============================================================================
    ./tests/test_business_validation.py
===============================================================================
# tests/test_business_validation.py
"""
Functional tests for business data validation and constraints.

Tests included:
- test_contract_amounts_logic: Verify remaining amount <= total amount.
- test_event_date_coherence: Verify event end date is after start date.
- test_attendees_positive: Verify number of attendees is not negative.
"""

import uuid
import pytest
from datetime import datetime, timedelta
from app.models.contract import Contract
from app.models.event import Event
from app.models.client import Client
from app.models.employee import Employee
from app.models.department import Department
from app.repositories.base_repository import BaseRepository


@pytest.fixture
def validation_setup(db_session):
    """Setup minimal data for validation tests."""
    dept_repo = BaseRepository(db_session, Department)
    dept = dept_repo.add(Department(name=f"VAL_{uuid.uuid4().hex[:6]}"))

    sales = Employee(
        full_name="Sales", email=f"s_{uuid.uuid4().hex[:6]}@test.com",
        password="h", employee_number=f"S{uuid.uuid4().hex[:4]}",
        department_id=dept.id
    )
    db_session.add(sales)
    db_session.commit()

    client = Client(
        full_name="C", email=f"c_{uuid.uuid4().hex[:6]}@test.com",
        phone="0", company_name="C", sales_contact_id=sales.id
    )
    db_session.add(client)
    db_session.commit()

    return {"sales": sales, "client": client}


def test_contract_amounts_logic(db_session, validation_setup):
    """Verify state of a contract with logically inconsistent amounts."""
    s = validation_setup
    contract = Contract(
        total_amount=100.00,
        remaining_amount=150.00,
        is_signed=True,
        client_id=s["client"].id,
        sales_contact_id=s["sales"].id
    )
    # This highlights that the model currently accepts the inconsistency
    assert contract.remaining_amount > contract.total_amount


def test_event_date_coherence(db_session, validation_setup):
    """Verify state of an event with non-chronological dates."""
    s = validation_setup
    start = datetime.now()
    end = start - timedelta(hours=1)

    # Create contract for the event
    contract = Contract(
        total_amount=100, remaining_amount=0, is_signed=True,
        client_id=s["client"].id, sales_contact_id=s["sales"].id
    )
    db_session.add(contract)
    db_session.commit()

    event = Event(
        name="Invalid Date Event",
        event_date_start=start,
        event_date_end=end,
        location="Paris",
        attendees=10,
        notes="Testing",
        client_id=s["client"].id,
        contract_id=contract.id
    )
    assert event.event_date_end < event.event_date_start


def test_attendees_positive(db_session, validation_setup):
    """Verify state of an event with negative attendees."""
    s = validation_setup
    event = Event(
        name="Negative Attendees",
        event_date_start=datetime.now(),
        event_date_end=datetime.now(),
        location="L",
        attendees=-5,
        notes="N",
        client_id=s["client"].id,
        contract_id=1 # Using dummy ID for unit check
    )
    assert event.attendees < 0

===============================================================================
    ./tests/test_functional_auth.py
===============================================================================
# tests/test_robustness_edge_cases.py
"""
Integration tests for edge cases, permission denials, and coverage optimization.

List of tests:
- test_auth_controller_full_flow: Covers logout and failed login logic.
- test_auth_login_success: Covers successful login and session management.
- test_client_controller_unauthorized: Covers permission denial branches.
- test_contract_controller_ownership: Covers ownership and not found logic.
- test_event_controller_complex_rules: Covers unsigned contracts and support.
- test_controllers_list_methods: Covers list_all methods for all controllers.
- test_employee_management_denials: Covers admin-only creation/update logic.
- test_repository_integrity_failure: Covers DB constraints and rollbacks.
- test_repository_delete_logic: Covers the delete method in BaseRepository.
- test_repository_specialized_filters: Covers specific repository lookups.
- test_models_string_representation: Covers __repr__ methods for all models.
"""

from datetime import datetime
import pytest
from sqlalchemy.exc import IntegrityError
from app.controllers.auth_controller import AuthController
from app.controllers.client_controller import ClientController
from app.controllers.contract_controller import ContractController
from app.controllers.event_controller import EventController
from app.controllers.employee_controller import EmployeeController
from app.repositories.employee_repository import EmployeeRepository
from app.repositories.client_repository import ClientRepository
from app.repositories.contract_repository import ContractRepository
from app.repositories.event_repository import EventRepository
from app.models.employee import Employee
from app.models.client import Client
from app.models.contract import Contract
from app.models.event import Event
from app.models.department import Department
from app.utils.auth import hash_password


@pytest.fixture
def auth_ctrl(db_session):
    """Fixture for AuthController."""
    return AuthController(EmployeeRepository(db_session))


def test_auth_controller_full_flow(auth_ctrl):
    """Covers logout and failed login logic."""
    auth_ctrl.logout()
    assert auth_ctrl.current_user_data is None
    assert auth_ctrl.login("ghost@missing.com", "password") is None
    assert auth_ctrl.check_user_permission("read") is False


def test_auth_login_success(db_session, auth_ctrl):
    """Covers successful login and user data structure."""
    dept = Department(name="AUTH_DEPT")
    db_session.add(dept)
    db_session.flush()

    pwd = hash_password("secret123")
    emp = Employee(
        full_name="Auth Success",
        email="success@test.com",
        password=pwd,
        employee_number="EMP_OK",
        department_id=dept.id
    )
    db_session.add(emp)
    db_session.commit()

    user = auth_ctrl.login("success@test.com", "secret123")
    assert user is not None
    # AuthController.login does not return 'email' in user_data dict
    assert user["full_name"] == "Auth Success"
    assert user["department"] == "AUTH_DEPT"


def test_client_controller_unauthorized(db_session, auth_ctrl):
    """Covers permission denial branches using manual session injection."""
    client_repo = ClientRepository(db_session)
    ctrl = ClientController(client_repo, auth_ctrl)

    # Support cannot create clients
    auth_ctrl.current_user_data = {"id": 1, "department": "SUPPORT"}
    assert ctrl.create_client({"full_name": "Fail", "phone": "123"}) is None

    # Sales cannot update unknown clients or others' clients
    auth_ctrl.current_user_data = {"id": 2, "department": "SALES"}
    assert ctrl.update_client(9999, {"full_name": "New"}) is None


def test_contract_controller_ownership(db_session, auth_ctrl):
    """Covers ownership and not found logic."""
    contract_repo = ContractRepository(db_session)
    ctrl = ContractController(contract_repo, auth_ctrl)

    sales_dept = Department(name="SALES")
    db_session.add(sales_dept)
    db_session.flush()

    emp5 = Employee(
        id=5, full_name="S1", email="s5@t.com", password="p",
        employee_number="E5", department_id=sales_dept.id
    )
    emp10 = Employee(
        id=10, full_name="S2", email="s10@t.com", password="p",
        employee_number="E10", department_id=sales_dept.id
    )
    db_session.add_all([emp5, emp10])
    db_session.flush()

    cl = Client(full_name="X", email="x@t.com", phone="1",
                company_name="X", sales_contact_id=5)
    db_session.add(cl)
    db_session.flush()

    c = Contract(id=102, sales_contact_id=10, client_id=cl.id,
                 total_amount=1000, remaining_amount=1000)
    db_session.add(c)
    db_session.flush()

    # User 5 tries to update user 10's contract
    auth_ctrl.current_user_data = {"id": 5, "department": "SALES"}
    assert ctrl.update_contract(102, {"total_amount": 2000}) is None


def test_event_controller_complex_rules(db_session, auth_ctrl):
    """Covers unsigned contracts and support assigned logic."""
    event_repo = EventRepository(db_session)
    ctrl = EventController(event_repo, auth_ctrl)

    s_dept = Department(name="SALES")
    sup_dept = Department(name="SUPPORT")
    db_session.add_all([s_dept, sup_dept])
    db_session.flush()

    s_emp = Employee(id=20, full_name="S1", email="s20@t.com", password="p",
                     employee_number="E20", department_id=s_dept.id)
    sup_emp = Employee(id=21, full_name="Sup1", email="s21@t.com", password="p",
                       employee_number="E21", department_id=sup_dept.id)
    db_session.add_all([s_emp, sup_emp])
    db_session.flush()

    cl = Client(full_name="Y", email="y@t.com", phone="2",
                company_name="Y", sales_contact_id=20)
    db_session.add(cl)
    db_session.flush()

    c = Contract(id=202, sales_contact_id=20, is_signed=False,
                 total_amount=0, remaining_amount=0, client_id=cl.id)
    db_session.add(c)
    db_session.flush()

    # Cannot create event for unsigned contract
    auth_ctrl.current_user_data = {"id": 20, "department": "SALES"}
    assert ctrl.create_event({"name": "X"}, c) is None

    ev = Event(id=302, name="Ev", location="P", attendees=5, notes="N",
               client_id=cl.id, contract_id=c.id, support_contact_id=sup_emp.id,
               event_date_start=datetime.now(), event_date_end=datetime.now())
    db_session.add(ev)
    db_session.flush()

    # Different support user cannot update
    auth_ctrl.current_user_data = {"id": 99, "department": "SUPPORT"}
    assert ctrl.update_event(302, {"notes": "hack"}) is None


def test_controllers_list_methods(db_session, auth_ctrl):
    """Covers list_all methods."""
    auth_ctrl.current_user_data = {"id": 1, "department": "MANAGEMENT"}

    cl_ctrl = ClientController(ClientRepository(db_session), auth_ctrl)
    assert isinstance(cl_ctrl.list_all_clients(), list)

    co_ctrl = ContractController(ContractRepository(db_session), auth_ctrl)
    assert co_ctrl.list_all_contracts() is not None

    ev_ctrl = EventController(EventRepository(db_session), auth_ctrl)
    assert ev_ctrl.list_all_events() is not None


def test_employee_management_denials(db_session, auth_ctrl):
    """Covers admin-only creation logic."""
    emp_repo = EmployeeRepository(db_session)
    ctrl = EmployeeController(emp_repo, auth_ctrl)
    auth_ctrl.current_user_data = {"department": "SALES"}
    assert ctrl.create_employee({"full_name": "Ghost"}) is None


def test_repository_integrity_failure(db_session):
    """Covers BaseRepository IntegrityError handling."""
    repo = ClientRepository(db_session)
    c1 = Client(full_name="A", email="dup@t.com", phone="1", company_name="C")
    db_session.add(c1)
    db_session.commit()

    c2 = Client(full_name="B", email="dup@t.com", phone="2", company_name="C")
    with pytest.raises(IntegrityError):
        repo.add(c2)


def test_repository_delete_logic(db_session):
    """Covers the delete method in BaseRepository."""
    repo = ClientRepository(db_session)
    cl = Client(full_name="Del", email="del@t.com", phone="0", company_name="D")
    db_session.add(cl)
    db_session.flush()
    repo.delete(cl)
    assert repo.get_by_id(cl.id) is None


def test_repository_specialized_filters(db_session):
    """Covers specific filter methods in repositories."""
    e_repo = EmployeeRepository(db_session)
    assert e_repo.get_by_email("none@t.com") is None

    c_repo = ContractRepository(db_session)
    assert isinstance(c_repo.get_unsigned_contracts(), list)

    ev_repo = EventRepository(db_session)
    assert isinstance(ev_repo.get_events_without_support(), list)


def test_models_string_representation():
    """Covers __repr__ for all models."""
    assert "Client" in repr(Client(full_name="Test"))
    assert "Contract" in repr(Contract(id=1))
    assert "Event" in repr(Event(name="Party"))
    assert "Employee" in repr(Employee(full_name="T", email="t@t.com"))

===============================================================================
    ./tests/test_functional_management.py
===============================================================================
# tests/test_functional_management.py
"""
Functional tests for Management (T12) operations.

Tests included:
- test_list_employees_as_management: Success for authorized users.
- test_create_employee_as_management: Success for authorized users.
- test_create_employee_as_sales_denied: Access control check.
- test_list_contracts_permission: Verify role-based contract access.
"""

import uuid
import pytest
from sqlalchemy import select
from app.controllers.employee_controller import EmployeeController
from app.controllers.contract_controller import ContractController
from app.controllers.auth_controller import AuthController
from app.repositories.employee_repository import EmployeeRepository
from app.repositories.contract_repository import ContractRepository
from app.models.department import Department
from app.repositories.base_repository import BaseRepository


@pytest.fixture
def management_suite(db_session):
    """Setup repositories and controllers with duplicate check."""
    dept_repo = BaseRepository(db_session, Department)
    emp_repo = EmployeeRepository(db_session)
    cont_repo = ContractRepository(db_session)
    auth_ctrl = AuthController(emp_repo)

    existing_dept = db_session.execute(
        select(Department).filter_by(name="MANAGEMENT")
    ).scalar_one_or_none()

    if existing_dept:
        test_dept = existing_dept
    else:
        test_dept = dept_repo.add(Department(name="MANAGEMENT"))

    emp_ctrl = EmployeeController(emp_repo, auth_ctrl)
    cont_ctrl = ContractController(cont_repo, auth_ctrl)

    return {
        "emp_ctrl": emp_ctrl,
        "cont_ctrl": cont_ctrl,
        "dept_id": test_dept.id
    }


def test_list_employees_as_management(management_suite):
    """Verify management can list employees."""
    ctrl = management_suite["emp_ctrl"]
    user_data = {"id": 1, "department": "MANAGEMENT"}

    result = ctrl.list_all_employees(user_data=user_data)
    assert isinstance(result, list)


def test_create_employee_as_management(management_suite):
    """Verify management can create a new employee."""
    ctrl = management_suite["emp_ctrl"]
    user_data = {"id": 1, "department": "MANAGEMENT"}

    email = f"manager_{uuid.uuid4().hex[:6]}@crm.com"
    emp_data = {
        "full_name": "New Manager",
        "email": email,
        "password": "securepassword",
        "employee_number": f"MGT_{uuid.uuid4().hex[:4]}",
        "department_id": management_suite["dept_id"]
    }

    new_emp = ctrl.create_employee(user_data=user_data, employee_data=emp_data)
    assert new_emp is not None
    assert new_emp.email == email


def test_create_employee_as_sales_denied(management_suite):
    """Verify sales role cannot create an employee."""
    ctrl = management_suite["emp_ctrl"]
    user_data = {"id": 2, "department": "SALES"}
    emp_data = {
        "full_name": "Unauthorized",
        "email": f"bad_{uuid.uuid4().hex[:4]}@crm.com",
        "password": "p",
        "employee_number": f"BAD_{uuid.uuid4().hex[:4]}",
        "department_id": management_suite["dept_id"]
    }

    result = ctrl.create_employee(user_data=user_data, employee_data=emp_data)
    assert result is None


def test_list_contracts_permission(management_suite):
    """Verify contract listing access for management."""
    ctrl = management_suite["cont_ctrl"]
    user_data = {"id": 1, "department": "MANAGEMENT"}

    result = ctrl.list_all_contracts(user_data=user_data)
    assert result is not None

===============================================================================
    ./tests/test_functional_permissions.py
===============================================================================
# tests/test_functional_permissions.py
"""
Functional tests for Role-Based Access Control (RBAC).

Tests included:
- test_management_can_create_employee: Verify high-level admin rights.
- test_sales_cannot_create_employee: Verify restriction for non-admin roles.
- test_sales_can_create_client: Verify role-specific creation rights.
- test_support_restrictions: Verify support agent cannot create contracts.
"""

import pytest
from app.controllers.auth_controller import AuthController
from app.repositories.employee_repository import EmployeeRepository


@pytest.fixture
def auth_controller(db_session):
    """Provides an AuthController instance."""
    return AuthController(EmployeeRepository(db_session))


def test_management_can_create_employee(auth_controller):
    """Verify Management role has administrative permissions."""
    auth_controller.current_user_data = {"department": "MANAGEMENT"}
    assert auth_controller.check_user_permission("create_employee") is True


def test_sales_cannot_create_employee(auth_controller):
    """Verify Sales role is restricted from administrative tasks."""
    auth_controller.current_user_data = {"department": "SALES"}
    assert auth_controller.check_user_permission("create_employee") is False


def test_sales_can_create_client(auth_controller):
    """Verify Sales role can perform their core business tasks."""
    auth_controller.current_user_data = {"department": "SALES"}
    assert auth_controller.check_user_permission("create_client") is True


def test_support_restrictions(auth_controller):
    """Verify Support role cannot perform Sales or Management tasks."""
    auth_controller.current_user_data = {"department": "SUPPORT"}
    # Can update events
    assert auth_controller.check_user_permission("update_event") is True
    # Cannot create contracts
    assert auth_controller.check_user_permission("create_contract") is False

===============================================================================
    ./tests/test_functional_sales.py
===============================================================================
# tests/test_functional_sales.py
"""
Functional tests for Sales (T13) operations.

List of tests:
- test_sales_can_create_client: Verify client creation and auto-assignment (6.8).
- test_support_cannot_create_client: Verify permission restriction for creation.
- test_sales_can_update_own_client: Success for assigned contact (6.9).
- test_sales_cannot_update_other_client: Denied for non-assigned contact.
- test_management_can_create_contract: Verify contract creation by management (6.10).
- test_sales_can_sign_own_contract: Verify sales can update their assigned
  contracts (6.11).
- test_sales_can_create_event_for_signed_contract: Success if signed and owner
  (6.12).
- test_sales_cannot_create_event_for_unsigned_contract: Denied if not signed
  (6.12).
- test_support_can_update_assigned_event: Verify support can update their event
  (6.13).
"""

import uuid
import pytest
from datetime import datetime, timedelta
from sqlalchemy import select
from app.controllers.client_controller import ClientController
from app.controllers.contract_controller import ContractController
from app.controllers.event_controller import EventController
from app.controllers.auth_controller import AuthController
from app.repositories.client_repository import ClientRepository
from app.repositories.contract_repository import ContractRepository
from app.repositories.event_repository import EventRepository
from app.repositories.employee_repository import EmployeeRepository
from app.models.department import Department
from app.models.employee import Employee
from app.models.client import Client
from app.models.contract import Contract
from app.models.event import Event
from app.repositories.base_repository import BaseRepository


@pytest.fixture
def sales_suite(db_session):
    """Setup repositories and controllers for sales tests."""
    dept_repo = BaseRepository(db_session, Department)
    emp_repo = EmployeeRepository(db_session)
    client_repo = ClientRepository(db_session)
    contract_repo = ContractRepository(db_session)
    event_repo = EventRepository(db_session)

    auth_ctrl = AuthController(emp_repo)
    client_ctrl = ClientController(client_repo, auth_ctrl)
    contract_ctrl = ContractController(contract_repo, auth_ctrl)
    event_ctrl = EventController(event_repo, auth_ctrl)

    # Setup departments
    for name in ["SALES", "MANAGEMENT", "SUPPORT"]:
        if not db_session.execute(
            select(Department).filter_by(name=name)
        ).scalar():
            dept_repo.add(Department(name=name))

    sales_dept = db_session.execute(
        select(Department).filter_by(name="SALES")
    ).scalar()
    mgmt_dept = db_session.execute(
        select(Department).filter_by(name="MANAGEMENT")
    ).scalar()
    supp_dept = db_session.execute(
        select(Department).filter_by(name="SUPPORT")
    ).scalar()

    # Employees
    unique_s1 = uuid.uuid4().hex[:4]
    s1 = emp_repo.add(Employee(
        full_name="Sales One", email=f"s1_{unique_s1}@crm.com",
        password="p", employee_number=f"S1_{unique_s1}",
        department_id=sales_dept.id
    ))

    unique_s2 = uuid.uuid4().hex[:4]
    s2 = emp_repo.add(Employee(
        full_name="Sales Two", email=f"s2_{unique_s2}@crm.com",
        password="p", employee_number=f"S2_{unique_s2}",
        department_id=sales_dept.id
    ))

    unique_m = uuid.uuid4().hex[:4]
    mgmt = emp_repo.add(Employee(
        full_name="Mgmt User", email=f"m1_{unique_m}@crm.com",
        password="p", employee_number=f"M1_{unique_m}",
        department_id=mgmt_dept.id
    ))

    unique_supp = uuid.uuid4().hex[:4]
    supp = emp_repo.add(Employee(
        full_name="Support User", email=f"supp_{unique_supp}@crm.com",
        password="p", employee_number=f"SUP_{unique_supp}",
        department_id=supp_dept.id
    ))

    # Seed baseline client/contract used by tests with hardcoded IDs
    baseline_client = client_repo.add(Client(
        full_name="Baseline Client",
        email=f"baseline_{uuid.uuid4().hex[:6]}@crm.com",
        phone="000",
        company_name="Baseline Corp",
        sales_contact_id=s1.id
    ))

    contract_repo.add(Contract(
        total_amount=1000,
        remaining_amount=1000,
        is_signed=True,
        client_id=baseline_client.id,
        sales_contact_id=s1.id
    ))

    return {
        "client_ctrl": client_ctrl,
        "contract_ctrl": contract_ctrl,
        "event_ctrl": event_ctrl,
        "sales_1": s1,
        "sales_2": s2,
        "mgmt_user": mgmt,
        "supp_user": supp
    }


def test_sales_can_create_client(sales_suite):
    """Verify that a SALES user can create a client with auto-assignment."""
    ctrl = sales_suite["client_ctrl"]
    user = sales_suite["sales_1"]
    user_data = {"id": user.id, "department": "SALES"}
    client_data = {
        "full_name": "Test Client Inc",
        "email": f"contact_{uuid.uuid4().hex[:6]}@client.com",
        "phone": "0102030405",
        "company_name": "Test Corp"
    }
    new_client = ctrl.create_client(user_data=user_data, client_data=client_data)
    assert new_client is not None
    assert new_client.sales_contact_id == user.id


def test_support_cannot_create_client(sales_suite):
    """Verify that a SUPPORT user cannot create a client."""
    ctrl = sales_suite["client_ctrl"]
    user_data = {"id": 999, "department": "SUPPORT"}
    client_data = {
        "full_name": "Forbidden",
        "email": "f@client.com",
        "phone": "0000",
        "company_name": "No Access"
    }
    result = ctrl.create_client(user_data=user_data, client_data=client_data)
    assert result is None


def test_sales_can_update_own_client(sales_suite):
    """Verify sales can update their assigned client."""
    ctrl = sales_suite["client_ctrl"]
    s1 = sales_suite["sales_1"]
    user_data = {"id": s1.id, "department": "SALES"}

    client_data = {
        "full_name": "Owned Client",
        "email": f"c_{uuid.uuid4().hex[:4]}@c.com",
        "phone": "12345",
        "company_name": "Own Corp",
        "sales_contact_id": s1.id
    }
    client = ctrl.create_client(user_data=user_data, client_data=client_data)

    updated = ctrl.update_client(
        user_data=user_data,
        client_id=client.id,
        updates={"phone": "99999"}
    )
    assert updated is not None
    assert updated.phone == "99999"


def test_sales_cannot_update_other_client(sales_suite):
    """Verify sales cannot update a client assigned to someone else."""
    ctrl = sales_suite["client_ctrl"]
    s1 = sales_suite["sales_1"]
    s2 = sales_suite["sales_2"]

    client_data = {
        "full_name": "S1 Client",
        "email": f"c_{uuid.uuid4().hex[:4]}@c.com",
        "phone": "123",
        "company_name": "S1 Corp",
        "sales_contact_id": s1.id
    }
    client = ctrl.create_client(
        user_data={"id": s1.id, "department": "SALES"},
        client_data=client_data
    )

    result = ctrl.update_client(
        user_data={"id": s2.id, "department": "SALES"},
        client_id=client.id,
        updates={"phone": "000"}
    )
    assert result is None


def test_management_can_create_contract(sales_suite):
    """Verify that MANAGEMENT can create a contract for a client."""
    client_ctrl = sales_suite["client_ctrl"]
    contract_ctrl = sales_suite["contract_ctrl"]
    sales_user = sales_suite["sales_1"]
    mgmt_user = sales_suite["mgmt_user"]

    client = client_ctrl.create_client(
        user_data={"id": sales_user.id, "department": "SALES"},
        client_data={
            "full_name": "Contract Client",
            "email": f"c_{uuid.uuid4().hex[:4]}@c.com",
            "phone": "0600000000",
            "company_name": "Contract Corp"
        }
    )

    contract_data = {
        "total_amount": 1000.00,
        "remaining_amount": 1000.00,
        "is_signed": False,
        "client_id": client.id,
        "sales_contact_id": sales_user.id
    }

    new_contract = contract_ctrl.create_contract(
        user_data={"id": mgmt_user.id, "department": "MANAGEMENT"},
        contract_data=contract_data
    )

    assert new_contract is not None
    assert float(new_contract.total_amount) == 1000.00


def test_sales_can_sign_own_contract(sales_suite):
    """Verify that sales can sign a contract assigned to them."""
    client_ctrl = sales_suite["client_ctrl"]
    contract_ctrl = sales_suite["contract_ctrl"]
    sales_user = sales_suite["sales_1"]
    user_data = {"id": sales_user.id, "department": "SALES"}

    client = client_ctrl.create_client(
        user_data=user_data,
        client_data={
            "full_name": "Sign Client",
            "email": f"c_{uuid.uuid4().hex[:4]}@c.com",
            "phone": "0611111111",
            "company_name": "Sign Corp"
        }
    )

    contract = contract_ctrl.repository.add(Contract(
        total_amount=500,
        remaining_amount=500,
        is_signed=False,
        client_id=client.id,
        sales_contact_id=sales_user.id
    ))

    updated = contract_ctrl.update_contract(
        user_data=user_data,
        contract_id=contract.id,
        updates={"is_signed": True}
    )

    assert updated is not None
    assert updated.is_signed is True


def test_sales_can_create_event_for_signed_contract(sales_suite):
    """Verify event creation works for a signed contract (6.12)."""
    event_ctrl = sales_suite["event_ctrl"]
    contract_ctrl = sales_suite["contract_ctrl"]
    sales_user = sales_suite["sales_1"]
    user_data = {"id": sales_user.id, "department": "SALES"}

    client = sales_suite["client_ctrl"].create_client(
        user_data=user_data,
        client_data={
            "full_name": "Event Client",
            "email": f"e_{uuid.uuid4().hex[:4]}@c.com",
            "phone": "06",
            "company_name": "Event Corp"
        }
    )

    contract = contract_ctrl.repository.add(Contract(
        total_amount=1000,
        remaining_amount=1000,
        is_signed=True,
        client_id=client.id,
        sales_contact_id=sales_user.id
    ))

    event_data = {
        "name": "Launch Party",
        "event_date_start": datetime.now(),
        "event_date_end": datetime.now() + timedelta(hours=2),
        "location": "Paris",
        "attendees": 50,
        "notes": "Test notes",
        "client_id": client.id,
        "contract_id": contract.id
    }

    event = event_ctrl.create_event(
        user_data=user_data,
        event_data=event_data,
        contract=contract
    )
    assert event is not None
    assert event.name == "Launch Party"


def test_sales_cannot_create_event_for_unsigned_contract(sales_suite):
    """Verify event creation is blocked if contract is not signed (6.12)."""
    event_ctrl = sales_suite["event_ctrl"]
    sales_user = sales_suite["sales_1"]
    user_data = {"id": sales_user.id, "department": "SALES"}

    contract = Contract(is_signed=False, sales_contact_id=sales_user.id)

    event = event_ctrl.create_event(
        user_data=user_data,
        event_data={},
        contract=contract
    )
    assert event is None


def test_support_can_update_assigned_event(sales_suite):
    """Verify support can update an event assigned to them (6.13)."""
    event_ctrl = sales_suite["event_ctrl"]
    supp_user = sales_suite["supp_user"]
    user_data = {"id": supp_user.id, "department": "SUPPORT"}

    # Setup: Create manual event assigned to supp_user
    new_event = event_ctrl.repository.add(Event(
        name="Update Test",
        event_date_start=datetime.now(),
        event_date_end=datetime.now(),
        location="Lyon",
        attendees=10,
        notes="Initial",
        client_id=1,
        contract_id=1,
        support_contact_id=supp_user.id
    ))

    updated = event_ctrl.update_event(
        user_data=user_data,
        event_id=new_event.id,
        updates={"notes": "Updated notes"}
    )

    assert updated is not None
    assert updated.notes == "Updated notes"


===============================================================================
    ./tests/test_integration_business_repos.py
===============================================================================
# tests/test_integration_business_repos.py
"""
Integration tests for Business Repositories (Client, Contract, Event).

Tests included:
- test_client_contract_event_chain: Verify the full creation chain with FKs.
- test_contract_integrity_violation: Verify error when client is missing.
- test_event_logic_queries: Verify business filters (unsigned, unpaid, etc.).
"""

import uuid
import pytest
from sqlalchemy.exc import IntegrityError
from app.repositories.client_repository import ClientRepository
from app.repositories.contract_repository import ContractRepository
from app.repositories.event_repository import EventRepository
from app.repositories.employee_repository import EmployeeRepository
from app.repositories.base_repository import BaseRepository
from app.models.department import Department
from app.models.employee import Employee
from app.models.client import Client
from app.models.contract import Contract
from app.models.event import Event
from datetime import datetime, timedelta


@pytest.fixture
def business_setup(db_session):
    """Fixture to provide staff and repositories for business integration."""
    dept_repo = BaseRepository(db_session, Department)
    emp_repo = EmployeeRepository(db_session)

    dept = dept_repo.add(Department(name=f"BIZ_{uuid.uuid4().hex[:6]}"))
    sales = emp_repo.add(Employee(
        full_name="Sales Rep",
        email=f"sales_{uuid.uuid4().hex[:6]}@epic.com",
        password="hash",
        employee_number=f"S_{uuid.uuid4().hex[:6]}",
        department_id=dept.id
    ))

    return {
        "sales": sales,
        "client_repo": ClientRepository(db_session),
        "contract_repo": ContractRepository(db_session),
        "event_repo": EventRepository(db_session)
    }


def test_client_contract_event_chain(business_setup):
    """Test the creation chain: Client -> Contract -> Event."""
    s = business_setup

    # 1. Create Client
    client = s["client_repo"].add(Client(
        full_name="Biz Client",
        email=f"biz_{uuid.uuid4().hex[:6]}@corp.com",
        phone="010203",
        company_name="BizCorp",
        sales_contact_id=s["sales"].id
    ))

    # 2. Create Contract
    contract = s["contract_repo"].add(Contract(
        total_amount=2000.0,
        remaining_amount=1000.0,
        is_signed=True,
        client_id=client.id,
        sales_contact_id=s["sales"].id
    ))

    # 3. Create Event
    event = s["event_repo"].add(Event(
        name="Biz Event",
        event_date_start=datetime.now(),
        event_date_end=datetime.now() + timedelta(hours=2),
        location="Paris",
        attendees=50,
        notes="Notes",
        client_id=client.id,
        contract_id=contract.id
    ))

    assert event.id is not None
    assert event.contract.total_amount == 2000.0
    assert event.client.full_name == "Biz Client"


def test_contract_integrity_violation(business_setup):
    """Verify that a contract cannot be created without a valid client."""
    s = business_setup
    invalid_contract = Contract(
        total_amount=100,
        remaining_amount=100,
        client_id=9999,  # Non-existent
        sales_contact_id=s["sales"].id
    )

    with pytest.raises(IntegrityError):
        s["contract_repo"].add(invalid_contract)


def test_event_logic_queries(business_setup):
    """Verify that specific repository filters return correct data."""
    s = business_setup

    # Create an unsigned contract
    client = s["client_repo"].add(Client(
        full_name="Filter Client",
        email=f"f_{uuid.uuid4().hex[:6]}@test.com",
        phone="0", company_name="F", sales_contact_id=s["sales"].id
    ))

    s["contract_repo"].add(Contract(
        total_amount=500, remaining_amount=500, is_signed=False,
        client_id=client.id, sales_contact_id=s["sales"].id
    ))

    unsigned = s["contract_repo"].get_unsigned_contracts()
    assert len(unsigned) >= 1
    assert any(c.is_signed is False for c in unsigned)

===============================================================================
    ./tests/test_integration_staff_repos.py
===============================================================================
# tests/test_integration_staff_repos.py
"""
Integration tests for Staff Repositories (Department & Employee).

Tests included:
- test_staff_creation_flow: Create a department then an employee linked to it.
- test_employee_unique_constraints_repo: Verify IntegrityError via Repository.
- test_department_lookup: Verify fetching department by name.
"""

import uuid
import pytest
from sqlalchemy.exc import IntegrityError
from app.repositories.department_repository import DepartmentRepository
from app.repositories.employee_repository import EmployeeRepository
from app.models.department import Department
from app.models.employee import Employee


@pytest.fixture
def staff_repos(db_session):
    """Fixture providing both staff repositories."""
    return DepartmentRepository(db_session), EmployeeRepository(db_session)


def test_staff_creation_flow(staff_repos):
    """Test full integration: creating a department and a linked employee."""
    dept_repo, emp_repo = staff_repos

    # 1. Create Department
    dept_name = f"DEPT_{uuid.uuid4().hex[:6]}"
    dept = Department(name=dept_name)
    dept_repo.add(dept)

    # 2. Create Employee linked to Dept
    emp_email = f"staff_{uuid.uuid4().hex[:6]}@epic.com"
    emp = Employee(
        full_name="Staff Member",
        email=emp_email,
        password="secure_hash",
        employee_number=f"EMP_{uuid.uuid4().hex[:6]}",
        department_id=dept.id
    )
    emp_repo.add(emp)

    # 3. Verify Integration
    fetched_emp = emp_repo.get_by_email(emp_email)
    assert fetched_emp.department.name == dept_name


def test_employee_unique_constraints_repo(staff_repos):
    """Verify that repositories correctly handle DB unique constraints."""
    dept_repo, emp_repo = staff_repos

    dept = Department(name=f"UNIQUE_DEPT_{uuid.uuid4().hex[:6]}")
    dept_repo.add(dept)

    shared_email = "duplicate@epic.com"
    emp1 = Employee(
        full_name="User 1", email=shared_email, password="h",
        employee_number="N1", department_id=dept.id
    )
    emp_repo.add(emp1)

    emp2 = Employee(
        full_name="User 2", email=shared_email, password="h",
        employee_number="N2", department_id=dept.id
    )

    with pytest.raises(IntegrityError):
        emp_repo.add(emp2)


def test_department_lookup(staff_repos):
    """Test the specific get_by_name method in DepartmentRepository."""
    dept_repo, _ = staff_repos
    name = "SUPPORT_TEAM"
    dept = Department(name=name)
    dept_repo.add(dept)

    found = dept_repo.get_by_name(name)
    assert found is not None
    assert found.id == dept.id

===============================================================================
    ./tests/test_jwt_handler.py
===============================================================================
# tests/test_jwt_handler.py
"""
Unit tests for JWT handler.

Tests included:
- test_create_and_decode_valid_token: Verify generation and decoding.
- test_decode_invalid_token: Ensure invalid strings return None.
- test_expired_token: Verify expiration logic returns None.
"""

import datetime
import jwt
from app.utils.jwt_handler import create_token, decode_token, SECRET_KEY, ALGORITHM


def test_create_and_decode_valid_token():
    """Verify that a generated token can be correctly decoded."""
    token = create_token(1, "Management")
    decoded = decode_token(token)

    assert decoded is not None
    assert decoded["sub"] == "1"
    assert decoded["department"] == "Management"


def test_decode_invalid_token():
    """Ensure that an invalid token returns None."""
    assert decode_token("invalid.token.string") is None


def test_expired_token():
    """Verify that an expired token returns None."""
    now = datetime.datetime.now(datetime.UTC)
    payload = {
        "sub": "1",
        "department": "Sales",
        "exp": int((now - datetime.timedelta(seconds=1)).timestamp())
    }
    expired_token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

    decoded = decode_token(expired_token)
    assert decoded is None

===============================================================================
    ./tests/test_logic_filters.py
===============================================================================
# tests/test_logic_filters.py
"""
Unit tests for specialized repository filtering logic.

Tests included:
- test_filter_unpaid_contracts: Verify only contracts with remaining_amount > 0 are returned.
- test_filter_events_without_support: Verify events with support_contact_id=None are returned.
- test_filter_unsigned_contracts: Verify only is_signed=False contracts are returned.
- test_filter_my_events: Verify support agents only see their assigned events.
"""

import uuid
import pytest
from datetime import datetime
from app.repositories.contract_repository import ContractRepository
from app.repositories.event_repository import EventRepository
from app.repositories.client_repository import ClientRepository
from app.repositories.employee_repository import EmployeeRepository
from app.repositories.base_repository import BaseRepository
from app.models.department import Department
from app.models.employee import Employee
from app.models.client import Client
from app.models.contract import Contract
from app.models.event import Event


@pytest.fixture
def filter_setup(db_session):
    """Setup a batch of data with various states for filtering tests."""
    dept_repo = BaseRepository(db_session, Department)
    emp_repo = EmployeeRepository(db_session)
    client_repo = ClientRepository(db_session)
    contract_repo = ContractRepository(db_session)

    dept = dept_repo.add(Department(name=f"FILT_{uuid.uuid4().hex[:6]}"))
    sales = emp_repo.add(Employee(
        full_name="Sales",
        email=f"s_{uuid.uuid4().hex[:6]}@test.com",
        password="h",
        employee_number=f"S{uuid.uuid4().hex[:4]}",
        department_id=dept.id
    ))
    support = emp_repo.add(Employee(
        full_name="Support",
        email=f"p_{uuid.uuid4().hex[:6]}@test.com",
        password="h",
        employee_number=f"P{uuid.uuid4().hex[:4]}",
        department_id=dept.id
    ))
    client = client_repo.add(Client(
        full_name="C",
        email=f"c_{uuid.uuid4().hex[:6]}@test.com",
        phone="0",
        company_name="C",
        sales_contact_id=sales.id
    ))
    # Create default contract for events
    contract = contract_repo.add(Contract(
        total_amount=1000,
        remaining_amount=500,
        is_signed=True,
        client_id=client.id,
        sales_contact_id=sales.id
    ))

    return {
        "db": db_session,
        "sales": sales,
        "support": support,
        "client": client,
        "contract": contract,
        "contract_repo": contract_repo,
        "event_repo": EventRepository(db_session)
    }


def test_filter_unpaid_contracts(filter_setup):
    """Verify that only contracts with a remaining balance are fetched."""
    repo = filter_setup["contract_repo"]
    client_id = filter_setup["client"].id
    sales_id = filter_setup["sales"].id

    repo.add(Contract(
        total_amount=1000, remaining_amount=0, is_signed=True,
        client_id=client_id, sales_contact_id=sales_id
    ))
    repo.add(Contract(
        total_amount=1000, remaining_amount=500, is_signed=True,
        client_id=client_id, sales_contact_id=sales_id
    ))

    unpaid = repo.get_unpaid_contracts()
    assert all(c.remaining_amount > 0 for c in unpaid)


def test_filter_events_without_support(filter_setup):
    """Verify that we can find events that need a support assignment."""
    repo = filter_setup["event_repo"]
    client_id = filter_setup["client"].id
    contract_id = filter_setup["contract"].id

    # Event with support
    repo.add(Event(
        name="E1", event_date_start=datetime.now(),
        event_date_end=datetime.now(), location="L", attendees=10,
        notes="N", client_id=client_id, contract_id=contract_id,
        support_contact_id=filter_setup["support"].id
    ))
    # Event without support
    repo.add(Event(
        name="E2", event_date_start=datetime.now(),
        event_date_end=datetime.now(), location="L", attendees=10,
        notes="N", client_id=client_id, contract_id=contract_id,
        support_contact_id=None
    ))

    no_support = repo.get_events_without_support()
    assert any(e.name == "E2" for e in no_support)
    assert all(e.support_contact_id is None for e in no_support)


def test_filter_unsigned_contracts(filter_setup):
    """Verify filtering of unsigned contracts."""
    repo = filter_setup["contract_repo"]
    client_id = filter_setup["client"].id
    sales_id = filter_setup["sales"].id

    repo.add(Contract(
        total_amount=100, remaining_amount=100, is_signed=False,
        client_id=client_id, sales_contact_id=sales_id
    ))

    unsigned = repo.get_unsigned_contracts()
    assert any(c.is_signed is False for c in unsigned)


def test_filter_my_events(filter_setup):
    """Verify support agents only see their assigned events."""
    repo = filter_setup["event_repo"]
    client_id = filter_setup["client"].id
    contract_id = filter_setup["contract"].id
    support_id = filter_setup["support"].id

    repo.add(Event(
        name="My Event", event_date_start=datetime.now(),
        event_date_end=datetime.now(), location="L", attendees=5,
        notes="N", client_id=client_id, contract_id=contract_id,
        support_contact_id=support_id
    ))

    my_events = repo.get_my_events(support_id)
    assert all(e.support_contact_id == support_id for e in my_events)

===============================================================================
    ./tests/test_models_business.py
===============================================================================
# tests/test_models_business.py
"""
Unit tests for Business models (Client, Contract, and Event).

Tests included:
- test_create_client: Verify client creation and relationship with sales.
- test_create_contract: Verify contract linked to client and sales contact.
- test_create_event: Verify event linked to contract, client and support.
- test_client_email_uniqueness: Ensure client emails are unique.
"""

import uuid
from datetime import datetime, timedelta
import pytest
from sqlalchemy.exc import IntegrityError
from app.models.department import Department
from app.models.employee import Employee
from app.models.client import Client
from app.models.contract import Contract
from app.models.event import Event


@pytest.fixture
def test_setup(db_session):
    """Fixture to provide a department and employees for business tests."""
    dept_sales = Department(name=f"SALES_{uuid.uuid4().hex[:6]}")
    dept_support = Department(name=f"SUPPORT_{uuid.uuid4().hex[:6]}")
    db_session.add_all([dept_sales, dept_support])
    db_session.commit()

    sales = Employee(
        full_name="Sales Guy",
        email=f"sales_{uuid.uuid4().hex[:6]}@epic.com",
        password="hash",
        employee_number=f"S_{uuid.uuid4().hex[:6]}",
        department_id=dept_sales.id
    )
    support = Employee(
        full_name="Support Guy",
        email=f"support_{uuid.uuid4().hex[:6]}@epic.com",
        password="hash",
        employee_number=f"SUP_{uuid.uuid4().hex[:6]}",
        department_id=dept_support.id
    )
    db_session.add_all([sales, support])
    db_session.commit()
    return sales, support


def test_create_client(db_session, test_setup):
    """Test client creation linked to a sales employee."""
    sales, _ = test_setup
    unique_email = f"client_{uuid.uuid4().hex[:6]}@corp.com"
    client = Client(
        full_name="Alice Client",
        email=unique_email,
        phone="0123456789",
        company_name="Alice Corp",
        sales_contact_id=sales.id
    )
    db_session.add(client)
    db_session.commit()

    assert client.id is not None
    assert client.sales_contact.full_name == "Sales Guy"
    assert str(client) == "<Client(name=Alice Client, company=Alice Corp)>"


def test_create_contract(db_session, test_setup):
    """Test contract creation with amounts and signature status."""
    sales, _ = test_setup
    client = Client(
        full_name="Contract Client",
        email=f"c_{uuid.uuid4().hex[:6]}@test.com",
        phone="000",
        company_name="C-Corp",
        sales_contact_id=sales.id
    )
    db_session.add(client)
    db_session.commit()

    contract = Contract(
        total_amount=1000.50,
        remaining_amount=500.00,
        is_signed=True,
        client_id=client.id,
        sales_contact_id=sales.id
    )
    db_session.add(contract)
    db_session.commit()

    assert contract.id is not None
    assert float(contract.total_amount) == 1000.50
    assert contract.client.full_name == "Contract Client"


def test_create_event(db_session, test_setup):
    """Test full event chain link: Client -> Contract -> Event."""
    sales, support = test_setup
    client = Client(
        full_name="Event Client",
        email=f"e_{uuid.uuid4().hex[:6]}@event.com",
        phone="111",
        company_name="E-Events",
        sales_contact_id=sales.id
    )
    db_session.add(client)
    db_session.commit()

    contract = Contract(
        total_amount=5000,
        remaining_amount=0,
        is_signed=True,
        client_id=client.id,
        sales_contact_id=sales.id
    )
    db_session.add(contract)
    db_session.commit()

    start_date = datetime.now() + timedelta(days=7)
    event = Event(
        name="Epic Party",
        event_date_start=start_date,
        event_date_end=start_date + timedelta(hours=5),
        location="Paris",
        attendees=100,
        notes="Important event",
        client_id=client.id,
        contract_id=contract.id,
        support_contact_id=support.id
    )
    db_session.add(event)
    db_session.commit()

    assert event.id is not None
    assert event.contract.is_signed is True
    assert event.support_contact.full_name == "Support Guy"


def test_client_email_uniqueness(db_session, test_setup):
    """Verify that two clients cannot share the same email."""
    sales, _ = test_setup
    email = "duplicate@test.com"
    c1 = Client(
        full_name="C1", email=email, phone="1",
        company_name="A", sales_contact_id=sales.id
    )
    db_session.add(c1)
    db_session.commit()

    c2 = Client(
        full_name="C2", email=email, phone="2",
        company_name="B", sales_contact_id=sales.id
    )
    db_session.add(c2)
    with pytest.raises(IntegrityError):
        db_session.commit()
    db_session.rollback()

===============================================================================
    ./tests/test_models_staff.py
===============================================================================
# tests/test_models_staff.py
"""
Unit tests for Staff models (Department and Employee).

Tests included:
- test_create_department: Validate department creation with unique names.
- test_department_unique_name: Ensure department names are unique.
- test_create_employee: Validate employee creation and relations.
- test_employee_unique_constraints: Validate email and employee_number uniqueness.
"""

import uuid
import pytest
from sqlalchemy.exc import IntegrityError
from app.models.department import Department
from app.models.employee import Employee


def test_create_department(db_session):
    """Test creating a department and its representation."""
    unique_name = f"DEPT_{uuid.uuid4().hex[:8]}"
    dept = Department(name=unique_name)
    db_session.add(dept)
    db_session.commit()

    assert dept.id is not None
    assert str(dept) == f"<Department(name={unique_name})>"


def test_department_unique_name(db_session):
    """Ensure that two departments cannot have the same name."""
    unique_name = f"UNIQUE_{uuid.uuid4().hex[:8]}"
    dept1 = Department(name=unique_name)
    db_session.add(dept1)
    db_session.commit()

    dept2 = Department(name=unique_name)
    db_session.add(dept2)
    with pytest.raises(IntegrityError):
        db_session.commit()
    db_session.rollback()


def test_create_employee(db_session):
    """Test creating an employee associated with a department."""
    unique_dept = f"SUPPORT_{uuid.uuid4().hex[:8]}"
    dept = Department(name=unique_dept)
    db_session.add(dept)
    db_session.commit()

    unique_email = f"user_{uuid.uuid4().hex[:8]}@test.com"
    emp = Employee(
        full_name="John Doe",
        email=unique_email,
        password="hashed_password",
        employee_number=f"EMP_{uuid.uuid4().hex[:8]}",
        department_id=dept.id
    )
    db_session.add(emp)
    db_session.commit()

    assert emp.id is not None
    assert emp.department.name == unique_dept


def test_employee_unique_constraints(db_session):
    """Test uniqueness of email and employee_number."""
    dept = Department(name=f"ADMIN_{uuid.uuid4().hex[:8]}")
    db_session.add(dept)
    db_session.commit()

    email = f"same_{uuid.uuid4().hex[:8]}@test.com"
    emp1 = Employee(
        full_name="User 1",
        email=email,
        password="pwd",
        employee_number="ID_STATIC",
        department_id=dept.id
    )
    db_session.add(emp1)
    db_session.commit()

    # Duplicate email
    emp2 = Employee(
        full_name="User 2",
        email=email,
        password="pwd",
        employee_number="ID_NEW",
        department_id=dept.id
    )
    db_session.add(emp2)
    with pytest.raises(IntegrityError):
        db_session.commit()
    db_session.rollback()


===============================================================================
    ./tests/test_permissions.py
===============================================================================
# tests/test_permissions.py
"""
Unit tests for the authorization system.

Tests included:
- test_management_permissions: Validate all actions for MANAGEMENT.
- test_sales_permissions: Validate allowed and restricted actions for SALES.
- test_support_permissions: Validate allowed and restricted actions for SUPPORT.
- test_unknown_department_permissions: Ensure unknown departments have no access.
"""

from app.utils.permissions import has_permission


def test_management_permissions():
    """Verify that MANAGEMENT has all its assigned permissions."""
    dept = "MANAGEMENT"
    assert has_permission("create_employee", dept) is True
    assert has_permission("delete_employee", dept) is True
    assert has_permission("update_contract", dept) is True


def test_sales_permissions():
    """Verify SALES permissions and restrictions."""
    dept = "SALES"
    # Allowed
    assert has_permission("create_client", dept) is True
    assert has_permission("create_event", dept) is True
    # Restricted
    assert has_permission("create_employee", dept) is False
    assert has_permission("delete_employee", dept) is False


def test_support_permissions():
    """Verify SUPPORT permissions and restrictions."""
    dept = "SUPPORT"
    # Allowed
    assert has_permission("read_event", dept) is True
    assert has_permission("update_event", dept) is True
    # Restricted
    assert has_permission("create_client", dept) is False
    assert has_permission("create_contract", dept) is False


def test_unknown_department_permissions():
    """Ensure that a non-existent department has no permissions."""
    assert has_permission("read_client", "GHOST_DEPT") is False

===============================================================================
    ./tests/test_repositories.py
===============================================================================
# tests/test_repositories.py
"""
Unit tests for Repositories.

Tests included:
- test_employee_repo_get_by_email: Verify lookup by email.
- test_employee_repo_add: Verify adding an employee via repo.
- test_repo_rollback_on_error: Ensure BaseRepository rolls back on failure.
"""

import uuid
import pytest
from sqlalchemy.exc import IntegrityError
from app.models.employee import Employee
from app.models.department import Department
from app.repositories.employee_repository import EmployeeRepository


@pytest.fixture
def employee_repo(db_session):
    """Fixture to provide the employee repository."""
    return EmployeeRepository(db_session)


def test_employee_repo_add(employee_repo, db_session):
    """Test adding an employee using the repository method."""
    # Setup department
    dept = Department(name=f"TECH_{uuid.uuid4().hex[:6]}")
    db_session.add(dept)
    db_session.commit()

    emp = Employee(
        full_name="Test Repo",
        email=f"repo_{uuid.uuid4().hex[:6]}@test.com",
        password="hash",
        employee_number=f"ID_{uuid.uuid4().hex[:6]}",
        department_id=dept.id
    )

    # Action via le repository
    employee_repo.add(emp)

    # Verification
    fetched = employee_repo.get_by_id(emp.id)
    assert fetched is not None
    assert fetched.full_name == "Test Repo"


def test_employee_repo_get_by_email(employee_repo, db_session):
    """Test finding an employee by email via the repository."""
    dept = Department(name=f"HR_{uuid.uuid4().hex[:6]}")
    db_session.add(dept)
    db_session.commit()

    email = f"findme_{uuid.uuid4().hex[:6]}@test.com"
    emp = Employee(
        full_name="Search Target",
        email=email,
        password="hash",
        employee_number=f"SN_{uuid.uuid4().hex[:6]}",
        department_id=dept.id
    )
    employee_repo.add(emp)

    found = employee_repo.get_by_email(email)
    assert found is not None
    assert found.id == emp.id


def test_repo_rollback_on_error(employee_repo, db_session):
    """Verify that BaseRepository handles IntegrityError and rolls back."""
    dept = Department(name=f"VOID_{uuid.uuid4().hex[:6]}")
    db_session.add(dept)
    db_session.commit()

    email = "duplicate@test.com"
    emp1 = Employee(
        full_name="User 1", email=email, password="h",
        employee_number="N1", department_id=dept.id
    )
    employee_repo.add(emp1)

    emp2 = Employee(
        full_name="User 2", email=email, password="h",
        employee_number="N2", department_id=dept.id
    )

    # Le BaseRepository doit lever l'erreur et faire le rollback
    with pytest.raises(IntegrityError):
        employee_repo.add(emp2)

===============================================================================
    ./tests/test_robustness_edge_cases.py
===============================================================================
"""
Integration tests for edge cases, permission denials, and repository exceptions.

List of tests:
- test_auth_controller_full_flow: Covers logout and failed login logic.
- test_client_controller_unauthorized: Covers permission denial branches.
- test_contract_controller_ownership: Covers ownership and not found logic.
- test_event_controller_complex_rules: Covers unsigned contracts and support.
- test_employee_management_denials: Covers admin-only creation/update logic.
- test_repository_integrity_failure: Covers DB constraints and rollbacks.
- test_models_string_representation: Covers __repr__ methods for all models.
"""

from datetime import datetime
import pytest
from sqlalchemy.exc import IntegrityError
from app.controllers.auth_controller import AuthController
from app.controllers.client_controller import ClientController
from app.controllers.contract_controller import ContractController
from app.controllers.event_controller import EventController
from app.controllers.employee_controller import EmployeeController
from app.repositories.employee_repository import EmployeeRepository
from app.repositories.client_repository import ClientRepository
from app.repositories.contract_repository import ContractRepository
from app.repositories.event_repository import EventRepository
from app.models.employee import Employee
from app.models.client import Client
from app.models.contract import Contract
from app.models.event import Event
from app.models.department import Department


@pytest.fixture
def auth_ctrl(db_session):
    """Fixture for AuthController."""
    return AuthController(EmployeeRepository(db_session))


def test_auth_controller_full_flow(auth_ctrl):
    """Covers logout and failed login logic."""
    auth_ctrl.logout()
    assert auth_ctrl.current_user_data is None
    assert auth_ctrl.login("ghost@missing.com", "password") is None
    assert auth_ctrl.check_user_permission("read") is False


def test_client_controller_unauthorized(db_session, auth_ctrl):
    """Covers permission denial branches."""
    client_repo = ClientRepository(db_session)
    ctrl = ClientController(client_repo, auth_ctrl)
    user_support = {"id": 1, "department": "SUPPORT"}
    assert ctrl.create_client(user_support, {"full_name": "Fail"}) in [None, []]
    user_sales = {"id": 2, "department": "SALES"}
    assert ctrl.update_client(user_sales, 9999, {"full_name": "New"}) in [None, []]


def test_contract_controller_ownership(db_session, auth_ctrl):
    """Covers ownership and not found logic."""
    contract_repo = ContractRepository(db_session)
    ctrl = ContractController(contract_repo, auth_ctrl)
    user_sales = {"id": 5, "department": "SALES"}

    # Create Department
    sales_dept = Department(name="SALES_OWN")
    db_session.add(sales_dept)
    db_session.flush()

    # Create two employees to avoid FK issues with sales_contact_id
    emp5 = Employee(
        id=5,
        full_name="Sales Guy",
        email="s5@t.com",
        password="password",
        employee_number="EMP005",
        department_id=sales_dept.id
    )
    emp10 = Employee(
        id=10,
        full_name="Other Sales",
        email="s10@t.com",
        password="password",
        employee_number="EMP010",
        department_id=sales_dept.id
    )
    db_session.add_all([emp5, emp10])
    db_session.flush()

    cl = Client(
        full_name="X",
        email="x@t.com",
        phone="1",
        company_name="X",
        sales_contact_id=5
    )
    db_session.add(cl)
    db_session.flush()

    other_contract = Contract(
        id=102,
        sales_contact_id=10,
        client_id=cl.id,
        total_amount=1000,
        remaining_amount=1000
    )
    db_session.add(other_contract)
    db_session.flush()
    assert ctrl.update_contract(user_sales, 102, {"total_amount": 2000}) in [None, []]


def test_event_controller_complex_rules(db_session, auth_ctrl):
    """Covers unsigned contracts and support assigned logic."""
    event_repo = EventRepository(db_session)
    ctrl = EventController(event_repo, auth_ctrl)

    sales_dept = Department(name="SALES_RULE")

